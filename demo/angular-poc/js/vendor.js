"format register";
System.register("github:angular-ui/bower-ui-grid@3.0.5/ui-grid", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    'use strict';
    angular.module('ui.grid.i18n', []);
    angular.module('ui.grid', ['ui.grid.i18n']);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').constant('uiGridConstants', {
      LOG_DEBUG_MESSAGES: true,
      LOG_WARN_MESSAGES: true,
      LOG_ERROR_MESSAGES: true,
      CUSTOM_FILTERS: /CUSTOM_FILTERS/g,
      COL_FIELD: /COL_FIELD/g,
      MODEL_COL_FIELD: /MODEL_COL_FIELD/g,
      TOOLTIP: /title=\"TOOLTIP\"/g,
      DISPLAY_CELL_TEMPLATE: /DISPLAY_CELL_TEMPLATE/g,
      TEMPLATE_REGEXP: /<.+>/,
      FUNC_REGEXP: /(\([^)]*\))?$/,
      DOT_REGEXP: /\./g,
      APOS_REGEXP: /'/g,
      BRACKET_REGEXP: /^(.*)((?:\s*\[\s*\d+\s*\]\s*)|(?:\s*\[\s*"(?:[^"\\]|\\.)*"\s*\]\s*)|(?:\s*\[\s*'(?:[^'\\]|\\.)*'\s*\]\s*))(.*)$/,
      COL_CLASS_PREFIX: 'ui-grid-col',
      events: {
        GRID_SCROLL: 'uiGridScroll',
        COLUMN_MENU_SHOWN: 'uiGridColMenuShown',
        ITEM_DRAGGING: 'uiGridItemDragStart',
        COLUMN_HEADER_CLICK: 'uiGridColumnHeaderClick'
      },
      keymap: {
        TAB: 9,
        STRG: 17,
        CAPSLOCK: 20,
        CTRL: 17,
        CTRLRIGHT: 18,
        CTRLR: 18,
        SHIFT: 16,
        RETURN: 13,
        ENTER: 13,
        BACKSPACE: 8,
        BCKSP: 8,
        ALT: 18,
        ALTR: 17,
        ALTRIGHT: 17,
        SPACE: 32,
        WIN: 91,
        MAC: 91,
        FN: null,
        PG_UP: 33,
        PG_DOWN: 34,
        UP: 38,
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39,
        ESC: 27,
        DEL: 46,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123
      },
      ASC: 'asc',
      DESC: 'desc',
      filter: {
        STARTS_WITH: 2,
        ENDS_WITH: 4,
        EXACT: 8,
        CONTAINS: 16,
        GREATER_THAN: 32,
        GREATER_THAN_OR_EQUAL: 64,
        LESS_THAN: 128,
        LESS_THAN_OR_EQUAL: 256,
        NOT_EQUAL: 512,
        SELECT: 'select',
        INPUT: 'input'
      },
      aggregationTypes: {
        sum: 2,
        count: 4,
        avg: 8,
        min: 16,
        max: 32
      },
      CURRENCY_SYMBOLS: ['ƒ', '$', '£', '$', '¤', '¥', '៛', '₩', '₱', '฿', '₫'],
      scrollDirection: {
        UP: 'up',
        DOWN: 'down',
        LEFT: 'left',
        RIGHT: 'right',
        NONE: 'none'
      },
      dataChange: {
        ALL: 'all',
        EDIT: 'edit',
        ROW: 'row',
        COLUMN: 'column',
        OPTIONS: 'options'
      },
      scrollbars: {
        NEVER: 0,
        ALWAYS: 1
      }
    });
  })();
  angular.module('ui.grid').directive('uiGridCell', ['$compile', '$parse', 'gridUtil', 'uiGridConstants', function($compile, $parse, gridUtil, uiGridConstants) {
    var uiGridCell = {
      priority: 0,
      scope: false,
      require: '?^uiGrid',
      compile: function() {
        return {
          pre: function($scope, $elm, $attrs, uiGridCtrl) {
            function compileTemplate() {
              var compiledElementFn = $scope.col.compiledElementFn;
              compiledElementFn($scope, function(clonedElement, scope) {
                $elm.append(clonedElement);
              });
            }
            if (uiGridCtrl && $scope.col.compiledElementFn) {
              compileTemplate();
            } else {
              if (uiGridCtrl && !$scope.col.compiledElementFn) {
                $scope.col.getCompiledElementFn().then(function(compiledElementFn) {
                  compiledElementFn($scope, function(clonedElement, scope) {
                    $elm.append(clonedElement);
                  });
                });
              } else {
                var html = $scope.col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, 'row.entity.' + gridUtil.preEval($scope.col.field)).replace(uiGridConstants.COL_FIELD, 'grid.getCellValue(row, col)');
                var cellElement = $compile(html)($scope);
                $elm.append(cellElement);
              }
            }
          },
          post: function($scope, $elm, $attrs, uiGridCtrl) {
            var initColClass = $scope.col.getColClass(false);
            $elm.addClass(initColClass);
            var classAdded;
            var updateClass = function(grid) {
              var contents = $elm;
              if (classAdded) {
                contents.removeClass(classAdded);
                classAdded = null;
              }
              if (angular.isFunction($scope.col.cellClass)) {
                classAdded = $scope.col.cellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
              } else {
                classAdded = $scope.col.cellClass;
              }
              contents.addClass(classAdded);
            };
            if ($scope.col.cellClass) {
              updateClass();
            }
            var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [uiGridConstants.dataChange.COLUMN, uiGridConstants.dataChange.EDIT]);
            var cellChangeFunction = function(n, o) {
              if (n !== o) {
                if (classAdded || $scope.col.cellClass) {
                  updateClass();
                }
                var newColClass = $scope.col.getColClass(false);
                if (newColClass !== initColClass) {
                  $elm.removeClass(initColClass);
                  $elm.addClass(newColClass);
                  initColClass = newColClass;
                }
              }
            };
            var rowWatchDereg = $scope.$watch('row', cellChangeFunction);
            var deregisterFunction = function() {
              dataChangeDereg();
              rowWatchDereg();
            };
            $scope.$on('$destroy', deregisterFunction);
            $elm.on('$destroy', deregisterFunction);
          }
        };
      }
    };
    return uiGridCell;
  }]);
  (function() {
    angular.module('ui.grid').service('uiGridColumnMenuService', ['i18nService', 'uiGridConstants', 'gridUtil', function(i18nService, uiGridConstants, gridUtil) {
      var service = {
        initialize: function($scope, uiGridCtrl) {
          $scope.grid = uiGridCtrl.grid;
          uiGridCtrl.columnMenuScope = $scope;
          $scope.menuShown = false;
        },
        setColMenuItemWatch: function($scope) {
          var deregFunction = $scope.$watch('col.menuItems', function(n, o) {
            if (typeof(n) !== 'undefined' && n && angular.isArray(n)) {
              n.forEach(function(item) {
                if (typeof(item.context) === 'undefined' || !item.context) {
                  item.context = {};
                }
                item.context.col = $scope.col;
              });
              $scope.menuItems = $scope.defaultMenuItems.concat(n);
            } else {
              $scope.menuItems = $scope.defaultMenuItems;
            }
          });
          $scope.$on('$destroy', deregFunction);
        },
        sortable: function($scope) {
          if ($scope.grid.options.enableSorting && typeof($scope.col) !== 'undefined' && $scope.col && $scope.col.enableSorting) {
            return true;
          } else {
            return false;
          }
        },
        isActiveSort: function($scope, direction) {
          return (typeof($scope.col) !== 'undefined' && typeof($scope.col.sort) !== 'undefined' && typeof($scope.col.sort.direction) !== 'undefined' && $scope.col.sort.direction === direction);
        },
        suppressRemoveSort: function($scope) {
          if ($scope.col && $scope.col.suppressRemoveSort) {
            return true;
          } else {
            return false;
          }
        },
        hideable: function($scope) {
          if (typeof($scope.col) !== 'undefined' && $scope.col && $scope.col.colDef && $scope.col.colDef.enableHiding === false) {
            return false;
          } else {
            return true;
          }
        },
        getDefaultMenuItems: function($scope) {
          return [{
            title: i18nService.getSafeText('sort.ascending'),
            icon: 'ui-grid-icon-sort-alt-up',
            action: function($event) {
              $event.stopPropagation();
              $scope.sortColumn($event, uiGridConstants.ASC);
            },
            shown: function() {
              return service.sortable($scope);
            },
            active: function() {
              return service.isActiveSort($scope, uiGridConstants.ASC);
            }
          }, {
            title: i18nService.getSafeText('sort.descending'),
            icon: 'ui-grid-icon-sort-alt-down',
            action: function($event) {
              $event.stopPropagation();
              $scope.sortColumn($event, uiGridConstants.DESC);
            },
            shown: function() {
              return service.sortable($scope);
            },
            active: function() {
              return service.isActiveSort($scope, uiGridConstants.DESC);
            }
          }, {
            title: i18nService.getSafeText('sort.remove'),
            icon: 'ui-grid-icon-cancel',
            action: function($event) {
              $event.stopPropagation();
              $scope.unsortColumn();
            },
            shown: function() {
              return service.sortable($scope) && typeof($scope.col) !== 'undefined' && (typeof($scope.col.sort) !== 'undefined' && typeof($scope.col.sort.direction) !== 'undefined') && $scope.col.sort.direction !== null && !service.suppressRemoveSort($scope);
            }
          }, {
            title: i18nService.getSafeText('column.hide'),
            icon: 'ui-grid-icon-cancel',
            shown: function() {
              return service.hideable($scope);
            },
            action: function($event) {
              $event.stopPropagation();
              $scope.hideColumn();
            }
          }, {
            title: i18nService.getSafeText('columnMenu.close'),
            screenReaderOnly: true,
            shown: function() {
              return true;
            },
            action: function($event) {
              $event.stopPropagation();
            }
          }];
        },
        getColumnElementPosition: function($scope, column, $columnElement) {
          var positionData = {};
          positionData.left = $columnElement[0].offsetLeft;
          positionData.top = $columnElement[0].offsetTop;
          positionData.parentLeft = $columnElement[0].offsetParent.offsetLeft;
          positionData.offset = 0;
          if (column.grid.options.offsetLeft) {
            positionData.offset = column.grid.options.offsetLeft;
          }
          positionData.height = gridUtil.elementHeight($columnElement, true);
          positionData.width = gridUtil.elementWidth($columnElement, true);
          return positionData;
        },
        repositionMenu: function($scope, column, positionData, $elm, $columnElement) {
          var menu = $elm[0].querySelectorAll('.ui-grid-menu');
          var containerId = column.renderContainer ? column.renderContainer : 'body';
          var renderContainer = column.grid.renderContainers[containerId];
          var renderContainerElm = gridUtil.closestElm($columnElement, '.ui-grid-render-container');
          var renderContainerOffset = renderContainerElm.getBoundingClientRect().left - $scope.grid.element[0].getBoundingClientRect().left;
          var containerScrollLeft = renderContainerElm.querySelectorAll('.ui-grid-viewport')[0].scrollLeft;
          var myWidth = column.lastMenuWidth ? column.lastMenuWidth : ($scope.lastMenuWidth ? $scope.lastMenuWidth : 170);
          var paddingRight = column.lastMenuPaddingRight ? column.lastMenuPaddingRight : ($scope.lastMenuPaddingRight ? $scope.lastMenuPaddingRight : 10);
          if (menu.length !== 0) {
            var mid = menu[0].querySelectorAll('.ui-grid-menu-mid');
            if (mid.length !== 0 && !angular.element(mid).hasClass('ng-hide')) {
              myWidth = gridUtil.elementWidth(menu, true);
              $scope.lastMenuWidth = myWidth;
              column.lastMenuWidth = myWidth;
              paddingRight = parseInt(gridUtil.getStyles(angular.element(menu)[0])['paddingRight'], 10);
              $scope.lastMenuPaddingRight = paddingRight;
              column.lastMenuPaddingRight = paddingRight;
            }
          }
          var left = positionData.left + renderContainerOffset - containerScrollLeft + positionData.parentLeft + positionData.width - myWidth + paddingRight;
          if (left < positionData.offset) {
            left = positionData.offset;
          }
          $elm.css('left', left + 'px');
          $elm.css('top', (positionData.top + positionData.height) + 'px');
        }
      };
      return service;
    }]).directive('uiGridColumnMenu', ['$timeout', 'gridUtil', 'uiGridConstants', 'uiGridColumnMenuService', '$document', function($timeout, gridUtil, uiGridConstants, uiGridColumnMenuService, $document) {
      var uiGridColumnMenu = {
        priority: 0,
        scope: true,
        require: '^uiGrid',
        templateUrl: 'ui-grid/uiGridColumnMenu',
        replace: true,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = this;
          uiGridColumnMenuService.initialize($scope, uiGridCtrl);
          $scope.defaultMenuItems = uiGridColumnMenuService.getDefaultMenuItems($scope);
          $scope.menuItems = $scope.defaultMenuItems;
          uiGridColumnMenuService.setColMenuItemWatch($scope);
          $scope.showMenu = function(column, $columnElement, event) {
            $scope.col = column;
            var colElementPosition = uiGridColumnMenuService.getColumnElementPosition($scope, column, $columnElement);
            if ($scope.menuShown) {
              $scope.colElement = $columnElement;
              $scope.colElementPosition = colElementPosition;
              $scope.hideThenShow = true;
              $scope.$broadcast('hide-menu', {originalEvent: event});
            } else {
              self.shown = $scope.menuShown = true;
              uiGridColumnMenuService.repositionMenu($scope, column, colElementPosition, $elm, $columnElement);
              $scope.colElement = $columnElement;
              $scope.colElementPosition = colElementPosition;
              $scope.$broadcast('show-menu', {originalEvent: event});
            }
          };
          $scope.hideMenu = function(broadcastTrigger) {
            $scope.menuShown = false;
            if (!broadcastTrigger) {
              $scope.$broadcast('hide-menu');
            }
          };
          $scope.$on('menu-hidden', function() {
            if ($scope.hideThenShow) {
              delete $scope.hideThenShow;
              uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
              $scope.$broadcast('show-menu');
              $scope.menuShown = true;
            } else {
              $scope.hideMenu(true);
              if ($scope.col) {
                gridUtil.focus.bySelector($document, '.ui-grid-header-cell.' + $scope.col.getColClass() + ' .ui-grid-column-menu-button', $scope.col.grid, false);
              }
            }
          });
          $scope.$on('menu-shown', function() {
            $timeout(function() {
              uiGridColumnMenuService.repositionMenu($scope, $scope.col, $scope.colElementPosition, $elm, $scope.colElement);
              delete $scope.colElementPosition;
              delete $scope.columnElement;
            }, 200);
          });
          $scope.sortColumn = function(event, dir) {
            event.stopPropagation();
            $scope.grid.sortColumn($scope.col, dir, true).then(function() {
              $scope.grid.refresh();
              $scope.hideMenu();
            });
          };
          $scope.unsortColumn = function() {
            $scope.col.unsort();
            $scope.grid.refresh();
            $scope.hideMenu();
          };
          var setFocusOnHideColumn = function() {
            $timeout(function() {
              var focusToGridMenu = function() {
                return gridUtil.focus.byId('grid-menu', $scope.grid);
              };
              var thisIndex;
              $scope.grid.columns.some(function(element, index) {
                if (angular.equals(element, $scope.col)) {
                  thisIndex = index;
                  return true;
                }
              });
              var previousVisibleCol;
              $scope.grid.columns.some(function(element, index) {
                if (!element.visible) {
                  return false;
                } else if (index < thisIndex) {
                  previousVisibleCol = element;
                } else if (index > thisIndex && !previousVisibleCol) {
                  previousVisibleCol = element;
                  return true;
                } else if (index > thisIndex && previousVisibleCol) {
                  return true;
                }
              });
              if (previousVisibleCol) {
                var colClass = previousVisibleCol.getColClass();
                gridUtil.focus.bySelector($document, '.ui-grid-header-cell.' + colClass + ' .ui-grid-header-cell-primary-focus', true).then(angular.noop, function(reason) {
                  if (reason !== 'canceled') {
                    return focusToGridMenu();
                  }
                });
              } else {
                focusToGridMenu();
              }
            });
          };
          $scope.hideColumn = function() {
            $scope.col.colDef.visible = false;
            $scope.col.visible = false;
            $scope.grid.queueGridRefresh();
            $scope.hideMenu();
            $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
            $scope.grid.api.core.raise.columnVisibilityChanged($scope.col);
            setFocusOnHideColumn();
          };
        },
        controller: ['$scope', function($scope) {
          var self = this;
          $scope.$watch('menuItems', function(n, o) {
            self.menuItems = n;
          });
        }]
      };
      return uiGridColumnMenu;
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridFilter', ['$compile', '$templateCache', 'i18nService', 'gridUtil', function($compile, $templateCache, i18nService, gridUtil) {
      return {compile: function() {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              $scope.col.updateFilters = function(filterable) {
                $elm.children().remove();
                if (filterable) {
                  var template = $scope.col.filterHeaderTemplate;
                  $elm.append($compile(template)($scope));
                }
              };
              $scope.$on('$destroy', function() {
                delete $scope.col.updateFilters;
              });
            },
            post: function($scope, $elm, $attrs, controllers) {
              $scope.aria = i18nService.getSafeText('headerCell.aria');
              $scope.removeFilter = function(colFilter, index) {
                colFilter.term = null;
                gridUtil.focus.bySelector($elm, '.ui-grid-filter-input-' + index);
              };
            }
          };
        }};
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridFooterCell', ['$timeout', 'gridUtil', 'uiGridConstants', '$compile', function($timeout, gridUtil, uiGridConstants, $compile) {
      var uiGridFooterCell = {
        priority: 0,
        scope: {
          col: '=',
          row: '=',
          renderIndex: '='
        },
        replace: true,
        require: '^uiGrid',
        compile: function compile(tElement, tAttrs, transclude) {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              var cellFooter = $compile($scope.col.footerCellTemplate)($scope);
              $elm.append(cellFooter);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {
              $scope.grid = uiGridCtrl.grid;
              var initColClass = $scope.col.getColClass(false);
              $elm.addClass(initColClass);
              var classAdded;
              var updateClass = function(grid) {
                var contents = $elm;
                if (classAdded) {
                  contents.removeClass(classAdded);
                  classAdded = null;
                }
                if (angular.isFunction($scope.col.footerCellClass)) {
                  classAdded = $scope.col.footerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                } else {
                  classAdded = $scope.col.footerCellClass;
                }
                contents.addClass(classAdded);
              };
              if ($scope.col.footerCellClass) {
                updateClass();
              }
              $scope.col.updateAggregationValue();
              var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateClass, [uiGridConstants.dataChange.COLUMN]);
              $scope.grid.api.core.on.rowsRendered($scope, $scope.col.updateAggregationValue);
              $scope.grid.api.core.on.rowsRendered($scope, updateClass);
              $scope.$on('$destroy', dataChangeDereg);
            }
          };
        }
      };
      return uiGridFooterCell;
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridFooter', ['$templateCache', '$compile', 'uiGridConstants', 'gridUtil', '$timeout', function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
      return {
        restrict: 'EA',
        replace: true,
        require: ['^uiGrid', '^uiGridRenderContainer'],
        scope: true,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              $scope.grid = uiGridCtrl.grid;
              $scope.colContainer = containerCtrl.colContainer;
              containerCtrl.footer = $elm;
              var footerTemplate = $scope.grid.options.footerTemplate;
              gridUtil.getTemplate(footerTemplate).then(function(contents) {
                var template = angular.element(contents);
                var newElm = $compile(template)($scope);
                $elm.append(newElm);
                if (containerCtrl) {
                  var footerViewport = $elm[0].getElementsByClassName('ui-grid-footer-viewport')[0];
                  if (footerViewport) {
                    containerCtrl.footerViewport = footerViewport;
                  }
                }
              });
            },
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              var grid = uiGridCtrl.grid;
              gridUtil.disableAnimations($elm);
              containerCtrl.footer = $elm;
              var footerViewport = $elm[0].getElementsByClassName('ui-grid-footer-viewport')[0];
              if (footerViewport) {
                containerCtrl.footerViewport = footerViewport;
              }
            }
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridGridFooter', ['$templateCache', '$compile', 'uiGridConstants', 'gridUtil', '$timeout', function($templateCache, $compile, uiGridConstants, gridUtil, $timeout) {
      return {
        restrict: 'EA',
        replace: true,
        require: '^uiGrid',
        scope: true,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              $scope.grid = uiGridCtrl.grid;
              var footerTemplate = $scope.grid.options.gridFooterTemplate;
              gridUtil.getTemplate(footerTemplate).then(function(contents) {
                var template = angular.element(contents);
                var newElm = $compile(template)($scope);
                $elm.append(newElm);
              });
            },
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridGroupPanel', ["$compile", "uiGridConstants", "gridUtil", function($compile, uiGridConstants, gridUtil) {
      var defaultTemplate = 'ui-grid/ui-grid-group-panel';
      return {
        restrict: 'EA',
        replace: true,
        require: '?^uiGrid',
        scope: false,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              var groupPanelTemplate = $scope.grid.options.groupPanelTemplate || defaultTemplate;
              gridUtil.getTemplate(groupPanelTemplate).then(function(contents) {
                var template = angular.element(contents);
                var newElm = $compile(template)($scope);
                $elm.append(newElm);
              });
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {
              $elm.bind('$destroy', function() {});
            }
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridHeaderCell', ['$compile', '$timeout', '$window', '$document', 'gridUtil', 'uiGridConstants', 'ScrollEvent', 'i18nService', function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, ScrollEvent, i18nService) {
      var mousedownTimeout = 500;
      var changeModeTimeout = 500;
      var uiGridHeaderCell = {
        priority: 0,
        scope: {
          col: '=',
          row: '=',
          renderIndex: '='
        },
        require: ['^uiGrid', '^uiGridRenderContainer'],
        replace: true,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs) {
              var cellHeader = $compile($scope.col.headerCellTemplate)($scope);
              $elm.append(cellHeader);
            },
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var renderContainerCtrl = controllers[1];
              $scope.i18n = {
                headerCell: i18nService.getSafeText('headerCell'),
                sort: i18nService.getSafeText('sort')
              };
              $scope.getSortDirectionAriaLabel = function() {
                var col = $scope.col;
                var sortDirectionText = col.sort.direction === uiGridConstants.ASC ? $scope.i18n.sort.ascending : (col.sort.direction === uiGridConstants.DESC ? $scope.i18n.sort.descending : $scope.i18n.sort.none);
                var label = sortDirectionText;
                if (col.sort.priority) {
                  label = label + '. ' + $scope.i18n.headerCell.priority + ' ' + col.sort.priority;
                }
                return label;
              };
              $scope.grid = uiGridCtrl.grid;
              $scope.renderContainer = uiGridCtrl.grid.renderContainers[renderContainerCtrl.containerId];
              var initColClass = $scope.col.getColClass(false);
              $elm.addClass(initColClass);
              $scope.menuShown = false;
              $scope.asc = uiGridConstants.ASC;
              $scope.desc = uiGridConstants.DESC;
              var $colMenu = angular.element($elm[0].querySelectorAll('.ui-grid-header-cell-menu'));
              var $contentsElm = angular.element($elm[0].querySelectorAll('.ui-grid-cell-contents'));
              var classAdded;
              var previousMouseX;
              var filterDeregisters = [];
              $scope.downFn = function(event) {
                event.stopPropagation();
                if (typeof(event.originalEvent) !== 'undefined' && event.originalEvent !== undefined) {
                  event = event.originalEvent;
                }
                if (event.button && event.button !== 0) {
                  return ;
                }
                previousMouseX = event.pageX;
                $scope.mousedownStartTime = (new Date()).getTime();
                $scope.mousedownTimeout = $timeout(function() {}, mousedownTimeout);
                $scope.mousedownTimeout.then(function() {
                  if ($scope.colMenu) {
                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm, event);
                  }
                });
                uiGridCtrl.fireEvent(uiGridConstants.events.COLUMN_HEADER_CLICK, {
                  event: event,
                  columnName: $scope.col.colDef.name
                });
                $scope.offAllEvents();
                if (event.type === 'touchstart') {
                  $document.on('touchend', $scope.upFn);
                  $document.on('touchmove', $scope.moveFn);
                } else if (event.type === 'mousedown') {
                  $document.on('mouseup', $scope.upFn);
                  $document.on('mousemove', $scope.moveFn);
                }
              };
              $scope.upFn = function(event) {
                event.stopPropagation();
                $timeout.cancel($scope.mousedownTimeout);
                $scope.offAllEvents();
                $scope.onDownEvents(event.type);
                var mousedownEndTime = (new Date()).getTime();
                var mousedownTime = mousedownEndTime - $scope.mousedownStartTime;
                if (mousedownTime > mousedownTimeout) {} else {
                  if ($scope.sortable) {
                    $scope.handleClick(event);
                  }
                }
              };
              $scope.moveFn = function(event) {
                var changeValue = event.pageX - previousMouseX;
                if (changeValue === 0) {
                  return ;
                }
                $timeout.cancel($scope.mousedownTimeout);
                $scope.offAllEvents();
                $scope.onDownEvents(event.type);
              };
              $scope.clickFn = function(event) {
                event.stopPropagation();
                $contentsElm.off('click', $scope.clickFn);
              };
              $scope.offAllEvents = function() {
                $contentsElm.off('touchstart', $scope.downFn);
                $contentsElm.off('mousedown', $scope.downFn);
                $document.off('touchend', $scope.upFn);
                $document.off('mouseup', $scope.upFn);
                $document.off('touchmove', $scope.moveFn);
                $document.off('mousemove', $scope.moveFn);
                $contentsElm.off('click', $scope.clickFn);
              };
              $scope.onDownEvents = function(type) {
                switch (type) {
                  case 'touchmove':
                  case 'touchend':
                    $contentsElm.on('click', $scope.clickFn);
                    $contentsElm.on('touchstart', $scope.downFn);
                    $timeout(function() {
                      $contentsElm.on('mousedown', $scope.downFn);
                    }, changeModeTimeout);
                    break;
                  case 'mousemove':
                  case 'mouseup':
                    $contentsElm.on('click', $scope.clickFn);
                    $contentsElm.on('mousedown', $scope.downFn);
                    $timeout(function() {
                      $contentsElm.on('touchstart', $scope.downFn);
                    }, changeModeTimeout);
                    break;
                  default:
                    $contentsElm.on('click', $scope.clickFn);
                    $contentsElm.on('touchstart', $scope.downFn);
                    $contentsElm.on('mousedown', $scope.downFn);
                }
              };
              var updateHeaderOptions = function(grid) {
                var contents = $elm;
                if (classAdded) {
                  contents.removeClass(classAdded);
                  classAdded = null;
                }
                if (angular.isFunction($scope.col.headerCellClass)) {
                  classAdded = $scope.col.headerCellClass($scope.grid, $scope.row, $scope.col, $scope.rowRenderIndex, $scope.colRenderIndex);
                } else {
                  classAdded = $scope.col.headerCellClass;
                }
                contents.addClass(classAdded);
                var rightMostContainer = $scope.grid.renderContainers['right'] ? $scope.grid.renderContainers['right'] : $scope.grid.renderContainers['body'];
                $scope.isLastCol = ($scope.col === rightMostContainer.visibleColumnCache[rightMostContainer.visibleColumnCache.length - 1]);
                if (uiGridCtrl.grid.options.enableSorting && $scope.col.enableSorting) {
                  $scope.sortable = true;
                } else {
                  $scope.sortable = false;
                }
                var oldFilterable = $scope.filterable;
                if (uiGridCtrl.grid.options.enableFiltering && $scope.col.enableFiltering) {
                  $scope.filterable = true;
                } else {
                  $scope.filterable = false;
                }
                if (oldFilterable !== $scope.filterable) {
                  if (typeof($scope.col.updateFilters) !== 'undefined') {
                    $scope.col.updateFilters($scope.filterable);
                  }
                  if ($scope.filterable) {
                    $scope.col.filters.forEach(function(filter, i) {
                      filterDeregisters.push($scope.$watch('col.filters[' + i + '].term', function(n, o) {
                        if (n !== o) {
                          uiGridCtrl.grid.api.core.raise.filterChanged();
                          uiGridCtrl.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
                          uiGridCtrl.grid.queueGridRefresh();
                        }
                      }));
                    });
                    $scope.$on('$destroy', function() {
                      filterDeregisters.forEach(function(filterDeregister) {
                        filterDeregister();
                      });
                    });
                  } else {
                    filterDeregisters.forEach(function(filterDeregister) {
                      filterDeregister();
                    });
                  }
                }
                if ($scope.col.grid.options && $scope.col.grid.options.enableColumnMenus !== false && $scope.col.colDef && $scope.col.colDef.enableColumnMenu !== false) {
                  $scope.colMenu = true;
                } else {
                  $scope.colMenu = false;
                }
                $scope.offAllEvents();
                if ($scope.sortable || $scope.colMenu) {
                  $scope.onDownEvents();
                  $scope.$on('$destroy', function() {
                    $scope.offAllEvents();
                  });
                }
              };
              updateHeaderOptions();
              var dataChangeDereg = $scope.grid.registerDataChangeCallback(updateHeaderOptions, [uiGridConstants.dataChange.COLUMN]);
              $scope.$on('$destroy', dataChangeDereg);
              $scope.handleClick = function(event) {
                var add = false;
                if (event.shiftKey) {
                  add = true;
                }
                uiGridCtrl.grid.sortColumn($scope.col, add).then(function() {
                  if (uiGridCtrl.columnMenuScope) {
                    uiGridCtrl.columnMenuScope.hideMenu();
                  }
                  uiGridCtrl.grid.refresh();
                });
              };
              $scope.toggleMenu = function(event) {
                event.stopPropagation();
                if (uiGridCtrl.columnMenuScope.menuShown) {
                  if (uiGridCtrl.columnMenuScope.col === $scope.col) {
                    uiGridCtrl.columnMenuScope.hideMenu();
                  } else {
                    uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                  }
                } else {
                  uiGridCtrl.columnMenuScope.showMenu($scope.col, $elm);
                }
              };
            }
          };
        }
      };
      return uiGridHeaderCell;
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridHeader', ['$templateCache', '$compile', 'uiGridConstants', 'gridUtil', '$timeout', 'ScrollEvent', function($templateCache, $compile, uiGridConstants, gridUtil, $timeout, ScrollEvent) {
      var defaultTemplate = 'ui-grid/ui-grid-header';
      var emptyTemplate = 'ui-grid/ui-grid-no-header';
      return {
        restrict: 'EA',
        replace: true,
        require: ['^uiGrid', '^uiGridRenderContainer'],
        scope: true,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              $scope.grid = uiGridCtrl.grid;
              $scope.colContainer = containerCtrl.colContainer;
              updateHeaderReferences();
              var headerTemplate;
              if (!$scope.grid.options.showHeader) {
                headerTemplate = emptyTemplate;
              } else {
                headerTemplate = ($scope.grid.options.headerTemplate) ? $scope.grid.options.headerTemplate : defaultTemplate;
              }
              gridUtil.getTemplate(headerTemplate).then(function(contents) {
                var template = angular.element(contents);
                var newElm = $compile(template)($scope);
                $elm.replaceWith(newElm);
                $elm = newElm;
                updateHeaderReferences();
                if (containerCtrl) {
                  var headerViewport = $elm[0].getElementsByClassName('ui-grid-header-viewport')[0];
                  if (headerViewport) {
                    containerCtrl.headerViewport = headerViewport;
                    angular.element(headerViewport).on('scroll', scrollHandler);
                    $scope.$on('$destroy', function() {
                      angular.element(headerViewport).off('scroll', scrollHandler);
                    });
                  }
                }
                $scope.grid.queueRefresh();
              });
              function updateHeaderReferences() {
                containerCtrl.header = containerCtrl.colContainer.header = $elm;
                var headerCanvases = $elm[0].getElementsByClassName('ui-grid-header-canvas');
                if (headerCanvases.length > 0) {
                  containerCtrl.headerCanvas = containerCtrl.colContainer.headerCanvas = headerCanvases[0];
                } else {
                  containerCtrl.headerCanvas = null;
                }
              }
              function scrollHandler(evt) {
                if (uiGridCtrl.grid.isScrollingHorizontally) {
                  return ;
                }
                var newScrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.headerViewport, uiGridCtrl.grid);
                var horizScrollPercentage = containerCtrl.colContainer.scrollHorizontal(newScrollLeft);
                var scrollEvent = new ScrollEvent(uiGridCtrl.grid, null, containerCtrl.colContainer, ScrollEvent.Sources.ViewPortScroll);
                scrollEvent.newScrollLeft = newScrollLeft;
                if (horizScrollPercentage > -1) {
                  scrollEvent.x = {percentage: horizScrollPercentage};
                }
                uiGridCtrl.grid.scrollContainers(null, scrollEvent);
              }
            },
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              var grid = uiGridCtrl.grid;
              gridUtil.disableAnimations($elm);
              function updateColumnWidths() {
                var columnCache = containerCtrl.colContainer.visibleColumnCache;
                var ret = '';
                var canvasWidth = 0;
                columnCache.forEach(function(column) {
                  ret = ret + column.getColClassDefinition();
                  canvasWidth += column.drawnWidth;
                });
                containerCtrl.colContainer.canvasWidth = canvasWidth;
                return ret;
              }
              containerCtrl.header = $elm;
              var headerViewport = $elm[0].getElementsByClassName('ui-grid-header-viewport')[0];
              if (headerViewport) {
                containerCtrl.headerViewport = headerViewport;
              }
              if (uiGridCtrl) {
                uiGridCtrl.grid.registerStyleComputation({
                  priority: 15,
                  func: updateColumnWidths
                });
              }
            }
          };
        }
      };
    }]);
  })();
  (function() {
    angular.module('ui.grid').service('uiGridGridMenuService', ['gridUtil', 'i18nService', 'uiGridConstants', function(gridUtil, i18nService, uiGridConstants) {
      var service = {
        initialize: function($scope, grid) {
          grid.gridMenuScope = $scope;
          $scope.grid = grid;
          $scope.registeredMenuItems = [];
          $scope.$on('$destroy', function() {
            if ($scope.grid && $scope.grid.gridMenuScope) {
              $scope.grid.gridMenuScope = null;
            }
            if ($scope.grid) {
              $scope.grid = null;
            }
            if ($scope.registeredMenuItems) {
              $scope.registeredMenuItems = null;
            }
          });
          $scope.registeredMenuItems = [];
          grid.api.registerMethod('core', 'addToGridMenu', service.addToGridMenu);
          grid.api.registerMethod('core', 'removeFromGridMenu', service.removeFromGridMenu);
        },
        addToGridMenu: function(grid, menuItems) {
          if (!angular.isArray(menuItems)) {
            gridUtil.logError('addToGridMenu: menuItems must be an array, and is not, not adding any items');
          } else {
            if (grid.gridMenuScope) {
              grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems ? grid.gridMenuScope.registeredMenuItems : [];
              grid.gridMenuScope.registeredMenuItems = grid.gridMenuScope.registeredMenuItems.concat(menuItems);
            } else {
              gridUtil.logError('Asked to addToGridMenu, but gridMenuScope not present.  Timing issue?  Please log issue with ui-grid');
            }
          }
        },
        removeFromGridMenu: function(grid, id) {
          var foundIndex = -1;
          if (grid && grid.gridMenuScope) {
            grid.gridMenuScope.registeredMenuItems.forEach(function(value, index) {
              if (value.id === id) {
                if (foundIndex > -1) {
                  gridUtil.logError('removeFromGridMenu: found multiple items with the same id, removing only the last');
                } else {
                  foundIndex = index;
                }
              }
            });
          }
          if (foundIndex > -1) {
            grid.gridMenuScope.registeredMenuItems.splice(foundIndex, 1);
          }
        },
        getMenuItems: function($scope) {
          var menuItems = [];
          if ($scope.grid.options.gridMenuCustomItems) {
            if (!angular.isArray($scope.grid.options.gridMenuCustomItems)) {
              gridUtil.logError('gridOptions.gridMenuCustomItems must be an array, and is not');
            } else {
              menuItems = menuItems.concat($scope.grid.options.gridMenuCustomItems);
            }
          }
          var clearFilters = [{
            title: i18nService.getSafeText('gridMenu.clearAllFilters'),
            action: function($event) {
              $scope.grid.clearAllFilters(undefined, true, undefined);
            },
            shown: function() {
              return $scope.grid.options.enableFiltering;
            },
            order: 100
          }];
          menuItems = menuItems.concat(clearFilters);
          menuItems = menuItems.concat($scope.registeredMenuItems);
          if ($scope.grid.options.gridMenuShowHideColumns !== false) {
            menuItems = menuItems.concat(service.showHideColumns($scope));
          }
          menuItems.sort(function(a, b) {
            return a.order - b.order;
          });
          return menuItems;
        },
        showHideColumns: function($scope) {
          var showHideColumns = [];
          if (!$scope.grid.options.columnDefs || $scope.grid.options.columnDefs.length === 0 || $scope.grid.columns.length === 0) {
            return showHideColumns;
          }
          showHideColumns.push({
            title: i18nService.getSafeText('gridMenu.columns'),
            order: 300
          });
          $scope.grid.options.gridMenuTitleFilter = $scope.grid.options.gridMenuTitleFilter ? $scope.grid.options.gridMenuTitleFilter : function(title) {
            return title;
          };
          $scope.grid.options.columnDefs.forEach(function(colDef, index) {
            if (colDef.enableHiding !== false) {
              var menuItem = {
                icon: 'ui-grid-icon-ok',
                action: function($event) {
                  $event.stopPropagation();
                  service.toggleColumnVisibility(this.context.gridCol);
                },
                shown: function() {
                  return this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined;
                },
                context: {gridCol: $scope.grid.getColumn(colDef.name || colDef.field)},
                leaveOpen: true,
                order: 301 + index * 2
              };
              service.setMenuItemTitle(menuItem, colDef, $scope.grid);
              showHideColumns.push(menuItem);
              menuItem = {
                icon: 'ui-grid-icon-cancel',
                action: function($event) {
                  $event.stopPropagation();
                  service.toggleColumnVisibility(this.context.gridCol);
                },
                shown: function() {
                  return !(this.context.gridCol.colDef.visible === true || this.context.gridCol.colDef.visible === undefined);
                },
                context: {gridCol: $scope.grid.getColumn(colDef.name || colDef.field)},
                leaveOpen: true,
                order: 301 + index * 2 + 1
              };
              service.setMenuItemTitle(menuItem, colDef, $scope.grid);
              showHideColumns.push(menuItem);
            }
          });
          return showHideColumns;
        },
        setMenuItemTitle: function(menuItem, colDef, grid) {
          var title = grid.options.gridMenuTitleFilter(colDef.displayName || gridUtil.readableColumnName(colDef.name) || colDef.field);
          if (typeof(title) === 'string') {
            menuItem.title = title;
          } else if (title.then) {
            menuItem.title = "";
            title.then(function(successValue) {
              menuItem.title = successValue;
            }, function(errorValue) {
              menuItem.title = errorValue;
            });
          } else {
            gridUtil.logError('Expected gridMenuTitleFilter to return a string or a promise, it has returned neither, bad config');
            menuItem.title = 'badconfig';
          }
        },
        toggleColumnVisibility: function(gridCol) {
          gridCol.colDef.visible = !(gridCol.colDef.visible === true || gridCol.colDef.visible === undefined);
          gridCol.grid.refresh();
          gridCol.grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
          gridCol.grid.api.core.raise.columnVisibilityChanged(gridCol);
        }
      };
      return service;
    }]).directive('uiGridMenuButton', ['gridUtil', 'uiGridConstants', 'uiGridGridMenuService', 'i18nService', function(gridUtil, uiGridConstants, uiGridGridMenuService, i18nService) {
      return {
        priority: 0,
        scope: true,
        require: ['^uiGrid'],
        templateUrl: 'ui-grid/ui-grid-menu-button',
        replace: true,
        link: function($scope, $elm, $attrs, controllers) {
          var uiGridCtrl = controllers[0];
          $scope.i18n = {aria: i18nService.getSafeText('gridMenu.aria')};
          uiGridGridMenuService.initialize($scope, uiGridCtrl.grid);
          $scope.shown = false;
          $scope.toggleMenu = function() {
            if ($scope.shown) {
              $scope.$broadcast('hide-menu');
              $scope.shown = false;
            } else {
              $scope.menuItems = uiGridGridMenuService.getMenuItems($scope);
              $scope.$broadcast('show-menu');
              $scope.shown = true;
            }
          };
          $scope.$on('menu-hidden', function() {
            $scope.shown = false;
            gridUtil.focus.bySelector($elm, '.ui-grid-icon-container');
          });
        }
      };
    }]);
  })();
  (function() {
    angular.module('ui.grid').directive('uiGridMenu', ['$compile', '$timeout', '$window', '$document', 'gridUtil', 'uiGridConstants', 'i18nService', function($compile, $timeout, $window, $document, gridUtil, uiGridConstants, i18nService) {
      var uiGridMenu = {
        priority: 0,
        scope: {
          menuItems: '=',
          autoHide: '=?'
        },
        require: '?^uiGrid',
        templateUrl: 'ui-grid/uiGridMenu',
        replace: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = this;
          var menuMid;
          var $animate;
          $scope.i18n = {close: i18nService.getSafeText('columnMenu.close')};
          self.showMenu = $scope.showMenu = function(event, args) {
            if (!$scope.shown) {
              $scope.shown = true;
              $timeout(function() {
                $scope.shownMid = true;
                $scope.$emit('menu-shown');
              });
            } else if (!$scope.shownMid) {
              $scope.shownMid = true;
              $scope.$emit('menu-shown');
            }
            var docEventType = 'click';
            if (args && args.originalEvent && args.originalEvent.type && args.originalEvent.type === 'touchstart') {
              docEventType = args.originalEvent.type;
            }
            angular.element(document).off('click touchstart', applyHideMenu);
            $timeout(function() {
              angular.element(document).on(docEventType, applyHideMenu);
            });
            gridUtil.focus.bySelector($elm, 'button[type=button]', true);
          };
          self.hideMenu = $scope.hideMenu = function(event, args) {
            if ($scope.shown) {
              $scope.shownMid = false;
              $timeout(function() {
                if (!$scope.shownMid) {
                  $scope.shown = false;
                  $scope.$emit('menu-hidden');
                }
              }, 200);
            }
            angular.element(document).off('click touchstart', applyHideMenu);
          };
          $scope.$on('hide-menu', function(event, args) {
            $scope.hideMenu(event, args);
          });
          $scope.$on('show-menu', function(event, args) {
            $scope.showMenu(event, args);
          });
          var applyHideMenu = function() {
            if ($scope.shown) {
              $scope.$apply(function() {
                $scope.hideMenu();
              });
            }
          };
          if (typeof($scope.autoHide) === 'undefined' || $scope.autoHide === undefined) {
            $scope.autoHide = true;
          }
          if ($scope.autoHide) {
            angular.element($window).on('resize', applyHideMenu);
          }
          $scope.$on('$destroy', function() {
            angular.element(document).off('click touchstart', applyHideMenu);
          });
          $scope.$on('$destroy', function() {
            angular.element($window).off('resize', applyHideMenu);
          });
          if (uiGridCtrl) {
            $scope.$on('$destroy', uiGridCtrl.grid.api.core.on.scrollBegin($scope, applyHideMenu));
          }
          $scope.$on('$destroy', $scope.$on(uiGridConstants.events.ITEM_DRAGGING, applyHideMenu));
        },
        controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
          var self = this;
        }]
      };
      return uiGridMenu;
    }]).directive('uiGridMenuItem', ['gridUtil', '$compile', 'i18nService', function(gridUtil, $compile, i18nService) {
      var uiGridMenuItem = {
        priority: 0,
        scope: {
          name: '=',
          active: '=',
          action: '=',
          icon: '=',
          shown: '=',
          context: '=',
          templateUrl: '=',
          leaveOpen: '=',
          screenReaderOnly: '='
        },
        require: ['?^uiGrid', '^uiGridMenu'],
        templateUrl: 'ui-grid/uiGridMenuItem',
        replace: false,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0],
                  uiGridMenuCtrl = controllers[1];
              if ($scope.templateUrl) {
                gridUtil.getTemplate($scope.templateUrl).then(function(contents) {
                  var template = angular.element(contents);
                  var newElm = $compile(template)($scope);
                  $elm.replaceWith(newElm);
                });
              }
            },
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0],
                  uiGridMenuCtrl = controllers[1];
              if (typeof($scope.shown) === 'undefined' || $scope.shown === null) {
                $scope.shown = function() {
                  return true;
                };
              }
              $scope.itemShown = function() {
                var context = {};
                if ($scope.context) {
                  context.context = $scope.context;
                }
                if (typeof(uiGridCtrl) !== 'undefined' && uiGridCtrl) {
                  context.grid = uiGridCtrl.grid;
                }
                return $scope.shown.call(context);
              };
              $scope.itemAction = function($event, title) {
                gridUtil.logDebug('itemAction');
                $event.stopPropagation();
                if (typeof($scope.action) === 'function') {
                  var context = {};
                  if ($scope.context) {
                    context.context = $scope.context;
                  }
                  if (typeof(uiGridCtrl) !== 'undefined' && uiGridCtrl) {
                    context.grid = uiGridCtrl.grid;
                  }
                  $scope.action.call(context, $event, title);
                  if (!$scope.leaveOpen) {
                    $scope.$emit('hide-menu');
                  } else {
                    gridUtil.focus.bySelector(angular.element(gridUtil.closestElm($elm, ".ui-grid-menu-items")), 'button[type=button]', true);
                  }
                }
              };
              $scope.i18n = i18nService.get();
            }
          };
        }
      };
      return uiGridMenuItem;
    }]);
  })();
  (function() {
    'use strict';
    var oneBinders = angular.module('ui.grid');
    angular.forEach([{
      tag: 'Src',
      method: 'attr'
    }, {
      tag: 'Text',
      method: 'text'
    }, {
      tag: 'Href',
      method: 'attr'
    }, {
      tag: 'Class',
      method: 'addClass'
    }, {
      tag: 'Html',
      method: 'html'
    }, {
      tag: 'Alt',
      method: 'attr'
    }, {
      tag: 'Style',
      method: 'css'
    }, {
      tag: 'Value',
      method: 'attr'
    }, {
      tag: 'Id',
      method: 'attr'
    }, {
      tag: 'Id',
      directiveName: 'IdGrid',
      method: 'attr',
      appendGridId: true
    }, {
      tag: 'Title',
      method: 'attr'
    }, {
      tag: 'Label',
      method: 'attr',
      aria: true
    }, {
      tag: 'Labelledby',
      method: 'attr',
      aria: true
    }, {
      tag: 'Labelledby',
      directiveName: 'LabelledbyGrid',
      appendGridId: true,
      method: 'attr',
      aria: true
    }, {
      tag: 'Describedby',
      method: 'attr',
      aria: true
    }, {
      tag: 'Describedby',
      directiveName: 'DescribedbyGrid',
      appendGridId: true,
      method: 'attr',
      aria: true
    }], function(v) {
      var baseDirectiveName = 'uiGridOneBind';
      var directiveName = (v.aria ? baseDirectiveName + 'Aria' : baseDirectiveName) + (v.directiveName ? v.directiveName : v.tag);
      oneBinders.directive(directiveName, ['gridUtil', function(gridUtil) {
        return {
          restrict: 'A',
          require: ['?uiGrid', '?^uiGrid'],
          link: function(scope, iElement, iAttrs, controllers) {
            var appendGridId = function(val) {
              var grid;
              if (scope.grid) {
                grid = scope.grid;
              } else if (scope.col && scope.col.grid) {
                grid = scope.col.grid;
              } else if (!controllers.some(function(controller) {
                if (controller && controller.grid) {
                  grid = controller.grid;
                  return true;
                }
              })) {
                gridUtil.logError("[" + directiveName + "] A valid grid could not be found to bind id. Are you using this directive " + "within the correct scope? Trying to generate id: [gridID]-" + val);
                throw new Error("No valid grid could be found");
              }
              if (grid) {
                var idRegex = new RegExp(grid.id.toString());
                if (!idRegex.test(val)) {
                  val = grid.id.toString() + '-' + val;
                }
              }
              return val;
            };
            var rmWatcher = scope.$watch(iAttrs[directiveName], function(newV) {
              if (newV) {
                if (v.appendGridId) {
                  var newIdString = null;
                  angular.forEach(newV.split(' '), function(s) {
                    newIdString = (newIdString ? (newIdString + ' ') : '') + appendGridId(s);
                  });
                  newV = newIdString;
                }
                switch (v.method) {
                  case 'attr':
                    if (v.aria) {
                      iElement[v.method]('aria-' + v.tag.toLowerCase(), newV);
                    } else {
                      iElement[v.method](v.tag.toLowerCase(), newV);
                    }
                    break;
                  case 'addClass':
                    if (angular.isObject(newV) && !angular.isArray(newV)) {
                      var results = [];
                      var nonNullFound = false;
                      angular.forEach(newV, function(value, index) {
                        if (value !== null && typeof(value) !== "undefined") {
                          nonNullFound = true;
                          if (value) {
                            results.push(index);
                          }
                        }
                      });
                      if (!nonNullFound) {
                        return ;
                      }
                      newV = results;
                    }
                    if (newV) {
                      iElement.addClass(angular.isArray(newV) ? newV.join(' ') : newV);
                    } else {
                      return ;
                    }
                    break;
                  default:
                    iElement[v.method](newV);
                    break;
                }
                rmWatcher();
              }
            }, true);
          }
        };
      }]);
    });
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid');
    module.directive('uiGridRenderContainer', ['$timeout', '$document', 'uiGridConstants', 'gridUtil', 'ScrollEvent', function($timeout, $document, uiGridConstants, gridUtil, ScrollEvent) {
      return {
        replace: true,
        transclude: true,
        templateUrl: 'ui-grid/uiGridRenderContainer',
        require: ['^uiGrid', 'uiGridRenderContainer'],
        scope: {
          containerId: '=',
          rowContainerName: '=',
          colContainerName: '=',
          bindScrollHorizontal: '=',
          bindScrollVertical: '=',
          enableVerticalScrollbar: '=',
          enableHorizontalScrollbar: '='
        },
        controller: 'uiGridRenderContainer as RenderContainer',
        compile: function() {
          return {
            pre: function prelink($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              var grid = $scope.grid = uiGridCtrl.grid;
              if (!$scope.rowContainerName) {
                throw "No row render container name specified";
              }
              if (!$scope.colContainerName) {
                throw "No column render container name specified";
              }
              if (!grid.renderContainers[$scope.rowContainerName]) {
                throw "Row render container '" + $scope.rowContainerName + "' is not registered.";
              }
              if (!grid.renderContainers[$scope.colContainerName]) {
                throw "Column render container '" + $scope.colContainerName + "' is not registered.";
              }
              var rowContainer = $scope.rowContainer = grid.renderContainers[$scope.rowContainerName];
              var colContainer = $scope.colContainer = grid.renderContainers[$scope.colContainerName];
              containerCtrl.containerId = $scope.containerId;
              containerCtrl.rowContainer = rowContainer;
              containerCtrl.colContainer = colContainer;
            },
            post: function postlink($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              var grid = uiGridCtrl.grid;
              var rowContainer = containerCtrl.rowContainer;
              var colContainer = containerCtrl.colContainer;
              var scrollTop = null;
              var scrollLeft = null;
              var renderContainer = grid.renderContainers[$scope.containerId];
              $elm.addClass('ui-grid-render-container-' + $scope.containerId);
              gridUtil.on.mousewheel($elm, function(event) {
                var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.RenderContainerMouseWheel);
                if (event.deltaY !== 0) {
                  var scrollYAmount = event.deltaY * -1 * event.deltaFactor;
                  scrollTop = containerCtrl.viewport[0].scrollTop;
                  scrollEvent.verticalScrollLength = rowContainer.getVerticalScrollLength();
                  var scrollYPercentage = (scrollTop + scrollYAmount) / scrollEvent.verticalScrollLength;
                  if (scrollYPercentage >= 1 && scrollTop < scrollEvent.verticalScrollLength) {
                    containerCtrl.viewport[0].scrollTop = scrollEvent.verticalScrollLength;
                  }
                  if (scrollYPercentage < 0) {
                    scrollYPercentage = 0;
                  } else if (scrollYPercentage > 1) {
                    scrollYPercentage = 1;
                  }
                  scrollEvent.y = {
                    percentage: scrollYPercentage,
                    pixels: scrollYAmount
                  };
                }
                if (event.deltaX !== 0) {
                  var scrollXAmount = event.deltaX * event.deltaFactor;
                  scrollLeft = gridUtil.normalizeScrollLeft(containerCtrl.viewport, grid);
                  scrollEvent.horizontalScrollLength = (colContainer.getCanvasWidth() - colContainer.getViewportWidth());
                  var scrollXPercentage = (scrollLeft + scrollXAmount) / scrollEvent.horizontalScrollLength;
                  if (scrollXPercentage < 0) {
                    scrollXPercentage = 0;
                  } else if (scrollXPercentage > 1) {
                    scrollXPercentage = 1;
                  }
                  scrollEvent.x = {
                    percentage: scrollXPercentage,
                    pixels: scrollXAmount
                  };
                }
                if ((event.deltaY !== 0 && (scrollEvent.atTop(scrollTop) || scrollEvent.atBottom(scrollTop))) || (event.deltaX !== 0 && (scrollEvent.atLeft(scrollLeft) || scrollEvent.atRight(scrollLeft)))) {} else {
                  event.preventDefault();
                  event.stopPropagation();
                  scrollEvent.fireThrottledScrollingEvent('', scrollEvent);
                }
              });
              $elm.bind('$destroy', function() {
                $elm.unbind('keydown');
                ['touchstart', 'touchmove', 'touchend', 'keydown', 'wheel', 'mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'].forEach(function(eventName) {
                  $elm.unbind(eventName);
                });
              });
              function update() {
                var ret = '';
                var canvasWidth = colContainer.canvasWidth;
                var viewportWidth = colContainer.getViewportWidth();
                var canvasHeight = rowContainer.getCanvasHeight();
                var viewportHeight = rowContainer.getViewportHeight();
                if (colContainer.needsHScrollbarPlaceholder()) {
                  viewportHeight -= grid.scrollbarHeight;
                }
                var headerViewportWidth,
                    footerViewportWidth;
                headerViewportWidth = footerViewportWidth = colContainer.getHeaderViewportWidth();
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-canvas { width: ' + canvasWidth + 'px; height: ' + canvasHeight + 'px; }';
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-header-canvas { width: ' + (canvasWidth + grid.scrollbarWidth) + 'px; }';
                if (renderContainer.explicitHeaderCanvasHeight) {
                  ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-header-canvas { height: ' + renderContainer.explicitHeaderCanvasHeight + 'px; }';
                } else {
                  ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-header-canvas { height: inherit; }';
                }
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-viewport { width: ' + viewportWidth + 'px; height: ' + viewportHeight + 'px; }';
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-header-viewport { width: ' + headerViewportWidth + 'px; }';
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-footer-canvas { width: ' + (canvasWidth + grid.scrollbarWidth) + 'px; }';
                ret += '\n .grid' + uiGridCtrl.grid.id + ' .ui-grid-render-container-' + $scope.containerId + ' .ui-grid-footer-viewport { width: ' + footerViewportWidth + 'px; }';
                return ret;
              }
              uiGridCtrl.grid.registerStyleComputation({
                priority: 6,
                func: update
              });
            }
          };
        }
      };
    }]);
    module.controller('uiGridRenderContainer', ['$scope', 'gridUtil', function($scope, gridUtil) {}]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridRow', ['gridUtil', function(gridUtil) {
      return {
        replace: true,
        require: ['^uiGrid', '^uiGridRenderContainer'],
        scope: {
          row: '=uiGridRow',
          rowRenderIndex: '='
        },
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var containerCtrl = controllers[1];
              var grid = uiGridCtrl.grid;
              $scope.grid = uiGridCtrl.grid;
              $scope.colContainer = containerCtrl.colContainer;
              var clonedElement,
                  cloneScope;
              function compileTemplate() {
                $scope.row.getRowTemplateFn.then(function(compiledElementFn) {
                  var newScope = $scope.$new();
                  compiledElementFn(newScope, function(newElm, scope) {
                    if (clonedElement) {
                      clonedElement.remove();
                      cloneScope.$destroy();
                    }
                    $elm.empty().append(newElm);
                    clonedElement = newElm;
                    cloneScope = newScope;
                  });
                });
              }
              compileTemplate();
              $scope.$watch('row.getRowTemplateFn', function(newFunc, oldFunc) {
                if (newFunc !== oldFunc) {
                  compileTemplate();
                }
              });
            },
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    angular.module('ui.grid').directive('uiGridStyle', ['gridUtil', '$interpolate', function(gridUtil, $interpolate) {
      return {link: function($scope, $elm, $attrs, uiGridCtrl) {
          var interpolateFn = $interpolate($elm.text(), true);
          if (interpolateFn) {
            $scope.$watch(interpolateFn, function(value) {
              $elm.text(value);
            });
          }
        }};
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridViewport', ['gridUtil', 'ScrollEvent', 'uiGridConstants', '$log', function(gridUtil, ScrollEvent, uiGridConstants, $log) {
      return {
        replace: true,
        scope: {},
        controllerAs: 'Viewport',
        templateUrl: 'ui-grid/uiGridViewport',
        require: ['^uiGrid', '^uiGridRenderContainer'],
        link: function($scope, $elm, $attrs, controllers) {
          var uiGridCtrl = controllers[0];
          var containerCtrl = controllers[1];
          $scope.containerCtrl = containerCtrl;
          var rowContainer = containerCtrl.rowContainer;
          var colContainer = containerCtrl.colContainer;
          var grid = uiGridCtrl.grid;
          $scope.grid = uiGridCtrl.grid;
          $scope.rowContainer = containerCtrl.rowContainer;
          $scope.colContainer = containerCtrl.colContainer;
          containerCtrl.viewport = $elm;
          $elm.on('scroll', scrollHandler);
          var ignoreScroll = false;
          function scrollHandler(evt) {
            var newScrollTop = $elm[0].scrollTop;
            var newScrollLeft = gridUtil.normalizeScrollLeft($elm, grid);
            var vertScrollPercentage = rowContainer.scrollVertical(newScrollTop);
            var horizScrollPercentage = colContainer.scrollHorizontal(newScrollLeft);
            var scrollEvent = new ScrollEvent(grid, rowContainer, colContainer, ScrollEvent.Sources.ViewPortScroll);
            scrollEvent.newScrollLeft = newScrollLeft;
            scrollEvent.newScrollTop = newScrollTop;
            if (horizScrollPercentage > -1) {
              scrollEvent.x = {percentage: horizScrollPercentage};
            }
            if (vertScrollPercentage > -1) {
              scrollEvent.y = {percentage: vertScrollPercentage};
            }
            grid.scrollContainers($scope.$parent.containerId, scrollEvent);
          }
          if ($scope.$parent.bindScrollVertical) {
            grid.addVerticalScrollSync($scope.$parent.containerId, syncVerticalScroll);
          }
          if ($scope.$parent.bindScrollHorizontal) {
            grid.addHorizontalScrollSync($scope.$parent.containerId, syncHorizontalScroll);
            grid.addHorizontalScrollSync($scope.$parent.containerId + 'header', syncHorizontalHeader);
            grid.addHorizontalScrollSync($scope.$parent.containerId + 'footer', syncHorizontalFooter);
          }
          function syncVerticalScroll(scrollEvent) {
            containerCtrl.prevScrollArgs = scrollEvent;
            var newScrollTop = scrollEvent.getNewScrollTop(rowContainer, containerCtrl.viewport);
            $elm[0].scrollTop = newScrollTop;
          }
          function syncHorizontalScroll(scrollEvent) {
            containerCtrl.prevScrollArgs = scrollEvent;
            var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
            $elm[0].scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
          }
          function syncHorizontalHeader(scrollEvent) {
            var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
            if (containerCtrl.headerViewport) {
              containerCtrl.headerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
            }
          }
          function syncHorizontalFooter(scrollEvent) {
            var newScrollLeft = scrollEvent.getNewScrollLeft(colContainer, containerCtrl.viewport);
            if (containerCtrl.footerViewport) {
              containerCtrl.footerViewport.scrollLeft = gridUtil.denormalizeScrollLeft(containerCtrl.viewport, newScrollLeft, grid);
            }
          }
        },
        controller: ['$scope', function($scope) {
          this.rowStyle = function(index) {
            var rowContainer = $scope.rowContainer;
            var colContainer = $scope.colContainer;
            var styles = {};
            if (index === 0 && rowContainer.currentTopRow !== 0) {
              var hiddenRowWidth = (rowContainer.currentTopRow) * rowContainer.grid.options.rowHeight;
              styles['margin-top'] = hiddenRowWidth + 'px';
            }
            if (colContainer.currentFirstColumn !== 0) {
              if (colContainer.grid.isRTL()) {
                styles['margin-right'] = colContainer.columnOffset + 'px';
              } else {
                styles['margin-left'] = colContainer.columnOffset + 'px';
              }
            }
            return styles;
          };
        }]
      };
    }]);
  })();
  (function() {
    angular.module('ui.grid').directive('uiGridVisible', function uiGridVisibleAction() {
      return function($scope, $elm, $attr) {
        $scope.$watch($attr.uiGridVisible, function(visible) {
          $elm[visible ? 'removeClass' : 'addClass']('ui-grid-invisible');
        });
      };
    });
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').controller('uiGridController', ['$scope', '$element', '$attrs', 'gridUtil', '$q', 'uiGridConstants', '$templateCache', 'gridClassFactory', '$timeout', '$parse', '$compile', function($scope, $elm, $attrs, gridUtil, $q, uiGridConstants, $templateCache, gridClassFactory, $timeout, $parse, $compile) {
      var self = this;
      self.grid = gridClassFactory.createGrid($scope.uiGrid);
      self.grid.appScope = self.grid.appScope || $scope.$parent;
      $elm.addClass('grid' + self.grid.id);
      self.grid.rtl = gridUtil.getStyles($elm[0])['direction'] === 'rtl';
      $scope.grid = self.grid;
      if ($attrs.uiGridColumns) {
        $attrs.$observe('uiGridColumns', function(value) {
          self.grid.options.columnDefs = value;
          self.grid.buildColumns().then(function() {
            self.grid.preCompileCellTemplates();
            self.grid.refreshCanvas(true);
          });
        });
      }
      var deregFunctions = [];
      if (self.grid.options.fastWatch) {
        self.uiGrid = $scope.uiGrid;
        if (angular.isString($scope.uiGrid.data)) {
          deregFunctions.push($scope.$parent.$watch($scope.uiGrid.data, dataWatchFunction));
          deregFunctions.push($scope.$parent.$watch(function() {
            if (self.grid.appScope[$scope.uiGrid.data]) {
              return self.grid.appScope[$scope.uiGrid.data].length;
            } else {
              return undefined;
            }
          }, dataWatchFunction));
        } else {
          deregFunctions.push($scope.$parent.$watch(function() {
            return $scope.uiGrid.data;
          }, dataWatchFunction));
          deregFunctions.push($scope.$parent.$watch(function() {
            return $scope.uiGrid.data.length;
          }, dataWatchFunction));
        }
        deregFunctions.push($scope.$parent.$watch(function() {
          return $scope.uiGrid.columnDefs;
        }, columnDefsWatchFunction));
        deregFunctions.push($scope.$parent.$watch(function() {
          return $scope.uiGrid.columnDefs.length;
        }, columnDefsWatchFunction));
      } else {
        if (angular.isString($scope.uiGrid.data)) {
          deregFunctions.push($scope.$parent.$watchCollection($scope.uiGrid.data, dataWatchFunction));
        } else {
          deregFunctions.push($scope.$parent.$watchCollection(function() {
            return $scope.uiGrid.data;
          }, dataWatchFunction));
        }
        deregFunctions.push($scope.$parent.$watchCollection(function() {
          return $scope.uiGrid.columnDefs;
        }, columnDefsWatchFunction));
      }
      function columnDefsWatchFunction(n, o) {
        if (n && n !== o) {
          self.grid.options.columnDefs = n;
          self.grid.buildColumns({orderByColumnDefs: true}).then(function() {
            self.grid.preCompileCellTemplates();
            self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.COLUMN);
          });
        }
      }
      function dataWatchFunction(newData) {
        var promises = [];
        if (self.grid.options.fastWatch) {
          if (angular.isString($scope.uiGrid.data)) {
            newData = self.grid.appScope[$scope.uiGrid.data];
          } else {
            newData = $scope.uiGrid.data;
          }
        }
        if (newData) {
          if (self.grid.columns.length === (self.grid.rowHeaderColumns ? self.grid.rowHeaderColumns.length : 0) && !$attrs.uiGridColumns && self.grid.options.columnDefs.length === 0 && newData.length > 0) {
            self.grid.buildColumnDefsFromData(newData);
          }
          if (self.grid.options.columnDefs.length > 0 || newData.length > 0) {
            promises.push(self.grid.buildColumns().then(function() {
              self.grid.preCompileCellTemplates();
            }));
          }
          $q.all(promises).then(function() {
            self.grid.modifyRows(newData).then(function() {
              self.grid.redrawInPlace(true);
              $scope.$evalAsync(function() {
                self.grid.refreshCanvas(true);
                self.grid.callDataChangeCallbacks(uiGridConstants.dataChange.ROW);
              });
            });
          });
        }
      }
      var styleWatchDereg = $scope.$watch(function() {
        return self.grid.styleComputations;
      }, function() {
        self.grid.refreshCanvas(true);
      });
      $scope.$on('$destroy', function() {
        deregFunctions.forEach(function(deregFn) {
          deregFn();
        });
        styleWatchDereg();
      });
      self.fireEvent = function(eventName, args) {
        if (typeof(args) === 'undefined' || args === undefined) {
          args = {};
        }
        if (typeof(args.grid) === 'undefined' || args.grid === undefined) {
          args.grid = self.grid;
        }
        $scope.$broadcast(eventName, args);
      };
      self.innerCompile = function innerCompile(elm) {
        $compile(elm)($scope);
      };
    }]);
    angular.module('ui.grid').directive('uiGrid', uiGridDirective);
    uiGridDirective.$inject = ['$compile', '$templateCache', '$timeout', '$window', 'gridUtil', 'uiGridConstants'];
    function uiGridDirective($compile, $templateCache, $timeout, $window, gridUtil, uiGridConstants) {
      return {
        templateUrl: 'ui-grid/ui-grid',
        scope: {uiGrid: '='},
        replace: true,
        transclude: true,
        controller: 'uiGridController',
        compile: function() {
          return {post: function($scope, $elm, $attrs, uiGridCtrl) {
              var grid = uiGridCtrl.grid;
              uiGridCtrl.scrollbars = [];
              grid.element = $elm;
              var sizeCheckInterval = 100;
              var maxSizeChecks = 20;
              var sizeChecks = 0;
              setup();
              init();
              grid.renderingComplete();
              checkSize();
              function checkSize() {
                if ($elm[0].offsetWidth <= 0 && sizeChecks < maxSizeChecks) {
                  setTimeout(checkSize, sizeCheckInterval);
                  sizeChecks++;
                } else {
                  $timeout(init);
                }
              }
              function setup() {
                angular.element($window).on('resize', gridResize);
                $elm.on('$destroy', function() {
                  angular.element($window).off('resize', gridResize);
                });
                $scope.$watch(function() {
                  return grid.hasLeftContainer();
                }, function(newValue, oldValue) {
                  if (newValue === oldValue) {
                    return ;
                  }
                  grid.refreshCanvas(true);
                });
                $scope.$watch(function() {
                  return grid.hasRightContainer();
                }, function(newValue, oldValue) {
                  if (newValue === oldValue) {
                    return ;
                  }
                  grid.refreshCanvas(true);
                });
              }
              function init() {
                grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                grid.canvasWidth = uiGridCtrl.grid.gridWidth;
                grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                if (grid.gridHeight < grid.options.rowHeight && grid.options.enableMinHeightCheck) {
                  autoAdjustHeight();
                }
                grid.refreshCanvas(true);
              }
              function autoAdjustHeight() {
                var contentHeight = grid.options.minRowsToShow * grid.options.rowHeight;
                var headerHeight = grid.options.showHeader ? grid.options.headerRowHeight : 0;
                var footerHeight = grid.calcFooterHeight();
                var scrollbarHeight = 0;
                if (grid.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
                  scrollbarHeight = gridUtil.getScrollbarWidth();
                }
                var maxNumberOfFilters = 0;
                angular.forEach(grid.options.columnDefs, function(col) {
                  if (col.hasOwnProperty('filter')) {
                    if (maxNumberOfFilters < 1) {
                      maxNumberOfFilters = 1;
                    }
                  } else if (col.hasOwnProperty('filters')) {
                    if (maxNumberOfFilters < col.filters.length) {
                      maxNumberOfFilters = col.filters.length;
                    }
                  }
                });
                if (grid.options.enableFiltering) {
                  var allColumnsHaveFilteringTurnedOff = grid.options.columnDefs.every(function(col) {
                    return col.enableFiltering === false;
                  });
                  if (!allColumnsHaveFilteringTurnedOff) {
                    maxNumberOfFilters++;
                  }
                }
                var filterHeight = maxNumberOfFilters * headerHeight;
                var newHeight = headerHeight + contentHeight + footerHeight + scrollbarHeight + filterHeight;
                $elm.css('height', newHeight + 'px');
                grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
              }
              function gridResize($event) {
                grid.gridWidth = $scope.gridWidth = gridUtil.elementWidth($elm);
                grid.gridHeight = $scope.gridHeight = gridUtil.elementHeight($elm);
                grid.refreshCanvas(true);
              }
            }};
        }
      };
    }
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').directive('uiGridPinnedContainer', ['gridUtil', function(gridUtil) {
      return {
        restrict: 'EA',
        replace: true,
        template: '<div class="ui-grid-pinned-container"><div ui-grid-render-container container-id="side" row-container-name="\'body\'" col-container-name="side" bind-scroll-vertical="true" class="{{ side }} ui-grid-render-container-{{ side }}"></div></div>',
        scope: {side: '=uiGridPinnedContainer'},
        require: '^uiGrid',
        compile: function compile() {
          return {post: function($scope, $elm, $attrs, uiGridCtrl) {
              var grid = uiGridCtrl.grid;
              var myWidth = 0;
              $elm.addClass('ui-grid-pinned-container-' + $scope.side);
              if ($scope.side === 'left' || $scope.side === 'right') {
                grid.renderContainers[$scope.side].getViewportWidth = monkeyPatchedGetViewportWidth;
              }
              function monkeyPatchedGetViewportWidth() {
                var self = this;
                var viewportWidth = 0;
                self.visibleColumnCache.forEach(function(column) {
                  viewportWidth += column.drawnWidth;
                });
                var adjustment = self.getViewportAdjustment();
                viewportWidth = viewportWidth + adjustment.width;
                return viewportWidth;
              }
              function updateContainerWidth() {
                if ($scope.side === 'left' || $scope.side === 'right') {
                  var cols = grid.renderContainers[$scope.side].visibleColumnCache;
                  var width = 0;
                  for (var i = 0; i < cols.length; i++) {
                    var col = cols[i];
                    width += col.drawnWidth || col.width || 0;
                  }
                  return width;
                }
              }
              function updateContainerDimensions() {
                var ret = '';
                if ($scope.side === 'left' || $scope.side === 'right') {
                  myWidth = updateContainerWidth();
                  $elm.attr('style', null);
                  ret += '.grid' + grid.id + ' .ui-grid-pinned-container-' + $scope.side + ', .grid' + grid.id + ' .ui-grid-pinned-container-' + $scope.side + ' .ui-grid-render-container-' + $scope.side + ' .ui-grid-viewport { width: ' + myWidth + 'px; } ';
                }
                return ret;
              }
              grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
                myWidth = updateContainerWidth();
                adjustment.width -= myWidth;
                adjustment.side = $scope.side;
                return adjustment;
              });
              grid.registerStyleComputation({
                priority: 15,
                func: updateContainerDimensions
              });
            }};
        }
      };
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('Grid', ['$q', '$compile', '$parse', 'gridUtil', 'uiGridConstants', 'GridOptions', 'GridColumn', 'GridRow', 'GridApi', 'rowSorter', 'rowSearcher', 'GridRenderContainer', '$timeout', 'ScrollEvent', function($q, $compile, $parse, gridUtil, uiGridConstants, GridOptions, GridColumn, GridRow, GridApi, rowSorter, rowSearcher, GridRenderContainer, $timeout, ScrollEvent) {
      var Grid = function Grid(options) {
        var self = this;
        if (options !== undefined && typeof(options.id) !== 'undefined' && options.id) {
          if (!/^[_a-zA-Z0-9-]+$/.test(options.id)) {
            throw new Error("Grid id '" + options.id + '" is invalid. It must follow CSS selector syntax rules.');
          }
        } else {
          throw new Error('No ID provided. An ID must be given when creating a grid.');
        }
        self.id = options.id;
        delete options.id;
        self.options = GridOptions.initialize(options);
        self.appScope = self.options.appScopeProvider;
        self.headerHeight = self.options.headerRowHeight;
        self.footerHeight = self.calcFooterHeight();
        self.columnFooterHeight = self.calcColumnFooterHeight();
        self.rtl = false;
        self.gridHeight = 0;
        self.gridWidth = 0;
        self.columnBuilders = [];
        self.rowBuilders = [];
        self.rowsProcessors = [];
        self.columnsProcessors = [];
        self.styleComputations = [];
        self.viewportAdjusters = [];
        self.rowHeaderColumns = [];
        self.dataChangeCallbacks = {};
        self.verticalScrollSyncCallBackFns = {};
        self.horizontalScrollSyncCallBackFns = {};
        self.renderContainers = {};
        self.renderContainers.body = new GridRenderContainer('body', self);
        self.cellValueGetterCache = {};
        self.getRowTemplateFn = null;
        self.rows = [];
        self.columns = [];
        self.isScrollingVertically = false;
        self.isScrollingHorizontally = false;
        self.scrollDirection = uiGridConstants.scrollDirection.NONE;
        self.disableScrolling = false;
        function vertical(scrollEvent) {
          self.isScrollingVertically = false;
          self.api.core.raise.scrollEnd(scrollEvent);
          self.scrollDirection = uiGridConstants.scrollDirection.NONE;
        }
        var debouncedVertical = gridUtil.debounce(vertical, self.options.scrollDebounce);
        var debouncedVerticalMinDelay = gridUtil.debounce(vertical, 0);
        function horizontal(scrollEvent) {
          self.isScrollingHorizontally = false;
          self.api.core.raise.scrollEnd(scrollEvent);
          self.scrollDirection = uiGridConstants.scrollDirection.NONE;
        }
        var debouncedHorizontal = gridUtil.debounce(horizontal, self.options.scrollDebounce);
        var debouncedHorizontalMinDelay = gridUtil.debounce(horizontal, 0);
        self.flagScrollingVertically = function(scrollEvent) {
          if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
            self.api.core.raise.scrollBegin(scrollEvent);
          }
          self.isScrollingVertically = true;
          if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
            debouncedVerticalMinDelay(scrollEvent);
          } else {
            debouncedVertical(scrollEvent);
          }
        };
        self.flagScrollingHorizontally = function(scrollEvent) {
          if (!self.isScrollingVertically && !self.isScrollingHorizontally) {
            self.api.core.raise.scrollBegin(scrollEvent);
          }
          self.isScrollingHorizontally = true;
          if (self.options.scrollDebounce === 0 || !scrollEvent.withDelay) {
            debouncedHorizontalMinDelay(scrollEvent);
          } else {
            debouncedHorizontal(scrollEvent);
          }
        };
        self.scrollbarHeight = 0;
        self.scrollbarWidth = 0;
        if (self.options.enableHorizontalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
          self.scrollbarHeight = gridUtil.getScrollbarWidth();
        }
        if (self.options.enableVerticalScrollbar === uiGridConstants.scrollbars.ALWAYS) {
          self.scrollbarWidth = gridUtil.getScrollbarWidth();
        }
        self.api = new GridApi(self);
        self.api.registerMethod('core', 'refresh', this.refresh);
        self.api.registerMethod('core', 'queueGridRefresh', this.queueGridRefresh);
        self.api.registerMethod('core', 'refreshRows', this.refreshRows);
        self.api.registerMethod('core', 'queueRefresh', this.queueRefresh);
        self.api.registerMethod('core', 'handleWindowResize', this.handleWindowResize);
        self.api.registerMethod('core', 'addRowHeaderColumn', this.addRowHeaderColumn);
        self.api.registerMethod('core', 'scrollToIfNecessary', function(gridRow, gridCol) {
          return self.scrollToIfNecessary(gridRow, gridCol);
        });
        self.api.registerMethod('core', 'scrollTo', function(rowEntity, colDef) {
          return self.scrollTo(rowEntity, colDef);
        });
        self.api.registerMethod('core', 'registerRowsProcessor', this.registerRowsProcessor);
        self.api.registerMethod('core', 'registerColumnsProcessor', this.registerColumnsProcessor);
        self.api.registerMethod('core', 'sortHandleNulls', rowSorter.handleNulls);
        self.api.registerEvent('core', 'sortChanged');
        self.api.registerEvent('core', 'columnVisibilityChanged');
        self.api.registerMethod('core', 'notifyDataChange', this.notifyDataChange);
        self.api.registerMethod('core', 'clearAllFilters', this.clearAllFilters);
        self.registerDataChangeCallback(self.columnRefreshCallback, [uiGridConstants.dataChange.COLUMN]);
        self.registerDataChangeCallback(self.processRowsCallback, [uiGridConstants.dataChange.EDIT]);
        self.registerDataChangeCallback(self.updateFooterHeightCallback, [uiGridConstants.dataChange.OPTIONS]);
        self.registerStyleComputation({
          priority: 10,
          func: self.getFooterStyles
        });
      };
      Grid.prototype.calcFooterHeight = function() {
        if (!this.hasFooter()) {
          return 0;
        }
        var height = 0;
        if (this.options.showGridFooter) {
          height += this.options.gridFooterHeight;
        }
        height += this.calcColumnFooterHeight();
        return height;
      };
      Grid.prototype.calcColumnFooterHeight = function() {
        var height = 0;
        if (this.options.showColumnFooter) {
          height += this.options.columnFooterHeight;
        }
        return height;
      };
      Grid.prototype.getFooterStyles = function() {
        var style = '.grid' + this.id + ' .ui-grid-footer-aggregates-row { height: ' + this.options.columnFooterHeight + 'px; }';
        style += ' .grid' + this.id + ' .ui-grid-footer-info { height: ' + this.options.gridFooterHeight + 'px; }';
        return style;
      };
      Grid.prototype.hasFooter = function() {
        return this.options.showGridFooter || this.options.showColumnFooter;
      };
      Grid.prototype.isRTL = function() {
        return this.rtl;
      };
      Grid.prototype.registerColumnBuilder = function registerColumnBuilder(columnBuilder) {
        this.columnBuilders.push(columnBuilder);
      };
      Grid.prototype.buildColumnDefsFromData = function(dataRows) {
        this.options.columnDefs = gridUtil.getColumnsFromData(dataRows, this.options.excludeProperties);
      };
      Grid.prototype.registerRowBuilder = function registerRowBuilder(rowBuilder) {
        this.rowBuilders.push(rowBuilder);
      };
      Grid.prototype.registerDataChangeCallback = function registerDataChangeCallback(callback, types, _this) {
        var uid = gridUtil.nextUid();
        if (!types) {
          types = [uiGridConstants.dataChange.ALL];
        }
        if (!Array.isArray(types)) {
          gridUtil.logError("Expected types to be an array or null in registerDataChangeCallback, value passed was: " + types);
        }
        this.dataChangeCallbacks[uid] = {
          callback: callback,
          types: types,
          _this: _this
        };
        var self = this;
        var deregisterFunction = function() {
          delete self.dataChangeCallbacks[uid];
        };
        return deregisterFunction;
      };
      Grid.prototype.callDataChangeCallbacks = function callDataChangeCallbacks(type, options) {
        angular.forEach(this.dataChangeCallbacks, function(callback, uid) {
          if (callback.types.indexOf(uiGridConstants.dataChange.ALL) !== -1 || callback.types.indexOf(type) !== -1 || type === uiGridConstants.dataChange.ALL) {
            if (callback._this) {
              callback.callback.apply(callback._this, this);
            } else {
              callback.callback(this);
            }
          }
        }, this);
      };
      Grid.prototype.notifyDataChange = function notifyDataChange(type) {
        var constants = uiGridConstants.dataChange;
        if (type === constants.ALL || type === constants.COLUMN || type === constants.EDIT || type === constants.ROW || type === constants.OPTIONS) {
          this.callDataChangeCallbacks(type);
        } else {
          gridUtil.logError("Notified of a data change, but the type was not recognised, so no action taken, type was: " + type);
        }
      };
      Grid.prototype.columnRefreshCallback = function columnRefreshCallback(grid) {
        grid.buildColumns();
        grid.queueGridRefresh();
      };
      Grid.prototype.processRowsCallback = function processRowsCallback(grid) {
        grid.queueGridRefresh();
      };
      Grid.prototype.updateFooterHeightCallback = function updateFooterHeightCallback(grid) {
        grid.footerHeight = grid.calcFooterHeight();
        grid.columnFooterHeight = grid.calcColumnFooterHeight();
      };
      Grid.prototype.getColumn = function getColumn(name) {
        var columns = this.columns.filter(function(column) {
          return column.colDef.name === name;
        });
        return columns.length > 0 ? columns[0] : null;
      };
      Grid.prototype.getColDef = function getColDef(name) {
        var colDefs = this.options.columnDefs.filter(function(colDef) {
          return colDef.name === name;
        });
        return colDefs.length > 0 ? colDefs[0] : null;
      };
      Grid.prototype.assignTypes = function() {
        var self = this;
        self.options.columnDefs.forEach(function(colDef, index) {
          if (!colDef.type) {
            var col = new GridColumn(colDef, index, self);
            var firstRow = self.rows.length > 0 ? self.rows[0] : null;
            if (firstRow) {
              colDef.type = gridUtil.guessType(self.getCellValue(firstRow, col));
            } else {
              colDef.type = 'string';
            }
          }
        });
      };
      Grid.prototype.isRowHeaderColumn = function isRowHeaderColumn(column) {
        return this.rowHeaderColumns.indexOf(column) !== -1;
      };
      Grid.prototype.addRowHeaderColumn = function addRowHeaderColumn(colDef) {
        var self = this;
        var rowHeaderCol = new GridColumn(colDef, gridUtil.nextUid(), self);
        rowHeaderCol.isRowHeader = true;
        if (self.isRTL()) {
          self.createRightContainer();
          rowHeaderCol.renderContainer = 'right';
        } else {
          self.createLeftContainer();
          rowHeaderCol.renderContainer = 'left';
        }
        self.columnBuilders[0](colDef, rowHeaderCol, self.options).then(function() {
          rowHeaderCol.enableFiltering = false;
          rowHeaderCol.enableSorting = false;
          rowHeaderCol.enableHiding = false;
          self.rowHeaderColumns.push(rowHeaderCol);
          self.buildColumns().then(function() {
            self.preCompileCellTemplates();
            self.queueGridRefresh();
          });
        });
      };
      Grid.prototype.getOnlyDataColumns = function getOnlyDataColumns() {
        var self = this;
        var cols = [];
        self.columns.forEach(function(col) {
          if (self.rowHeaderColumns.indexOf(col) === -1) {
            cols.push(col);
          }
        });
        return cols;
      };
      Grid.prototype.buildColumns = function buildColumns(opts) {
        var options = {orderByColumnDefs: false};
        angular.extend(options, opts);
        var self = this;
        var builderPromises = [];
        var headerOffset = self.rowHeaderColumns.length;
        var i;
        for (i = 0; i < self.columns.length; i++) {
          if (!self.getColDef(self.columns[i].name)) {
            self.columns.splice(i, 1);
            i--;
          }
        }
        self.rowHeaderColumns.forEach(function(rowHeaderColumn) {
          self.columns.unshift(rowHeaderColumn);
        });
        self.options.columnDefs.forEach(function(colDef, index) {
          self.preprocessColDef(colDef);
          var col = self.getColumn(colDef.name);
          if (!col) {
            col = new GridColumn(colDef, gridUtil.nextUid(), self);
            self.columns.splice(index + headerOffset, 0, col);
          } else {
            col.updateColumnDef(colDef, false);
          }
          self.columnBuilders.forEach(function(builder) {
            builderPromises.push(builder.call(self, colDef, col, self.options));
          });
        });
        if (!!options.orderByColumnDefs) {
          var columnCache = self.columns.slice(0);
          var len = Math.min(self.options.columnDefs.length, self.columns.length);
          for (i = 0; i < len; i++) {
            if (self.columns[i + headerOffset].name !== self.options.columnDefs[i].name) {
              columnCache[i + headerOffset] = self.getColumn(self.options.columnDefs[i].name);
            } else {
              columnCache[i + headerOffset] = self.columns[i + headerOffset];
            }
          }
          self.columns.length = 0;
          Array.prototype.splice.apply(self.columns, [0, 0].concat(columnCache));
        }
        return $q.all(builderPromises).then(function() {
          if (self.rows.length > 0) {
            self.assignTypes();
          }
        });
      };
      Grid.prototype.preCompileCellTemplates = function() {
        var self = this;
        var preCompileTemplate = function(col) {
          var html = col.cellTemplate.replace(uiGridConstants.MODEL_COL_FIELD, self.getQualifiedColField(col));
          html = html.replace(uiGridConstants.COL_FIELD, 'grid.getCellValue(row, col)');
          var compiledElementFn = $compile(html);
          col.compiledElementFn = compiledElementFn;
          if (col.compiledElementFnDefer) {
            col.compiledElementFnDefer.resolve(col.compiledElementFn);
          }
        };
        this.columns.forEach(function(col) {
          if (col.cellTemplate) {
            preCompileTemplate(col);
          } else if (col.cellTemplatePromise) {
            col.cellTemplatePromise.then(function() {
              preCompileTemplate(col);
            });
          }
        });
      };
      Grid.prototype.getQualifiedColField = function(col) {
        return 'row.entity.' + gridUtil.preEval(col.field);
      };
      Grid.prototype.createLeftContainer = function() {
        if (!this.hasLeftContainer()) {
          this.renderContainers.left = new GridRenderContainer('left', this, {disableColumnOffset: true});
        }
      };
      Grid.prototype.createRightContainer = function() {
        if (!this.hasRightContainer()) {
          this.renderContainers.right = new GridRenderContainer('right', this, {disableColumnOffset: true});
        }
      };
      Grid.prototype.hasLeftContainer = function() {
        return this.renderContainers.left !== undefined;
      };
      Grid.prototype.hasRightContainer = function() {
        return this.renderContainers.right !== undefined;
      };
      Grid.prototype.preprocessColDef = function preprocessColDef(colDef) {
        var self = this;
        if (!colDef.field && !colDef.name) {
          throw new Error('colDef.name or colDef.field property is required');
        }
        if (colDef.name === undefined && colDef.field !== undefined) {
          var newName = colDef.field,
              counter = 2;
          while (self.getColumn(newName)) {
            newName = colDef.field + counter.toString();
            counter++;
          }
          colDef.name = newName;
        }
      };
      Grid.prototype.newInN = function newInN(o, n, oAccessor, nAccessor) {
        var self = this;
        var t = [];
        for (var i = 0; i < n.length; i++) {
          var nV = nAccessor ? n[i][nAccessor] : n[i];
          var found = false;
          for (var j = 0; j < o.length; j++) {
            var oV = oAccessor ? o[j][oAccessor] : o[j];
            if (self.options.rowEquality(nV, oV)) {
              found = true;
              break;
            }
          }
          if (!found) {
            t.push(nV);
          }
        }
        return t;
      };
      Grid.prototype.getRow = function getRow(rowEntity, lookInRows) {
        var self = this;
        lookInRows = typeof(lookInRows) === 'undefined' ? self.rows : lookInRows;
        var rows = lookInRows.filter(function(row) {
          return self.options.rowEquality(row.entity, rowEntity);
        });
        return rows.length > 0 ? rows[0] : null;
      };
      Grid.prototype.modifyRows = function modifyRows(newRawData) {
        var self = this;
        var oldRows = self.rows.slice(0);
        var oldRowHash = self.rowHashMap || self.createRowHashMap();
        self.rowHashMap = self.createRowHashMap();
        self.rows.length = 0;
        newRawData.forEach(function(newEntity, i) {
          var newRow;
          if (self.options.enableRowHashing) {
            newRow = oldRowHash.get(newEntity);
          } else {
            newRow = self.getRow(newEntity, oldRows);
          }
          if (!newRow) {
            newRow = self.processRowBuilders(new GridRow(newEntity, i, self));
          }
          self.rows.push(newRow);
          self.rowHashMap.put(newEntity, newRow);
        });
        self.assignTypes();
        var p1 = $q.when(self.processRowsProcessors(self.rows)).then(function(renderableRows) {
          return self.setVisibleRows(renderableRows);
        });
        var p2 = $q.when(self.processColumnsProcessors(self.columns)).then(function(renderableColumns) {
          return self.setVisibleColumns(renderableColumns);
        });
        return $q.all([p1, p2]);
      };
      Grid.prototype.addRows = function addRows(newRawData) {
        var self = this;
        var existingRowCount = self.rows.length;
        for (var i = 0; i < newRawData.length; i++) {
          var newRow = self.processRowBuilders(new GridRow(newRawData[i], i + existingRowCount, self));
          if (self.options.enableRowHashing) {
            var found = self.rowHashMap.get(newRow.entity);
            if (found) {
              found.row = newRow;
            }
          }
          self.rows.push(newRow);
        }
      };
      Grid.prototype.processRowBuilders = function processRowBuilders(gridRow) {
        var self = this;
        self.rowBuilders.forEach(function(builder) {
          builder.call(self, gridRow, self.options);
        });
        return gridRow;
      };
      Grid.prototype.registerStyleComputation = function registerStyleComputation(styleComputationInfo) {
        this.styleComputations.push(styleComputationInfo);
      };
      Grid.prototype.registerRowsProcessor = function registerRowsProcessor(processor, priority) {
        if (!angular.isFunction(processor)) {
          throw 'Attempt to register non-function rows processor: ' + processor;
        }
        this.rowsProcessors.push({
          processor: processor,
          priority: priority
        });
        this.rowsProcessors.sort(function sortByPriority(a, b) {
          return a.priority - b.priority;
        });
      };
      Grid.prototype.removeRowsProcessor = function removeRowsProcessor(processor) {
        var idx = -1;
        this.rowsProcessors.forEach(function(rowsProcessor, index) {
          if (rowsProcessor.processor === processor) {
            idx = index;
          }
        });
        if (idx !== -1) {
          this.rowsProcessors.splice(idx, 1);
        }
      };
      Grid.prototype.processRowsProcessors = function processRowsProcessors(renderableRows) {
        var self = this;
        var myRenderableRows = renderableRows.slice(0);
        if (self.rowsProcessors.length === 0) {
          return $q.when(myRenderableRows);
        }
        var i = 0;
        var finished = $q.defer();
        function startProcessor(i, renderedRowsToProcess) {
          var processor = self.rowsProcessors[i].processor;
          return $q.when(processor.call(self, renderedRowsToProcess, self.columns)).then(function handleProcessedRows(processedRows) {
            if (!processedRows) {
              throw "Processor at index " + i + " did not return a set of renderable rows";
            }
            if (!angular.isArray(processedRows)) {
              throw "Processor at index " + i + " did not return an array";
            }
            i++;
            if (i <= self.rowsProcessors.length - 1) {
              return startProcessor(i, processedRows);
            } else {
              finished.resolve(processedRows);
            }
          });
        }
        startProcessor(0, myRenderableRows);
        return finished.promise;
      };
      Grid.prototype.setVisibleRows = function setVisibleRows(rows) {
        var self = this;
        for (var i in self.renderContainers) {
          var container = self.renderContainers[i];
          container.canvasHeightShouldUpdate = true;
          if (typeof(container.visibleRowCache) === 'undefined') {
            container.visibleRowCache = [];
          } else {
            container.visibleRowCache.length = 0;
          }
        }
        for (var ri = 0; ri < rows.length; ri++) {
          var row = rows[ri];
          var targetContainer = (typeof(row.renderContainer) !== 'undefined' && row.renderContainer) ? row.renderContainer : 'body';
          if (row.visible) {
            self.renderContainers[targetContainer].visibleRowCache.push(row);
          }
        }
        self.api.core.raise.rowsRendered(this.api);
      };
      Grid.prototype.registerColumnsProcessor = function registerColumnsProcessor(processor, priority) {
        if (!angular.isFunction(processor)) {
          throw 'Attempt to register non-function rows processor: ' + processor;
        }
        this.columnsProcessors.push({
          processor: processor,
          priority: priority
        });
        this.columnsProcessors.sort(function sortByPriority(a, b) {
          return a.priority - b.priority;
        });
      };
      Grid.prototype.removeColumnsProcessor = function removeColumnsProcessor(processor) {
        var idx = this.columnsProcessors.indexOf(processor);
        if (typeof(idx) !== 'undefined' && idx !== undefined) {
          this.columnsProcessors.splice(idx, 1);
        }
      };
      Grid.prototype.processColumnsProcessors = function processColumnsProcessors(renderableColumns) {
        var self = this;
        var myRenderableColumns = renderableColumns.slice(0);
        if (self.columnsProcessors.length === 0) {
          return $q.when(myRenderableColumns);
        }
        var i = 0;
        var finished = $q.defer();
        function startProcessor(i, renderedColumnsToProcess) {
          var processor = self.columnsProcessors[i].processor;
          return $q.when(processor.call(self, renderedColumnsToProcess, self.rows)).then(function handleProcessedRows(processedColumns) {
            if (!processedColumns) {
              throw "Processor at index " + i + " did not return a set of renderable rows";
            }
            if (!angular.isArray(processedColumns)) {
              throw "Processor at index " + i + " did not return an array";
            }
            i++;
            if (i <= self.columnsProcessors.length - 1) {
              return startProcessor(i, myRenderableColumns);
            } else {
              finished.resolve(myRenderableColumns);
            }
          });
        }
        startProcessor(0, myRenderableColumns);
        return finished.promise;
      };
      Grid.prototype.setVisibleColumns = function setVisibleColumns(columns) {
        var self = this;
        for (var i in self.renderContainers) {
          var container = self.renderContainers[i];
          container.visibleColumnCache.length = 0;
        }
        for (var ci = 0; ci < columns.length; ci++) {
          var column = columns[ci];
          if (column.visible) {
            if (typeof(column.renderContainer) !== 'undefined' && column.renderContainer) {
              self.renderContainers[column.renderContainer].visibleColumnCache.push(column);
            } else {
              self.renderContainers.body.visibleColumnCache.push(column);
            }
          }
        }
      };
      Grid.prototype.handleWindowResize = function handleWindowResize($event) {
        var self = this;
        self.gridWidth = gridUtil.elementWidth(self.element);
        self.gridHeight = gridUtil.elementHeight(self.element);
        self.queueRefresh();
      };
      Grid.prototype.queueRefresh = function queueRefresh() {
        var self = this;
        if (self.refreshCanceller) {
          $timeout.cancel(self.refreshCanceller);
        }
        self.refreshCanceller = $timeout(function() {
          self.refreshCanvas(true);
        });
        self.refreshCanceller.then(function() {
          self.refreshCanceller = null;
        });
        return self.refreshCanceller;
      };
      Grid.prototype.queueGridRefresh = function queueGridRefresh() {
        var self = this;
        if (self.gridRefreshCanceller) {
          $timeout.cancel(self.gridRefreshCanceller);
        }
        self.gridRefreshCanceller = $timeout(function() {
          self.refresh(true);
        });
        self.gridRefreshCanceller.then(function() {
          self.gridRefreshCanceller = null;
        });
        return self.gridRefreshCanceller;
      };
      Grid.prototype.updateCanvasHeight = function updateCanvasHeight() {
        var self = this;
        for (var containerId in self.renderContainers) {
          if (self.renderContainers.hasOwnProperty(containerId)) {
            var container = self.renderContainers[containerId];
            container.canvasHeightShouldUpdate = true;
          }
        }
      };
      Grid.prototype.buildStyles = function buildStyles() {
        var self = this;
        self.customStyles = '';
        self.styleComputations.sort(function(a, b) {
          if (a.priority === null) {
            return 1;
          }
          if (b.priority === null) {
            return -1;
          }
          if (a.priority === null && b.priority === null) {
            return 0;
          }
          return a.priority - b.priority;
        }).forEach(function(compInfo) {
          var ret = compInfo.func.call(self);
          if (angular.isString(ret)) {
            self.customStyles += '\n' + ret;
          }
        });
      };
      Grid.prototype.minColumnsToRender = function minColumnsToRender() {
        var self = this;
        var viewport = this.getViewportWidth();
        var min = 0;
        var totalWidth = 0;
        self.columns.forEach(function(col, i) {
          if (totalWidth < viewport) {
            totalWidth += col.drawnWidth;
            min++;
          } else {
            var currWidth = 0;
            for (var j = i; j >= i - min; j--) {
              currWidth += self.columns[j].drawnWidth;
            }
            if (currWidth < viewport) {
              min++;
            }
          }
        });
        return min;
      };
      Grid.prototype.getBodyHeight = function getBodyHeight() {
        var bodyHeight = this.getViewportHeight();
        return bodyHeight;
      };
      Grid.prototype.getViewportHeight = function getViewportHeight() {
        var self = this;
        var viewPortHeight = this.gridHeight - this.headerHeight - this.footerHeight;
        var adjustment = self.getViewportAdjustment();
        viewPortHeight = viewPortHeight + adjustment.height;
        return viewPortHeight;
      };
      Grid.prototype.getViewportWidth = function getViewportWidth() {
        var self = this;
        var viewPortWidth = this.gridWidth;
        var adjustment = self.getViewportAdjustment();
        viewPortWidth = viewPortWidth + adjustment.width;
        return viewPortWidth;
      };
      Grid.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
        var viewPortWidth = this.getViewportWidth();
        return viewPortWidth;
      };
      Grid.prototype.addVerticalScrollSync = function(containerId, callBackFn) {
        this.verticalScrollSyncCallBackFns[containerId] = callBackFn;
      };
      Grid.prototype.addHorizontalScrollSync = function(containerId, callBackFn) {
        this.horizontalScrollSyncCallBackFns[containerId] = callBackFn;
      };
      Grid.prototype.scrollContainers = function(sourceContainerId, scrollEvent) {
        if (scrollEvent.y) {
          var verts = ['body', 'left', 'right'];
          this.flagScrollingVertically(scrollEvent);
          if (sourceContainerId === 'body') {
            verts = ['left', 'right'];
          } else if (sourceContainerId === 'left') {
            verts = ['body', 'right'];
          } else if (sourceContainerId === 'right') {
            verts = ['body', 'left'];
          }
          for (var i = 0; i < verts.length; i++) {
            var id = verts[i];
            if (this.verticalScrollSyncCallBackFns[id]) {
              this.verticalScrollSyncCallBackFns[id](scrollEvent);
            }
          }
        }
        if (scrollEvent.x) {
          var horizs = ['body', 'bodyheader', 'bodyfooter'];
          this.flagScrollingHorizontally(scrollEvent);
          if (sourceContainerId === 'body') {
            horizs = ['bodyheader', 'bodyfooter'];
          }
          for (var j = 0; j < horizs.length; j++) {
            var idh = horizs[j];
            if (this.horizontalScrollSyncCallBackFns[idh]) {
              this.horizontalScrollSyncCallBackFns[idh](scrollEvent);
            }
          }
        }
      };
      Grid.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
        this.viewportAdjusters.push(func);
      };
      Grid.prototype.removeViewportAdjuster = function registerViewportAdjuster(func) {
        var idx = this.viewportAdjusters.indexOf(func);
        if (typeof(idx) !== 'undefined' && idx !== undefined) {
          this.viewportAdjusters.splice(idx, 1);
        }
      };
      Grid.prototype.getViewportAdjustment = function getViewportAdjustment() {
        var self = this;
        var adjustment = {
          height: 0,
          width: 0
        };
        self.viewportAdjusters.forEach(function(func) {
          adjustment = func.call(this, adjustment);
        });
        return adjustment;
      };
      Grid.prototype.getVisibleRowCount = function getVisibleRowCount() {
        return this.renderContainers.body.visibleRowCache.length;
      };
      Grid.prototype.getVisibleRows = function getVisibleRows() {
        return this.renderContainers.body.visibleRowCache;
      };
      Grid.prototype.getVisibleColumnCount = function getVisibleColumnCount() {
        return this.renderContainers.body.visibleColumnCache.length;
      };
      Grid.prototype.searchRows = function searchRows(renderableRows) {
        return rowSearcher.search(this, renderableRows, this.columns);
      };
      Grid.prototype.sortByColumn = function sortByColumn(renderableRows) {
        return rowSorter.sort(this, renderableRows, this.columns);
      };
      Grid.prototype.getCellValue = function getCellValue(row, col) {
        if (typeof(row.entity['$$' + col.uid]) !== 'undefined') {
          return row.entity['$$' + col.uid].rendered;
        } else if (this.options.flatEntityAccess && typeof(col.field) !== 'undefined') {
          return row.entity[col.field];
        } else {
          if (!col.cellValueGetterCache) {
            col.cellValueGetterCache = $parse(row.getEntityQualifiedColField(col));
          }
          return col.cellValueGetterCache(row);
        }
      };
      Grid.prototype.getCellDisplayValue = function getCellDisplayValue(row, col) {
        if (!col.cellDisplayGetterCache) {
          var custom_filter = col.cellFilter ? " | " + col.cellFilter : "";
          if (typeof(row.entity['$$' + col.uid]) !== 'undefined') {
            col.cellDisplayGetterCache = $parse(row.entity['$$' + col.uid].rendered + custom_filter);
          } else if (this.options.flatEntityAccess && typeof(col.field) !== 'undefined') {
            col.cellDisplayGetterCache = $parse(row.entity[col.field] + custom_filter);
          } else {
            col.cellDisplayGetterCache = $parse(row.getEntityQualifiedColField(col) + custom_filter);
          }
        }
        return col.cellDisplayGetterCache(row);
      };
      Grid.prototype.getNextColumnSortPriority = function getNextColumnSortPriority() {
        var self = this,
            p = 0;
        self.columns.forEach(function(col) {
          if (col.sort && col.sort.priority && col.sort.priority > p) {
            p = col.sort.priority;
          }
        });
        return p + 1;
      };
      Grid.prototype.resetColumnSorting = function resetColumnSorting(excludeCol) {
        var self = this;
        self.columns.forEach(function(col) {
          if (col !== excludeCol && !col.suppressRemoveSort) {
            col.sort = {};
          }
        });
      };
      Grid.prototype.getColumnSorting = function getColumnSorting() {
        var self = this;
        var sortedCols = [],
            myCols;
        myCols = self.columns.slice(0);
        myCols.sort(rowSorter.prioritySort).forEach(function(col) {
          if (col.sort && typeof(col.sort.direction) !== 'undefined' && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
            sortedCols.push(col);
          }
        });
        return sortedCols;
      };
      Grid.prototype.sortColumn = function sortColumn(column, directionOrAdd, add) {
        var self = this,
            direction = null;
        if (typeof(column) === 'undefined' || !column) {
          throw new Error('No column parameter provided');
        }
        if (typeof(directionOrAdd) === 'boolean') {
          add = directionOrAdd;
        } else {
          direction = directionOrAdd;
        }
        if (!add) {
          self.resetColumnSorting(column);
          column.sort.priority = 0;
          column.sort.priority = self.getNextColumnSortPriority();
        } else if (!column.sort.priority) {
          column.sort.priority = self.getNextColumnSortPriority();
        }
        if (!direction) {
          if (column.sort.direction && column.sort.direction === uiGridConstants.ASC) {
            column.sort.direction = uiGridConstants.DESC;
          } else if (column.sort.direction && column.sort.direction === uiGridConstants.DESC) {
            if (column.colDef && column.suppressRemoveSort) {
              column.sort.direction = uiGridConstants.ASC;
            } else {
              column.sort = {};
            }
          } else {
            column.sort.direction = uiGridConstants.ASC;
          }
        } else {
          column.sort.direction = direction;
        }
        self.api.core.raise.sortChanged(self, self.getColumnSorting());
        return $q.when(column);
      };
      Grid.prototype.renderingComplete = function() {
        if (angular.isFunction(this.options.onRegisterApi)) {
          this.options.onRegisterApi(this.api);
        }
        this.api.core.raise.renderingComplete(this.api);
      };
      Grid.prototype.createRowHashMap = function createRowHashMap() {
        var self = this;
        var hashMap = new RowHashMap();
        hashMap.grid = self;
        return hashMap;
      };
      Grid.prototype.refresh = function refresh(rowsAltered) {
        var self = this;
        var p1 = self.processRowsProcessors(self.rows).then(function(renderableRows) {
          self.setVisibleRows(renderableRows);
        });
        var p2 = self.processColumnsProcessors(self.columns).then(function(renderableColumns) {
          self.setVisibleColumns(renderableColumns);
        });
        return $q.all([p1, p2]).then(function() {
          self.redrawInPlace(rowsAltered);
          self.refreshCanvas(true);
        });
      };
      Grid.prototype.refreshRows = function refreshRows() {
        var self = this;
        return self.processRowsProcessors(self.rows).then(function(renderableRows) {
          self.setVisibleRows(renderableRows);
          self.redrawInPlace();
          self.refreshCanvas(true);
        });
      };
      Grid.prototype.refreshCanvas = function(buildStyles) {
        var self = this;
        if (buildStyles) {
          self.buildStyles();
        }
        var p = $q.defer();
        var containerHeadersToRecalc = [];
        for (var containerId in self.renderContainers) {
          if (self.renderContainers.hasOwnProperty(containerId)) {
            var container = self.renderContainers[containerId];
            if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
              continue;
            }
            if (container.header || container.headerCanvas) {
              container.explicitHeaderHeight = container.explicitHeaderHeight || null;
              container.explicitHeaderCanvasHeight = container.explicitHeaderCanvasHeight || null;
              containerHeadersToRecalc.push(container);
            }
          }
        }
        if (containerHeadersToRecalc.length > 0) {
          if (buildStyles) {
            self.buildStyles();
          }
          $timeout(function() {
            var rebuildStyles = false;
            var maxHeaderHeight = 0;
            var maxHeaderCanvasHeight = 0;
            var i,
                container;
            var getHeight = function(oldVal, newVal) {
              if (oldVal !== newVal) {
                rebuildStyles = true;
              }
              return newVal;
            };
            for (i = 0; i < containerHeadersToRecalc.length; i++) {
              container = containerHeadersToRecalc[i];
              if (container.canvasWidth === null || isNaN(container.canvasWidth)) {
                continue;
              }
              if (container.header) {
                var headerHeight = container.headerHeight = getHeight(container.headerHeight, parseInt(gridUtil.outerElementHeight(container.header), 10));
                var topBorder = gridUtil.getBorderSize(container.header, 'top');
                var bottomBorder = gridUtil.getBorderSize(container.header, 'bottom');
                var innerHeaderHeight = parseInt(headerHeight - topBorder - bottomBorder, 10);
                innerHeaderHeight = innerHeaderHeight < 0 ? 0 : innerHeaderHeight;
                container.innerHeaderHeight = innerHeaderHeight;
                if (!container.explicitHeaderHeight && innerHeaderHeight > maxHeaderHeight) {
                  maxHeaderHeight = innerHeaderHeight;
                }
              }
              if (container.headerCanvas) {
                var headerCanvasHeight = container.headerCanvasHeight = getHeight(container.headerCanvasHeight, parseInt(gridUtil.outerElementHeight(container.headerCanvas), 10));
                if (!container.explicitHeaderCanvasHeight && headerCanvasHeight > maxHeaderCanvasHeight) {
                  maxHeaderCanvasHeight = headerCanvasHeight;
                }
              }
            }
            for (i = 0; i < containerHeadersToRecalc.length; i++) {
              container = containerHeadersToRecalc[i];
              if (maxHeaderHeight > 0 && typeof(container.headerHeight) !== 'undefined' && container.headerHeight !== null && (container.explicitHeaderHeight || container.headerHeight < maxHeaderHeight)) {
                container.explicitHeaderHeight = getHeight(container.explicitHeaderHeight, maxHeaderHeight);
              }
              if (maxHeaderCanvasHeight > 0 && typeof(container.headerCanvasHeight) !== 'undefined' && container.headerCanvasHeight !== null && (container.explicitHeaderCanvasHeight || container.headerCanvasHeight < maxHeaderCanvasHeight)) {
                container.explicitHeaderCanvasHeight = getHeight(container.explicitHeaderCanvasHeight, maxHeaderCanvasHeight);
              }
            }
            if (buildStyles && rebuildStyles) {
              self.buildStyles();
            }
            p.resolve();
          });
        } else {
          $timeout(function() {
            p.resolve();
          });
        }
        return p.promise;
      };
      Grid.prototype.redrawInPlace = function redrawInPlace(rowsAdded) {
        var self = this;
        for (var i in self.renderContainers) {
          var container = self.renderContainers[i];
          if (rowsAdded) {
            container.adjustRows(container.prevScrollTop, null);
            container.adjustColumns(container.prevScrollLeft, null);
          } else {
            container.adjustRows(null, container.prevScrolltopPercentage);
            container.adjustColumns(null, container.prevScrollleftPercentage);
          }
        }
      };
      Grid.prototype.hasLeftContainerColumns = function() {
        return this.hasLeftContainer() && this.renderContainers.left.renderedColumns.length > 0;
      };
      Grid.prototype.hasRightContainerColumns = function() {
        return this.hasRightContainer() && this.renderContainers.right.renderedColumns.length > 0;
      };
      Grid.prototype.scrollToIfNecessary = function(gridRow, gridCol) {
        var self = this;
        var scrollEvent = new ScrollEvent(self, 'uiGrid.scrollToIfNecessary');
        var visRowCache = self.renderContainers.body.visibleRowCache;
        var visColCache = self.renderContainers.body.visibleColumnCache;
        var topBound = self.renderContainers.body.prevScrollTop + self.headerHeight;
        topBound = (topBound < 0) ? 0 : topBound;
        var leftBound = self.renderContainers.body.prevScrollLeft;
        var bottomBound = self.renderContainers.body.prevScrollTop + self.gridHeight - self.renderContainers.body.headerHeight - self.footerHeight - self.scrollbarWidth;
        var rightBound = self.renderContainers.body.prevScrollLeft + Math.ceil(self.gridWidth);
        if (gridRow !== null) {
          var seekRowIndex = visRowCache.indexOf(gridRow);
          var scrollLength = (self.renderContainers.body.getCanvasHeight() - self.renderContainers.body.getViewportHeight());
          var pixelsToSeeRow = ((seekRowIndex + 1) * self.options.rowHeight);
          pixelsToSeeRow = (pixelsToSeeRow < 0) ? 0 : pixelsToSeeRow;
          var scrollPixels,
              percentage;
          if (pixelsToSeeRow < topBound) {
            scrollPixels = self.renderContainers.body.prevScrollTop - (topBound - pixelsToSeeRow);
            percentage = scrollPixels / scrollLength;
            scrollEvent.y = {percentage: percentage};
          } else if (pixelsToSeeRow > bottomBound) {
            scrollPixels = pixelsToSeeRow - bottomBound + self.renderContainers.body.prevScrollTop;
            percentage = scrollPixels / scrollLength;
            scrollEvent.y = {percentage: percentage};
          }
        }
        if (gridCol !== null) {
          var seekColumnIndex = visColCache.indexOf(gridCol);
          var horizScrollLength = (self.renderContainers.body.getCanvasWidth() - self.renderContainers.body.getViewportWidth());
          var columnLeftEdge = 0;
          for (var i = 0; i < seekColumnIndex; i++) {
            var col = visColCache[i];
            columnLeftEdge += col.drawnWidth;
          }
          columnLeftEdge = (columnLeftEdge < 0) ? 0 : columnLeftEdge;
          var columnRightEdge = columnLeftEdge + gridCol.drawnWidth;
          columnRightEdge = (columnRightEdge < 0) ? 0 : columnRightEdge;
          var horizScrollPixels,
              horizPercentage;
          if (columnLeftEdge < leftBound) {
            horizScrollPixels = self.renderContainers.body.prevScrollLeft - (leftBound - columnLeftEdge);
            horizPercentage = horizScrollPixels / horizScrollLength;
            horizPercentage = (horizPercentage > 1) ? 1 : horizPercentage;
            scrollEvent.x = {percentage: horizPercentage};
          } else if (columnRightEdge > rightBound) {
            horizScrollPixels = columnRightEdge - rightBound + self.renderContainers.body.prevScrollLeft;
            horizPercentage = horizScrollPixels / horizScrollLength;
            horizPercentage = (horizPercentage > 1) ? 1 : horizPercentage;
            scrollEvent.x = {percentage: horizPercentage};
          }
        }
        var deferred = $q.defer();
        if (scrollEvent.y || scrollEvent.x) {
          scrollEvent.withDelay = false;
          self.scrollContainers('', scrollEvent);
          var dereg = self.api.core.on.scrollEnd(null, function() {
            deferred.resolve(scrollEvent);
            dereg();
          });
        } else {
          deferred.resolve();
        }
        return deferred.promise;
      };
      Grid.prototype.scrollTo = function(rowEntity, colDef) {
        var gridRow = null,
            gridCol = null;
        if (rowEntity !== null && typeof(rowEntity) !== 'undefined') {
          gridRow = this.getRow(rowEntity);
        }
        if (colDef !== null && typeof(colDef) !== 'undefined') {
          gridCol = this.getColumn(colDef.name ? colDef.name : colDef.field);
        }
        return this.scrollToIfNecessary(gridRow, gridCol);
      };
      Grid.prototype.clearAllFilters = function clearAllFilters(refreshRows, clearConditions, clearFlags) {
        if (refreshRows === undefined) {
          refreshRows = true;
        }
        if (clearConditions === undefined) {
          clearConditions = false;
        }
        if (clearFlags === undefined) {
          clearFlags = false;
        }
        this.columns.forEach(function(column) {
          column.filters.forEach(function(filter) {
            filter.term = undefined;
            if (clearConditions) {
              filter.condition = undefined;
            }
            if (clearFlags) {
              filter.flags = undefined;
            }
          });
        });
        if (refreshRows) {
          return this.refreshRows();
        }
      };
      function RowHashMap() {}
      RowHashMap.prototype = {
        put: function(key, value) {
          this[this.grid.options.rowIdentity(key)] = value;
        },
        get: function(key) {
          return this[this.grid.options.rowIdentity(key)];
        },
        remove: function(key) {
          var value = this[key = this.grid.options.rowIdentity(key)];
          delete this[key];
          return value;
        }
      };
      return Grid;
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('GridApi', ['$q', '$rootScope', 'gridUtil', 'uiGridConstants', 'GridRow', 'uiGridGridMenuService', function($q, $rootScope, gridUtil, uiGridConstants, GridRow, uiGridGridMenuService) {
      var GridApi = function GridApi(grid) {
        this.grid = grid;
        this.listeners = [];
        this.registerEvent('core', 'renderingComplete');
        this.registerEvent('core', 'filterChanged');
        this.registerMethod('core', 'setRowInvisible', GridRow.prototype.setRowInvisible);
        this.registerMethod('core', 'clearRowInvisible', GridRow.prototype.clearRowInvisible);
        this.registerMethod('core', 'getVisibleRows', this.grid.getVisibleRows);
        this.registerEvent('core', 'rowsVisibleChanged');
        this.registerEvent('core', 'rowsRendered');
        this.registerEvent('core', 'scrollBegin');
        this.registerEvent('core', 'scrollEnd');
        this.registerEvent('core', 'canvasHeightChanged');
      };
      GridApi.prototype.suppressEvents = function(listenerFuncs, callBackFn) {
        var self = this;
        var listeners = angular.isArray(listenerFuncs) ? listenerFuncs : [listenerFuncs];
        var foundListeners = self.listeners.filter(function(listener) {
          return listeners.some(function(l) {
            return listener.handler === l;
          });
        });
        foundListeners.forEach(function(l) {
          l.dereg();
        });
        callBackFn();
        foundListeners.forEach(function(l) {
          l.dereg = registerEventWithAngular(l.eventId, l.handler, self.grid, l._this);
        });
      };
      GridApi.prototype.registerEvent = function(featureName, eventName) {
        var self = this;
        if (!self[featureName]) {
          self[featureName] = {};
        }
        var feature = self[featureName];
        if (!feature.on) {
          feature.on = {};
          feature.raise = {};
        }
        var eventId = self.grid.id + featureName + eventName;
        feature.raise[eventName] = function() {
          $rootScope.$emit.apply($rootScope, [eventId].concat(Array.prototype.slice.call(arguments)));
        };
        feature.on[eventName] = function(scope, handler, _this) {
          if (scope !== null && typeof(scope.$on) === 'undefined') {
            gridUtil.logError('asked to listen on ' + featureName + '.on.' + eventName + ' but scope wasn\'t passed in the input parameters.  It is legitimate to pass null, but you\'ve passed something else, so you probably forgot to provide scope rather than did it deliberately, not registering');
            return ;
          }
          var deregAngularOn = registerEventWithAngular(eventId, handler, self.grid, _this);
          var listener = {
            handler: handler,
            dereg: deregAngularOn,
            eventId: eventId,
            scope: scope,
            _this: _this
          };
          self.listeners.push(listener);
          var removeListener = function() {
            listener.dereg();
            var index = self.listeners.indexOf(listener);
            self.listeners.splice(index, 1);
          };
          if (scope) {
            scope.$on('$destroy', function() {
              removeListener();
            });
          }
          return removeListener;
        };
      };
      function registerEventWithAngular(eventId, handler, grid, _this) {
        return $rootScope.$on(eventId, function(event) {
          var args = Array.prototype.slice.call(arguments);
          args.splice(0, 1);
          handler.apply(_this ? _this : grid.api, args);
        });
      }
      GridApi.prototype.registerEventsFromObject = function(eventObjectMap) {
        var self = this;
        var features = [];
        angular.forEach(eventObjectMap, function(featProp, featPropName) {
          var feature = {
            name: featPropName,
            events: []
          };
          angular.forEach(featProp, function(prop, propName) {
            feature.events.push(propName);
          });
          features.push(feature);
        });
        features.forEach(function(feature) {
          feature.events.forEach(function(event) {
            self.registerEvent(feature.name, event);
          });
        });
      };
      GridApi.prototype.registerMethod = function(featureName, methodName, callBackFn, _this) {
        if (!this[featureName]) {
          this[featureName] = {};
        }
        var feature = this[featureName];
        feature[methodName] = gridUtil.createBoundedWrapper(_this || this.grid, callBackFn);
      };
      GridApi.prototype.registerMethodsFromObject = function(methodMap, _this) {
        var self = this;
        var features = [];
        angular.forEach(methodMap, function(featProp, featPropName) {
          var feature = {
            name: featPropName,
            methods: []
          };
          angular.forEach(featProp, function(prop, propName) {
            feature.methods.push({
              name: propName,
              fn: prop
            });
          });
          features.push(feature);
        });
        features.forEach(function(feature) {
          feature.methods.forEach(function(method) {
            self.registerMethod(feature.name, method.name, method.fn, _this);
          });
        });
      };
      return GridApi;
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('GridColumn', ['gridUtil', 'uiGridConstants', 'i18nService', function(gridUtil, uiGridConstants, i18nService) {
      function GridColumn(colDef, uid, grid) {
        var self = this;
        self.grid = grid;
        self.uid = uid;
        self.updateColumnDef(colDef, true);
        GridColumn.prototype.hideColumn = function() {
          this.colDef.visible = false;
        };
        self.aggregationValue = undefined;
        self.updateAggregationValue = function() {
          if (!self.aggregationType) {
            self.aggregationValue = undefined;
            return ;
          }
          var result = 0;
          var visibleRows = self.grid.getVisibleRows();
          var cellValues = function() {
            var values = [];
            visibleRows.forEach(function(row) {
              var cellValue = self.grid.getCellValue(row, self);
              var cellNumber = Number(cellValue);
              if (!isNaN(cellNumber)) {
                values.push(cellNumber);
              }
            });
            return values;
          };
          if (angular.isFunction(self.aggregationType)) {
            self.aggregationValue = self.aggregationType(visibleRows, self);
          } else if (self.aggregationType === uiGridConstants.aggregationTypes.count) {
            self.aggregationValue = self.grid.getVisibleRowCount();
          } else if (self.aggregationType === uiGridConstants.aggregationTypes.sum) {
            cellValues().forEach(function(value) {
              result += value;
            });
            self.aggregationValue = result;
          } else if (self.aggregationType === uiGridConstants.aggregationTypes.avg) {
            cellValues().forEach(function(value) {
              result += value;
            });
            result = result / cellValues().length;
            self.aggregationValue = result;
          } else if (self.aggregationType === uiGridConstants.aggregationTypes.min) {
            self.aggregationValue = Math.min.apply(null, cellValues());
          } else if (self.aggregationType === uiGridConstants.aggregationTypes.max) {
            self.aggregationValue = Math.max.apply(null, cellValues());
          } else {
            self.aggregationValue = '\u00A0';
          }
        };
        this.getAggregationValue = function() {
          return self.aggregationValue;
        };
      }
      GridColumn.prototype.setPropertyOrDefault = function(colDef, propName, defaultValue) {
        var self = this;
        if (typeof(colDef[propName]) !== 'undefined' && colDef[propName]) {
          self[propName] = colDef[propName];
        } else if (typeof(self[propName]) !== 'undefined') {
          self[propName] = self[propName];
        } else {
          self[propName] = defaultValue ? defaultValue : {};
        }
      };
      GridColumn.prototype.updateColumnDef = function(colDef, isNew) {
        var self = this;
        self.colDef = colDef;
        if (colDef.name === undefined) {
          throw new Error('colDef.name is required for column at index ' + self.grid.options.columnDefs.indexOf(colDef));
        }
        self.displayName = (colDef.displayName === undefined) ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
        if (!angular.isNumber(self.width) || !self.hasCustomWidth || colDef.allowCustomWidthOverride) {
          var colDefWidth = colDef.width;
          var parseErrorMsg = "Cannot parse column width '" + colDefWidth + "' for column named '" + colDef.name + "'";
          self.hasCustomWidth = false;
          if (!angular.isString(colDefWidth) && !angular.isNumber(colDefWidth)) {
            self.width = '*';
          } else if (angular.isString(colDefWidth)) {
            if (gridUtil.endsWith(colDefWidth, '%')) {
              var percentStr = colDefWidth.replace(/%/g, '');
              var percent = parseInt(percentStr, 10);
              if (isNaN(percent)) {
                throw new Error(parseErrorMsg);
              }
              self.width = colDefWidth;
            } else if (colDefWidth.match(/^(\d+)$/)) {
              self.width = parseInt(colDefWidth.match(/^(\d+)$/)[1], 10);
            } else if (colDefWidth.match(/^\*+$/)) {
              self.width = colDefWidth;
            } else {
              throw new Error(parseErrorMsg);
            }
          } else {
            self.width = colDefWidth;
          }
        }
        ['minWidth', 'maxWidth'].forEach(function(name) {
          var minOrMaxWidth = colDef[name];
          var parseErrorMsg = "Cannot parse column " + name + " '" + minOrMaxWidth + "' for column named '" + colDef.name + "'";
          if (!angular.isString(minOrMaxWidth) && !angular.isNumber(minOrMaxWidth)) {
            self[name] = ((name === 'minWidth') ? 30 : 9000);
          } else if (angular.isString(minOrMaxWidth)) {
            if (minOrMaxWidth.match(/^(\d+)$/)) {
              self[name] = parseInt(minOrMaxWidth.match(/^(\d+)$/)[1], 10);
            } else {
              throw new Error(parseErrorMsg);
            }
          } else {
            self[name] = minOrMaxWidth;
          }
        });
        self.field = (colDef.field === undefined) ? colDef.name : colDef.field;
        if (typeof(self.field) !== 'string') {
          gridUtil.logError('Field is not a string, this is likely to break the code, Field is: ' + self.field);
        }
        self.name = colDef.name;
        self.displayName = (colDef.displayName === undefined) ? gridUtil.readableColumnName(colDef.name) : colDef.displayName;
        self.aggregationType = angular.isDefined(colDef.aggregationType) ? colDef.aggregationType : null;
        self.footerCellTemplate = angular.isDefined(colDef.footerCellTemplate) ? colDef.footerCellTemplate : null;
        if (typeof(colDef.cellTooltip) === 'undefined' || colDef.cellTooltip === false) {
          self.cellTooltip = false;
        } else if (colDef.cellTooltip === true) {
          self.cellTooltip = function(row, col) {
            return self.grid.getCellValue(row, col);
          };
        } else if (typeof(colDef.cellTooltip) === 'function') {
          self.cellTooltip = colDef.cellTooltip;
        } else {
          self.cellTooltip = function(row, col) {
            return col.colDef.cellTooltip;
          };
        }
        if (typeof(colDef.headerTooltip) === 'undefined' || colDef.headerTooltip === false) {
          self.headerTooltip = false;
        } else if (colDef.headerTooltip === true) {
          self.headerTooltip = function(col) {
            return col.displayName;
          };
        } else if (typeof(colDef.headerTooltip) === 'function') {
          self.headerTooltip = colDef.headerTooltip;
        } else {
          self.headerTooltip = function(col) {
            return col.colDef.headerTooltip;
          };
        }
        self.footerCellClass = colDef.footerCellClass;
        self.cellClass = colDef.cellClass;
        self.headerCellClass = colDef.headerCellClass;
        self.cellFilter = colDef.cellFilter ? colDef.cellFilter : "";
        self.sortCellFiltered = colDef.sortCellFiltered ? true : false;
        self.filterCellFiltered = colDef.filterCellFiltered ? true : false;
        self.headerCellFilter = colDef.headerCellFilter ? colDef.headerCellFilter : "";
        self.footerCellFilter = colDef.footerCellFilter ? colDef.footerCellFilter : "";
        self.visible = gridUtil.isNullOrUndefined(colDef.visible) || colDef.visible;
        self.headerClass = colDef.headerClass;
        self.enableSorting = typeof(colDef.enableSorting) !== 'undefined' ? colDef.enableSorting : true;
        self.sortingAlgorithm = colDef.sortingAlgorithm;
        if (typeof(self.suppressRemoveSort) === 'undefined') {
          self.suppressRemoveSort = typeof(colDef.suppressRemoveSort) !== 'undefined' ? colDef.suppressRemoveSort : false;
        }
        self.enableFiltering = typeof(colDef.enableFiltering) !== 'undefined' ? colDef.enableFiltering : true;
        self.setPropertyOrDefault(colDef, 'menuItems', []);
        if (isNew) {
          self.setPropertyOrDefault(colDef, 'sort');
        }
        var defaultFilters = [];
        if (colDef.filter) {
          defaultFilters.push(colDef.filter);
        } else if (colDef.filters) {
          defaultFilters = colDef.filters;
        } else {
          defaultFilters.push({});
        }
        if (isNew) {
          self.setPropertyOrDefault(colDef, 'filter');
          self.setPropertyOrDefault(colDef, 'filters', defaultFilters);
        } else if (self.filters.length === defaultFilters.length) {
          self.filters.forEach(function(filter, index) {
            if (typeof(defaultFilters[index].placeholder) !== 'undefined') {
              filter.placeholder = defaultFilters[index].placeholder;
            }
            if (typeof(defaultFilters[index].ariaLabel) !== 'undefined') {
              filter.ariaLabel = defaultFilters[index].ariaLabel;
            }
            if (typeof(defaultFilters[index].flags) !== 'undefined') {
              filter.flags = defaultFilters[index].flags;
            }
            if (typeof(defaultFilters[index].type) !== 'undefined') {
              filter.type = defaultFilters[index].type;
            }
            if (typeof(defaultFilters[index].selectOptions) !== 'undefined') {
              filter.selectOptions = defaultFilters[index].selectOptions;
            }
          });
        }
        GridColumn.prototype.unsort = function() {
          this.sort = {};
          self.grid.api.core.raise.sortChanged(self.grid, self.grid.getColumnSorting());
        };
      };
      GridColumn.prototype.getColClass = function(prefixDot) {
        var cls = uiGridConstants.COL_CLASS_PREFIX + this.uid;
        return prefixDot ? '.' + cls : cls;
      };
      GridColumn.prototype.isPinnedLeft = function() {
        return this.renderContainer === 'left';
      };
      GridColumn.prototype.isPinnedRight = function() {
        return this.renderContainer === 'right';
      };
      GridColumn.prototype.getColClassDefinition = function() {
        return ' .grid' + this.grid.id + ' ' + this.getColClass(true) + ' { min-width: ' + this.drawnWidth + 'px; max-width: ' + this.drawnWidth + 'px; }';
      };
      GridColumn.prototype.getRenderContainer = function getRenderContainer() {
        var self = this;
        var containerId = self.renderContainer;
        if (containerId === null || containerId === '' || containerId === undefined) {
          containerId = 'body';
        }
        return self.grid.renderContainers[containerId];
      };
      GridColumn.prototype.showColumn = function() {
        this.colDef.visible = true;
      };
      GridColumn.prototype.getAggregationText = function() {
        var self = this;
        if (self.colDef.aggregationHideLabel) {
          return '';
        } else if (self.colDef.aggregationLabel) {
          return self.colDef.aggregationLabel;
        } else {
          switch (self.colDef.aggregationType) {
            case uiGridConstants.aggregationTypes.count:
              return i18nService.getSafeText('aggregation.count');
            case uiGridConstants.aggregationTypes.sum:
              return i18nService.getSafeText('aggregation.sum');
            case uiGridConstants.aggregationTypes.avg:
              return i18nService.getSafeText('aggregation.avg');
            case uiGridConstants.aggregationTypes.min:
              return i18nService.getSafeText('aggregation.min');
            case uiGridConstants.aggregationTypes.max:
              return i18nService.getSafeText('aggregation.max');
            default:
              return '';
          }
        }
      };
      GridColumn.prototype.getCellTemplate = function() {
        var self = this;
        return self.cellTemplatePromise;
      };
      GridColumn.prototype.getCompiledElementFn = function() {
        var self = this;
        return self.compiledElementFnDefer.promise;
      };
      return GridColumn;
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('GridOptions', ['gridUtil', 'uiGridConstants', function(gridUtil, uiGridConstants) {
      return {initialize: function(baseOptions) {
          baseOptions.onRegisterApi = baseOptions.onRegisterApi || angular.noop();
          baseOptions.data = baseOptions.data || [];
          baseOptions.columnDefs = baseOptions.columnDefs || [];
          baseOptions.excludeProperties = baseOptions.excludeProperties || ['$$hashKey'];
          baseOptions.enableRowHashing = baseOptions.enableRowHashing !== false;
          baseOptions.rowIdentity = baseOptions.rowIdentity || function rowIdentity(row) {
            return gridUtil.hashKey(row);
          };
          baseOptions.getRowIdentity = baseOptions.getRowIdentity || function getRowIdentity(row) {
            return row.$$hashKey;
          };
          baseOptions.flatEntityAccess = baseOptions.flatEntityAccess === true;
          baseOptions.showHeader = typeof(baseOptions.showHeader) !== "undefined" ? baseOptions.showHeader : true;
          if (!baseOptions.showHeader) {
            baseOptions.headerRowHeight = 0;
          } else {
            baseOptions.headerRowHeight = typeof(baseOptions.headerRowHeight) !== "undefined" ? baseOptions.headerRowHeight : 30;
          }
          baseOptions.rowHeight = baseOptions.rowHeight || 30;
          baseOptions.minRowsToShow = typeof(baseOptions.minRowsToShow) !== "undefined" ? baseOptions.minRowsToShow : 10;
          baseOptions.showGridFooter = baseOptions.showGridFooter === true;
          baseOptions.showColumnFooter = baseOptions.showColumnFooter === true;
          baseOptions.columnFooterHeight = typeof(baseOptions.columnFooterHeight) !== "undefined" ? baseOptions.columnFooterHeight : 30;
          baseOptions.gridFooterHeight = typeof(baseOptions.gridFooterHeight) !== "undefined" ? baseOptions.gridFooterHeight : 30;
          baseOptions.columnWidth = typeof(baseOptions.columnWidth) !== "undefined" ? baseOptions.columnWidth : 50;
          baseOptions.maxVisibleColumnCount = typeof(baseOptions.maxVisibleColumnCount) !== "undefined" ? baseOptions.maxVisibleColumnCount : 200;
          baseOptions.virtualizationThreshold = typeof(baseOptions.virtualizationThreshold) !== "undefined" ? baseOptions.virtualizationThreshold : 20;
          baseOptions.columnVirtualizationThreshold = typeof(baseOptions.columnVirtualizationThreshold) !== "undefined" ? baseOptions.columnVirtualizationThreshold : 10;
          baseOptions.excessRows = typeof(baseOptions.excessRows) !== "undefined" ? baseOptions.excessRows : 4;
          baseOptions.scrollThreshold = typeof(baseOptions.scrollThreshold) !== "undefined" ? baseOptions.scrollThreshold : 4;
          baseOptions.excessColumns = typeof(baseOptions.excessColumns) !== "undefined" ? baseOptions.excessColumns : 4;
          baseOptions.horizontalScrollThreshold = typeof(baseOptions.horizontalScrollThreshold) !== "undefined" ? baseOptions.horizontalScrollThreshold : 2;
          baseOptions.aggregationCalcThrottle = typeof(baseOptions.aggregationCalcThrottle) !== "undefined" ? baseOptions.aggregationCalcThrottle : 500;
          baseOptions.wheelScrollThrottle = typeof(baseOptions.wheelScrollThrottle) !== "undefined" ? baseOptions.wheelScrollThrottle : 70;
          baseOptions.scrollDebounce = typeof(baseOptions.scrollDebounce) !== "undefined" ? baseOptions.scrollDebounce : 300;
          baseOptions.enableSorting = baseOptions.enableSorting !== false;
          baseOptions.enableFiltering = baseOptions.enableFiltering === true;
          baseOptions.enableColumnMenus = baseOptions.enableColumnMenus !== false;
          baseOptions.enableVerticalScrollbar = typeof(baseOptions.enableVerticalScrollbar) !== "undefined" ? baseOptions.enableVerticalScrollbar : uiGridConstants.scrollbars.ALWAYS;
          baseOptions.enableHorizontalScrollbar = typeof(baseOptions.enableHorizontalScrollbar) !== "undefined" ? baseOptions.enableHorizontalScrollbar : uiGridConstants.scrollbars.ALWAYS;
          baseOptions.enableMinHeightCheck = baseOptions.enableMinHeightCheck !== false;
          baseOptions.minimumColumnSize = typeof(baseOptions.minimumColumnSize) !== "undefined" ? baseOptions.minimumColumnSize : 10;
          baseOptions.rowEquality = baseOptions.rowEquality || function(entityA, entityB) {
            return entityA === entityB;
          };
          baseOptions.headerTemplate = baseOptions.headerTemplate || null;
          baseOptions.footerTemplate = baseOptions.footerTemplate || 'ui-grid/ui-grid-footer';
          baseOptions.gridFooterTemplate = baseOptions.gridFooterTemplate || 'ui-grid/ui-grid-grid-footer';
          baseOptions.rowTemplate = baseOptions.rowTemplate || 'ui-grid/ui-grid-row';
          baseOptions.appScopeProvider = baseOptions.appScopeProvider || null;
          return baseOptions;
        }};
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('GridRenderContainer', ['gridUtil', 'uiGridConstants', function(gridUtil, uiGridConstants) {
      function GridRenderContainer(name, grid, options) {
        var self = this;
        self.name = name;
        self.grid = grid;
        self.visibleRowCache = [];
        self.visibleColumnCache = [];
        self.renderedRows = [];
        self.renderedColumns = [];
        self.prevScrollTop = 0;
        self.prevScrolltopPercentage = 0;
        self.prevRowScrollIndex = 0;
        self.prevScrollLeft = 0;
        self.prevScrollleftPercentage = 0;
        self.prevColumnScrollIndex = 0;
        self.columnStyles = "";
        self.viewportAdjusters = [];
        self.hasHScrollbar = false;
        self.hasVScrollbar = false;
        self.canvasHeightShouldUpdate = true;
        self.$$canvasHeight = 0;
        if (options && angular.isObject(options)) {
          angular.extend(self, options);
        }
        grid.registerStyleComputation({
          priority: 5,
          func: function() {
            self.updateColumnWidths();
            return self.columnStyles;
          }
        });
      }
      GridRenderContainer.prototype.reset = function reset() {
        this.visibleColumnCache.length = 0;
        this.visibleRowCache.length = 0;
        this.renderedRows.length = 0;
        this.renderedColumns.length = 0;
      };
      GridRenderContainer.prototype.containsColumn = function(col) {
        return this.visibleColumnCache.indexOf(col) !== -1;
      };
      GridRenderContainer.prototype.minRowsToRender = function minRowsToRender() {
        var self = this;
        var minRows = 0;
        var rowAddedHeight = 0;
        var viewPortHeight = self.getViewportHeight();
        for (var i = self.visibleRowCache.length - 1; rowAddedHeight < viewPortHeight && i >= 0; i--) {
          rowAddedHeight += self.visibleRowCache[i].height;
          minRows++;
        }
        return minRows;
      };
      GridRenderContainer.prototype.minColumnsToRender = function minColumnsToRender() {
        var self = this;
        var viewportWidth = this.getViewportWidth();
        var min = 0;
        var totalWidth = 0;
        for (var i = 0; i < self.visibleColumnCache.length; i++) {
          var col = self.visibleColumnCache[i];
          if (totalWidth < viewportWidth) {
            totalWidth += col.drawnWidth ? col.drawnWidth : 0;
            min++;
          } else {
            var currWidth = 0;
            for (var j = i; j >= i - min; j--) {
              currWidth += self.visibleColumnCache[j].drawnWidth ? self.visibleColumnCache[j].drawnWidth : 0;
            }
            if (currWidth < viewportWidth) {
              min++;
            }
          }
        }
        return min;
      };
      GridRenderContainer.prototype.getVisibleRowCount = function getVisibleRowCount() {
        return this.visibleRowCache.length;
      };
      GridRenderContainer.prototype.registerViewportAdjuster = function registerViewportAdjuster(func) {
        this.viewportAdjusters.push(func);
      };
      GridRenderContainer.prototype.removeViewportAdjuster = function removeViewportAdjuster(func) {
        var idx = this.viewportAdjusters.indexOf(func);
        if (idx > -1) {
          this.viewportAdjusters.splice(idx, 1);
        }
      };
      GridRenderContainer.prototype.getViewportAdjustment = function getViewportAdjustment() {
        var self = this;
        var adjustment = {
          height: 0,
          width: 0
        };
        self.viewportAdjusters.forEach(function(func) {
          adjustment = func.call(this, adjustment);
        });
        return adjustment;
      };
      GridRenderContainer.prototype.getMargin = function getMargin(side) {
        var self = this;
        var amount = 0;
        self.viewportAdjusters.forEach(function(func) {
          var adjustment = func.call(this, {
            height: 0,
            width: 0
          });
          if (adjustment.side && adjustment.side === side) {
            amount += adjustment.width * -1;
          }
        });
        return amount;
      };
      GridRenderContainer.prototype.getViewportHeight = function getViewportHeight() {
        var self = this;
        var headerHeight = (self.headerHeight) ? self.headerHeight : self.grid.headerHeight;
        var viewPortHeight = self.grid.gridHeight - headerHeight - self.grid.footerHeight;
        var adjustment = self.getViewportAdjustment();
        viewPortHeight = viewPortHeight + adjustment.height;
        return viewPortHeight;
      };
      GridRenderContainer.prototype.getViewportWidth = function getViewportWidth() {
        var self = this;
        var viewportWidth = self.grid.gridWidth;
        var adjustment = self.getViewportAdjustment();
        viewportWidth = viewportWidth + adjustment.width;
        return viewportWidth;
      };
      GridRenderContainer.prototype.getHeaderViewportWidth = function getHeaderViewportWidth() {
        var self = this;
        var viewportWidth = this.getViewportWidth();
        return viewportWidth;
      };
      GridRenderContainer.prototype.getCanvasHeight = function getCanvasHeight() {
        var self = this;
        if (!self.canvasHeightShouldUpdate) {
          return self.$$canvasHeight;
        }
        var oldCanvasHeight = self.$$canvasHeight;
        self.$$canvasHeight = 0;
        self.visibleRowCache.forEach(function(row) {
          self.$$canvasHeight += row.height;
        });
        self.canvasHeightShouldUpdate = false;
        self.grid.api.core.raise.canvasHeightChanged(oldCanvasHeight, self.$$canvasHeight);
        return self.$$canvasHeight;
      };
      GridRenderContainer.prototype.getVerticalScrollLength = function getVerticalScrollLength() {
        return this.getCanvasHeight() - this.getViewportHeight() + this.grid.scrollbarHeight;
      };
      GridRenderContainer.prototype.getCanvasWidth = function getCanvasWidth() {
        var self = this;
        var ret = self.canvasWidth;
        return ret;
      };
      GridRenderContainer.prototype.setRenderedRows = function setRenderedRows(newRows) {
        this.renderedRows.length = newRows.length;
        for (var i = 0; i < newRows.length; i++) {
          this.renderedRows[i] = newRows[i];
        }
      };
      GridRenderContainer.prototype.setRenderedColumns = function setRenderedColumns(newColumns) {
        var self = this;
        this.renderedColumns.length = newColumns.length;
        for (var i = 0; i < newColumns.length; i++) {
          this.renderedColumns[i] = newColumns[i];
        }
        this.updateColumnOffset();
      };
      GridRenderContainer.prototype.updateColumnOffset = function updateColumnOffset() {
        var hiddenColumnsWidth = 0;
        for (var i = 0; i < this.currentFirstColumn; i++) {
          hiddenColumnsWidth += this.visibleColumnCache[i].drawnWidth;
        }
        this.columnOffset = hiddenColumnsWidth;
      };
      GridRenderContainer.prototype.scrollVertical = function(newScrollTop) {
        var vertScrollPercentage = -1;
        if (newScrollTop !== this.prevScrollTop) {
          var yDiff = newScrollTop - this.prevScrollTop;
          if (yDiff > 0) {
            this.grid.scrollDirection = uiGridConstants.scrollDirection.DOWN;
          }
          if (yDiff < 0) {
            this.grid.scrollDirection = uiGridConstants.scrollDirection.UP;
          }
          var vertScrollLength = this.getVerticalScrollLength();
          vertScrollPercentage = newScrollTop / vertScrollLength;
          if (vertScrollPercentage > 1) {
            vertScrollPercentage = 1;
          }
          if (vertScrollPercentage < 0) {
            vertScrollPercentage = 0;
          }
          this.adjustScrollVertical(newScrollTop, vertScrollPercentage);
          return vertScrollPercentage;
        }
      };
      GridRenderContainer.prototype.scrollHorizontal = function(newScrollLeft) {
        var horizScrollPercentage = -1;
        if (newScrollLeft !== this.prevScrollLeft) {
          var xDiff = newScrollLeft - this.prevScrollLeft;
          if (xDiff > 0) {
            this.grid.scrollDirection = uiGridConstants.scrollDirection.RIGHT;
          }
          if (xDiff < 0) {
            this.grid.scrollDirection = uiGridConstants.scrollDirection.LEFT;
          }
          var horizScrollLength = (this.canvasWidth - this.getViewportWidth());
          if (horizScrollLength !== 0) {
            horizScrollPercentage = newScrollLeft / horizScrollLength;
          } else {
            horizScrollPercentage = 0;
          }
          this.adjustScrollHorizontal(newScrollLeft, horizScrollPercentage);
          return horizScrollPercentage;
        }
      };
      GridRenderContainer.prototype.adjustScrollVertical = function adjustScrollVertical(scrollTop, scrollPercentage, force) {
        if (this.prevScrollTop === scrollTop && !force) {
          return ;
        }
        if (typeof(scrollTop) === 'undefined' || scrollTop === undefined || scrollTop === null) {
          scrollTop = (this.getCanvasHeight() - this.getViewportHeight()) * scrollPercentage;
        }
        this.adjustRows(scrollTop, scrollPercentage, false);
        this.prevScrollTop = scrollTop;
        this.prevScrolltopPercentage = scrollPercentage;
        this.grid.queueRefresh();
      };
      GridRenderContainer.prototype.adjustScrollHorizontal = function adjustScrollHorizontal(scrollLeft, scrollPercentage, force) {
        if (this.prevScrollLeft === scrollLeft && !force) {
          return ;
        }
        if (typeof(scrollLeft) === 'undefined' || scrollLeft === undefined || scrollLeft === null) {
          scrollLeft = (this.getCanvasWidth() - this.getViewportWidth()) * scrollPercentage;
        }
        this.adjustColumns(scrollLeft, scrollPercentage);
        this.prevScrollLeft = scrollLeft;
        this.prevScrollleftPercentage = scrollPercentage;
        this.grid.queueRefresh();
      };
      GridRenderContainer.prototype.adjustRows = function adjustRows(scrollTop, scrollPercentage, postDataLoaded) {
        var self = this;
        var minRows = self.minRowsToRender();
        var rowCache = self.visibleRowCache;
        var maxRowIndex = rowCache.length - minRows;
        if ((typeof(scrollPercentage) === 'undefined' || scrollPercentage === null) && scrollTop) {
          scrollPercentage = scrollTop / self.getVerticalScrollLength();
        }
        var rowIndex = Math.ceil(Math.min(maxRowIndex, maxRowIndex * scrollPercentage));
        if (rowIndex > maxRowIndex) {
          rowIndex = maxRowIndex;
        }
        var newRange = [];
        if (rowCache.length > self.grid.options.virtualizationThreshold) {
          if (!(typeof(scrollTop) === 'undefined' || scrollTop === null)) {
            if (!self.grid.suppressParentScrollDown && self.prevScrollTop < scrollTop && rowIndex < self.prevRowScrollIndex + self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
              return ;
            }
            if (!self.grid.suppressParentScrollUp && self.prevScrollTop > scrollTop && rowIndex > self.prevRowScrollIndex - self.grid.options.scrollThreshold && rowIndex < maxRowIndex) {
              return ;
            }
          }
          var rangeStart = {};
          var rangeEnd = {};
          rangeStart = Math.max(0, rowIndex - self.grid.options.excessRows);
          rangeEnd = Math.min(rowCache.length, rowIndex + minRows + self.grid.options.excessRows);
          newRange = [rangeStart, rangeEnd];
        } else {
          var maxLen = self.visibleRowCache.length;
          newRange = [0, Math.max(maxLen, minRows + self.grid.options.excessRows)];
        }
        self.updateViewableRowRange(newRange);
        self.prevRowScrollIndex = rowIndex;
      };
      GridRenderContainer.prototype.adjustColumns = function adjustColumns(scrollLeft, scrollPercentage) {
        var self = this;
        var minCols = self.minColumnsToRender();
        var columnCache = self.visibleColumnCache;
        var maxColumnIndex = columnCache.length - minCols;
        if ((typeof(scrollPercentage) === 'undefined' || scrollPercentage === null) && scrollLeft) {
          var horizScrollLength = (self.getCanvasWidth() - self.getViewportWidth());
          scrollPercentage = scrollLeft / horizScrollLength;
        }
        var colIndex = Math.ceil(Math.min(maxColumnIndex, maxColumnIndex * scrollPercentage));
        if (colIndex > maxColumnIndex) {
          colIndex = maxColumnIndex;
        }
        var newRange = [];
        if (columnCache.length > self.grid.options.columnVirtualizationThreshold && self.getCanvasWidth() > self.getViewportWidth()) {
          var rangeStart = Math.max(0, colIndex - self.grid.options.excessColumns);
          var rangeEnd = Math.min(columnCache.length, colIndex + minCols + self.grid.options.excessColumns);
          newRange = [rangeStart, rangeEnd];
        } else {
          var maxLen = self.visibleColumnCache.length;
          newRange = [0, Math.max(maxLen, minCols + self.grid.options.excessColumns)];
        }
        self.updateViewableColumnRange(newRange);
        self.prevColumnScrollIndex = colIndex;
      };
      GridRenderContainer.prototype.updateViewableRowRange = function updateViewableRowRange(renderedRange) {
        var rowArr = this.visibleRowCache.slice(renderedRange[0], renderedRange[1]);
        this.currentTopRow = renderedRange[0];
        this.setRenderedRows(rowArr);
      };
      GridRenderContainer.prototype.updateViewableColumnRange = function updateViewableColumnRange(renderedRange) {
        var columnArr = this.visibleColumnCache.slice(renderedRange[0], renderedRange[1]);
        this.currentFirstColumn = renderedRange[0];
        this.setRenderedColumns(columnArr);
      };
      GridRenderContainer.prototype.headerCellWrapperStyle = function() {
        var self = this;
        if (self.currentFirstColumn !== 0) {
          var offset = self.columnOffset;
          if (self.grid.isRTL()) {
            return {'margin-right': offset + 'px'};
          } else {
            return {'margin-left': offset + 'px'};
          }
        }
        return null;
      };
      GridRenderContainer.prototype.updateColumnWidths = function() {
        var self = this;
        var asterisksArray = [],
            asteriskNum = 0,
            usedWidthSum = 0,
            ret = '';
        var availableWidth = self.grid.getViewportWidth() - self.grid.scrollbarWidth;
        var columnCache = [];
        angular.forEach(self.grid.renderContainers, function(container, name) {
          columnCache = columnCache.concat(container.visibleColumnCache);
        });
        columnCache.forEach(function(column, i) {
          var width = 0;
          if (!column.visible) {
            return ;
          }
          if (angular.isNumber(column.width)) {
            width = parseInt(column.width, 10);
            usedWidthSum = usedWidthSum + width;
            column.drawnWidth = width;
          } else if (gridUtil.endsWith(column.width, "%")) {
            width = parseInt(parseInt(column.width.replace(/%/g, ''), 10) / 100 * availableWidth);
            if (width > column.maxWidth) {
              width = column.maxWidth;
            }
            if (width < column.minWidth) {
              width = column.minWidth;
            }
            usedWidthSum = usedWidthSum + width;
            column.drawnWidth = width;
          } else if (angular.isString(column.width) && column.width.indexOf('*') !== -1) {
            asteriskNum = asteriskNum + column.width.length;
            asterisksArray.push(column);
          }
        });
        var remainingWidth = availableWidth - usedWidthSum;
        var i,
            column,
            colWidth;
        if (asterisksArray.length > 0) {
          var asteriskVal = remainingWidth / asteriskNum;
          asterisksArray.forEach(function(column) {
            var width = parseInt(column.width.length * asteriskVal, 10);
            if (width > column.maxWidth) {
              width = column.maxWidth;
            }
            if (width < column.minWidth) {
              width = column.minWidth;
            }
            usedWidthSum = usedWidthSum + width;
            column.drawnWidth = width;
          });
        }
        var processColumnUpwards = function(column) {
          if (column.drawnWidth < column.maxWidth && leftoverWidth > 0) {
            column.drawnWidth++;
            usedWidthSum++;
            leftoverWidth--;
            columnsToChange = true;
          }
        };
        var leftoverWidth = availableWidth - usedWidthSum;
        var columnsToChange = true;
        while (leftoverWidth > 0 && columnsToChange) {
          columnsToChange = false;
          asterisksArray.forEach(processColumnUpwards);
        }
        var processColumnDownwards = function(column) {
          if (column.drawnWidth > column.minWidth && excessWidth > 0) {
            column.drawnWidth--;
            usedWidthSum--;
            excessWidth--;
            columnsToChange = true;
          }
        };
        var excessWidth = usedWidthSum - availableWidth;
        columnsToChange = true;
        while (excessWidth > 0 && columnsToChange) {
          columnsToChange = false;
          asterisksArray.forEach(processColumnDownwards);
        }
        var canvasWidth = 0;
        self.visibleColumnCache.forEach(function(column) {
          if (column.visible) {
            canvasWidth = canvasWidth + column.drawnWidth;
          }
        });
        columnCache.forEach(function(column) {
          ret = ret + column.getColClassDefinition();
        });
        self.canvasWidth = canvasWidth;
        this.columnStyles = ret;
      };
      GridRenderContainer.prototype.needsHScrollbarPlaceholder = function() {
        return this.grid.options.enableHorizontalScrollbar && !this.hasHScrollbar;
      };
      GridRenderContainer.prototype.getViewportStyle = function() {
        var self = this;
        var styles = {};
        self.hasHScrollbar = false;
        self.hasVScrollbar = false;
        if (self.grid.disableScrolling) {
          styles['overflow-x'] = 'hidden';
          styles['overflow-y'] = 'hidden';
          return styles;
        }
        if (self.name === 'body') {
          self.hasHScrollbar = self.grid.options.enableHorizontalScrollbar !== uiGridConstants.scrollbars.NEVER;
          if (!self.grid.isRTL()) {
            if (!self.grid.hasRightContainerColumns()) {
              self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
            }
          } else {
            if (!self.grid.hasLeftContainerColumns()) {
              self.hasVScrollbar = self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER;
            }
          }
        } else if (self.name === 'left') {
          self.hasVScrollbar = self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
        } else {
          self.hasVScrollbar = !self.grid.isRTL() ? self.grid.options.enableVerticalScrollbar !== uiGridConstants.scrollbars.NEVER : false;
        }
        styles['overflow-x'] = self.hasHScrollbar ? 'scroll' : 'hidden';
        styles['overflow-y'] = self.hasVScrollbar ? 'scroll' : 'hidden';
        return styles;
      };
      return GridRenderContainer;
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('GridRow', ['gridUtil', function(gridUtil) {
      function GridRow(entity, index, grid) {
        this.grid = grid;
        this.entity = entity;
        this.uid = gridUtil.nextUid();
        this.visible = true;
        this.$$height = grid.options.rowHeight;
      }
      Object.defineProperty(GridRow.prototype, 'height', {
        get: function() {
          return this.$$height;
        },
        set: function(height) {
          if (height !== this.$$height) {
            this.grid.updateCanvasHeight();
            this.$$height = height;
          }
        }
      });
      GridRow.prototype.getQualifiedColField = function(col) {
        return 'row.' + this.getEntityQualifiedColField(col);
      };
      GridRow.prototype.getEntityQualifiedColField = function(col) {
        return gridUtil.preEval('entity.' + col.field);
      };
      GridRow.prototype.setRowInvisible = function(row) {
        if (row && row.setThisRowInvisible) {
          row.setThisRowInvisible('user');
        }
      };
      GridRow.prototype.clearRowInvisible = function(row) {
        if (row && row.clearThisRowInvisible) {
          row.clearThisRowInvisible('user');
        }
      };
      GridRow.prototype.setThisRowInvisible = function(reason, fromRowsProcessor) {
        if (!this.invisibleReason) {
          this.invisibleReason = {};
        }
        this.invisibleReason[reason] = true;
        this.evaluateRowVisibility(fromRowsProcessor);
      };
      GridRow.prototype.clearThisRowInvisible = function(reason, fromRowsProcessor) {
        if (typeof(this.invisibleReason) !== 'undefined') {
          delete this.invisibleReason[reason];
        }
        this.evaluateRowVisibility(fromRowsProcessor);
      };
      GridRow.prototype.evaluateRowVisibility = function(fromRowProcessor) {
        var newVisibility = true;
        if (typeof(this.invisibleReason) !== 'undefined') {
          angular.forEach(this.invisibleReason, function(value, key) {
            if (value) {
              newVisibility = false;
            }
          });
        }
        if (typeof(this.visible) === 'undefined' || this.visible !== newVisibility) {
          this.visible = newVisibility;
          if (!fromRowProcessor) {
            this.grid.queueGridRefresh();
            this.grid.api.core.raise.rowsVisibleChanged(this);
          }
        }
      };
      return GridRow;
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').factory('GridRowColumn', ['$parse', '$filter', function GridRowColumnFactory($parse, $filter) {
      var GridRowColumn = function GridRowColumn(row, col) {
        if (!(this instanceof GridRowColumn)) {
          throw "Using GridRowColumn as a function insead of as a constructor. Must be called with `new` keyword";
        }
        this.row = row;
        this.col = col;
      };
      GridRowColumn.prototype.getIntersectionValueRaw = function() {
        var getter = $parse(this.row.getEntityQualifiedColField(this.col));
        var context = this.row;
        return getter(context);
      };
      GridRowColumn.prototype.getIntersectionValueFiltered = function() {
        var value = this.getIntersectionValueRaw();
        if (this.col.cellFilter && this.col.cellFilter !== '') {
          var getFilterIfExists = function(filterName) {
            try {
              return $filter(filterName);
            } catch (e) {
              return null;
            }
          };
          var filter = getFilterIfExists(this.col.cellFilter);
          if (filter) {
            value = filter(value);
          } else {
            var re = /([^:]*):([^:]*):?([\s\S]+)?/;
            var matches;
            if ((matches = re.exec(this.col.cellFilter)) !== null) {
              value = $filter(matches[1])(value, matches[2], matches[3]);
            }
          }
        }
        return value;
      };
      return GridRowColumn;
    }]);
  })();
  (function() {
    angular.module('ui.grid').factory('ScrollEvent', ['gridUtil', function(gridUtil) {
      function ScrollEvent(grid, sourceRowContainer, sourceColContainer, source) {
        var self = this;
        if (!grid) {
          throw new Error("grid argument is required");
        }
        self.grid = grid;
        self.source = source;
        self.withDelay = true;
        self.sourceRowContainer = sourceRowContainer;
        self.sourceColContainer = sourceColContainer;
        self.newScrollLeft = null;
        self.newScrollTop = null;
        self.x = null;
        self.y = null;
        self.verticalScrollLength = -9999999;
        self.horizontalScrollLength = -999999;
        self.fireThrottledScrollingEvent = gridUtil.throttle(function(sourceContainerId) {
          self.grid.scrollContainers(sourceContainerId, self);
        }, self.grid.options.wheelScrollThrottle, {trailing: true});
      }
      ScrollEvent.prototype.getNewScrollLeft = function(colContainer, viewport) {
        var self = this;
        if (!self.newScrollLeft) {
          var scrollWidth = (colContainer.getCanvasWidth() - colContainer.getViewportWidth());
          var oldScrollLeft = gridUtil.normalizeScrollLeft(viewport, self.grid);
          var scrollXPercentage;
          if (typeof(self.x.percentage) !== 'undefined' && self.x.percentage !== undefined) {
            scrollXPercentage = self.x.percentage;
          } else if (typeof(self.x.pixels) !== 'undefined' && self.x.pixels !== undefined) {
            scrollXPercentage = self.x.percentage = (oldScrollLeft + self.x.pixels) / scrollWidth;
          } else {
            throw new Error("No percentage or pixel value provided for scroll event X axis");
          }
          return Math.max(0, scrollXPercentage * scrollWidth);
        }
        return self.newScrollLeft;
      };
      ScrollEvent.prototype.getNewScrollTop = function(rowContainer, viewport) {
        var self = this;
        if (!self.newScrollTop) {
          var scrollLength = rowContainer.getVerticalScrollLength();
          var oldScrollTop = viewport[0].scrollTop;
          var scrollYPercentage;
          if (typeof(self.y.percentage) !== 'undefined' && self.y.percentage !== undefined) {
            scrollYPercentage = self.y.percentage;
          } else if (typeof(self.y.pixels) !== 'undefined' && self.y.pixels !== undefined) {
            scrollYPercentage = self.y.percentage = (oldScrollTop + self.y.pixels) / scrollLength;
          } else {
            throw new Error("No percentage or pixel value provided for scroll event Y axis");
          }
          return Math.max(0, scrollYPercentage * scrollLength);
        }
        return self.newScrollTop;
      };
      ScrollEvent.prototype.atTop = function(scrollTop) {
        return (this.y && (this.y.percentage === 0 || this.verticalScrollLength < 0) && scrollTop === 0);
      };
      ScrollEvent.prototype.atBottom = function(scrollTop) {
        return (this.y && (this.y.percentage === 1 || this.verticalScrollLength === 0) && scrollTop > 0);
      };
      ScrollEvent.prototype.atLeft = function(scrollLeft) {
        return (this.x && (this.x.percentage === 0 || this.horizontalScrollLength < 0) && scrollLeft === 0);
      };
      ScrollEvent.prototype.atRight = function(scrollLeft) {
        return (this.x && (this.x.percentage === 1 || this.horizontalScrollLength === 0) && scrollLeft > 0);
      };
      ScrollEvent.Sources = {
        ViewPortScroll: 'ViewPortScroll',
        RenderContainerMouseWheel: 'RenderContainerMouseWheel',
        RenderContainerTouchMove: 'RenderContainerTouchMove',
        Other: 99
      };
      return ScrollEvent;
    }]);
  })();
  (function() {
    'use strict';
    angular.module('ui.grid').service('gridClassFactory', ['gridUtil', '$q', '$compile', '$templateCache', 'uiGridConstants', 'Grid', 'GridColumn', 'GridRow', function(gridUtil, $q, $compile, $templateCache, uiGridConstants, Grid, GridColumn, GridRow) {
      var service = {
        createGrid: function(options) {
          options = (typeof(options) !== 'undefined') ? options : {};
          options.id = gridUtil.newId();
          var grid = new Grid(options);
          if (grid.options.rowTemplate) {
            var rowTemplateFnPromise = $q.defer();
            grid.getRowTemplateFn = rowTemplateFnPromise.promise;
            gridUtil.getTemplate(grid.options.rowTemplate).then(function(template) {
              var rowTemplateFn = $compile(template);
              rowTemplateFnPromise.resolve(rowTemplateFn);
            }, function(res) {
              throw new Error("Couldn't fetch/use row template '" + grid.options.rowTemplate + "'");
            });
          }
          grid.registerColumnBuilder(service.defaultColumnBuilder);
          grid.registerRowBuilder(service.rowTemplateAssigner);
          grid.registerRowsProcessor(function allRowsVisible(rows) {
            rows.forEach(function(row) {
              row.evaluateRowVisibility(true);
            }, 50);
            return rows;
          });
          grid.registerColumnsProcessor(function allColumnsVisible(columns) {
            columns.forEach(function(column) {
              column.visible = true;
            });
            return columns;
          }, 50);
          grid.registerColumnsProcessor(function(renderableColumns) {
            renderableColumns.forEach(function(column) {
              if (column.colDef.visible === false) {
                column.visible = false;
              }
            });
            return renderableColumns;
          }, 50);
          grid.registerRowsProcessor(grid.searchRows, 100);
          if (grid.options.externalSort && angular.isFunction(grid.options.externalSort)) {
            grid.registerRowsProcessor(grid.options.externalSort, 200);
          } else {
            grid.registerRowsProcessor(grid.sortByColumn, 200);
          }
          return grid;
        },
        defaultColumnBuilder: function(colDef, col, gridOptions) {
          var templateGetPromises = [];
          var processTemplate = function(templateType, providedType, defaultTemplate, filterType, tooltipType) {
            if (!colDef[templateType]) {
              col[providedType] = defaultTemplate;
            } else {
              col[providedType] = colDef[templateType];
            }
            templateGetPromises.push(gridUtil.getTemplate(col[providedType]).then(function(template) {
              if (angular.isFunction(template)) {
                template = template();
              }
              var tooltipCall = (tooltipType === 'cellTooltip') ? 'col.cellTooltip(row,col)' : 'col.headerTooltip(col)';
              if (tooltipType && col[tooltipType] === false) {
                template = template.replace(uiGridConstants.TOOLTIP, '');
              } else if (tooltipType && col[tooltipType]) {
                template = template.replace(uiGridConstants.TOOLTIP, 'title="{{' + tooltipCall + ' CUSTOM_FILTERS }}"');
              }
              if (filterType) {
                col[templateType] = template.replace(uiGridConstants.CUSTOM_FILTERS, function() {
                  return col[filterType] ? "|" + col[filterType] : "";
                });
              } else {
                col[templateType] = template;
              }
            }, function(res) {
              throw new Error("Couldn't fetch/use colDef." + templateType + " '" + colDef[templateType] + "'");
            }));
          };
          processTemplate('cellTemplate', 'providedCellTemplate', 'ui-grid/uiGridCell', 'cellFilter', 'cellTooltip');
          col.cellTemplatePromise = templateGetPromises[0];
          processTemplate('headerCellTemplate', 'providedHeaderCellTemplate', 'ui-grid/uiGridHeaderCell', 'headerCellFilter', 'headerTooltip');
          processTemplate('footerCellTemplate', 'providedFooterCellTemplate', 'ui-grid/uiGridFooterCell', 'footerCellFilter');
          processTemplate('filterHeaderTemplate', 'providedFilterHeaderTemplate', 'ui-grid/ui-grid-filter');
          col.compiledElementFnDefer = $q.defer();
          return $q.all(templateGetPromises);
        },
        rowTemplateAssigner: function rowTemplateAssigner(row) {
          var grid = this;
          if (!row.rowTemplate) {
            row.rowTemplate = grid.options.rowTemplate;
            row.getRowTemplateFn = grid.getRowTemplateFn;
          } else {
            var perRowTemplateFnPromise = $q.defer();
            row.getRowTemplateFn = perRowTemplateFnPromise.promise;
            gridUtil.getTemplate(row.rowTemplate).then(function(template) {
              var rowTemplateFn = $compile(template);
              perRowTemplateFnPromise.resolve(rowTemplateFn);
            }, function(res) {
              throw new Error("Couldn't fetch/use row template '" + row.rowTemplate + "'");
            });
          }
          return row.getRowTemplateFn;
        }
      };
      return service;
    }]);
  })();
  (function() {
    var module = angular.module('ui.grid');
    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    module.service('rowSearcher', ['gridUtil', 'uiGridConstants', function(gridUtil, uiGridConstants) {
      var defaultCondition = uiGridConstants.filter.CONTAINS;
      var rowSearcher = {};
      rowSearcher.getTerm = function getTerm(filter) {
        if (typeof(filter.term) === 'undefined') {
          return filter.term;
        }
        var term = filter.term;
        if (typeof(term) === 'string') {
          term = term.trim();
        }
        return term;
      };
      rowSearcher.stripTerm = function stripTerm(filter) {
        var term = rowSearcher.getTerm(filter);
        if (typeof(term) === 'string') {
          return escapeRegExp(term.replace(/(^\*|\*$)/g, ''));
        } else {
          return term;
        }
      };
      rowSearcher.guessCondition = function guessCondition(filter) {
        if (typeof(filter.term) === 'undefined' || !filter.term) {
          return defaultCondition;
        }
        var term = rowSearcher.getTerm(filter);
        if (/\*/.test(term)) {
          var regexpFlags = '';
          if (!filter.flags || !filter.flags.caseSensitive) {
            regexpFlags += 'i';
          }
          var reText = term.replace(/(\\)?\*/g, function($0, $1) {
            return $1 ? $0 : '[\\s\\S]*?';
          });
          return new RegExp('^' + reText + '$', regexpFlags);
        } else {
          return defaultCondition;
        }
      };
      rowSearcher.setupFilters = function setupFilters(filters) {
        var newFilters = [];
        var filtersLength = filters.length;
        for (var i = 0; i < filtersLength; i++) {
          var filter = filters[i];
          if (filter.noTerm || !gridUtil.isNullOrUndefined(filter.term)) {
            var newFilter = {};
            var regexpFlags = '';
            if (!filter.flags || !filter.flags.caseSensitive) {
              regexpFlags += 'i';
            }
            if (!gridUtil.isNullOrUndefined(filter.term)) {
              newFilter.term = rowSearcher.stripTerm(filter);
            }
            if (filter.condition) {
              newFilter.condition = filter.condition;
            } else {
              newFilter.condition = rowSearcher.guessCondition(filter);
            }
            newFilter.flags = angular.extend({
              caseSensitive: false,
              date: false
            }, filter.flags);
            if (newFilter.condition === uiGridConstants.filter.STARTS_WITH) {
              newFilter.startswithRE = new RegExp('^' + newFilter.term, regexpFlags);
            }
            if (newFilter.condition === uiGridConstants.filter.ENDS_WITH) {
              newFilter.endswithRE = new RegExp(newFilter.term + '$', regexpFlags);
            }
            if (newFilter.condition === uiGridConstants.filter.CONTAINS) {
              newFilter.containsRE = new RegExp(newFilter.term, regexpFlags);
            }
            if (newFilter.condition === uiGridConstants.filter.EXACT) {
              newFilter.exactRE = new RegExp('^' + newFilter.term + '$', regexpFlags);
            }
            newFilters.push(newFilter);
          }
        }
        return newFilters;
      };
      rowSearcher.runColumnFilter = function runColumnFilter(grid, row, column, filter) {
        var conditionType = typeof(filter.condition);
        var term = filter.term;
        var value;
        if (column.filterCellFiltered) {
          value = grid.getCellDisplayValue(row, column);
        } else {
          value = grid.getCellValue(row, column);
        }
        if (filter.condition instanceof RegExp) {
          return filter.condition.test(value);
        }
        if (conditionType === 'function') {
          return filter.condition(term, value, row, column);
        }
        if (filter.startswithRE) {
          return filter.startswithRE.test(value);
        }
        if (filter.endswithRE) {
          return filter.endswithRE.test(value);
        }
        if (filter.containsRE) {
          return filter.containsRE.test(value);
        }
        if (filter.exactRE) {
          return filter.exactRE.test(value);
        }
        if (filter.condition === uiGridConstants.filter.NOT_EQUAL) {
          var regex = new RegExp('^' + term + '$');
          return !regex.exec(value);
        }
        if (typeof(value) === 'number' && typeof(term) === 'string') {
          var tempFloat = parseFloat(term.replace(/\\\./, '.').replace(/\\\-/, '-'));
          if (!isNaN(tempFloat)) {
            term = tempFloat;
          }
        }
        if (filter.flags.date === true) {
          value = new Date(value);
          term = new Date(term.replace(/\\/g, ''));
        }
        if (filter.condition === uiGridConstants.filter.GREATER_THAN) {
          return (value > term);
        }
        if (filter.condition === uiGridConstants.filter.GREATER_THAN_OR_EQUAL) {
          return (value >= term);
        }
        if (filter.condition === uiGridConstants.filter.LESS_THAN) {
          return (value < term);
        }
        if (filter.condition === uiGridConstants.filter.LESS_THAN_OR_EQUAL) {
          return (value <= term);
        }
        return true;
      };
      rowSearcher.searchColumn = function searchColumn(grid, row, column, filters) {
        if (grid.options.useExternalFiltering) {
          return true;
        }
        var filtersLength = filters.length;
        for (var i = 0; i < filtersLength; i++) {
          var filter = filters[i];
          var ret = rowSearcher.runColumnFilter(grid, row, column, filter);
          if (!ret) {
            return false;
          }
        }
        return true;
      };
      rowSearcher.search = function search(grid, rows, columns) {
        if (!rows) {
          return ;
        }
        if (!grid.options.enableFiltering) {
          return rows;
        }
        var filterData = [];
        var colsLength = columns.length;
        var hasTerm = function(filters) {
          var hasTerm = false;
          filters.forEach(function(filter) {
            if (!gridUtil.isNullOrUndefined(filter.term) && filter.term !== '' || filter.noTerm) {
              hasTerm = true;
            }
          });
          return hasTerm;
        };
        for (var i = 0; i < colsLength; i++) {
          var col = columns[i];
          if (typeof(col.filters) !== 'undefined' && hasTerm(col.filters)) {
            filterData.push({
              col: col,
              filters: rowSearcher.setupFilters(col.filters)
            });
          }
        }
        if (filterData.length > 0) {
          var foreachRow = function(grid, row, col, filters) {
            if (row.visible && !rowSearcher.searchColumn(grid, row, col, filters)) {
              row.visible = false;
            }
          };
          var foreachFilterCol = function(grid, filterData) {
            var rowsLength = rows.length;
            for (var i = 0; i < rowsLength; i++) {
              foreachRow(grid, rows[i], filterData.col, filterData.filters);
            }
          };
          var filterDataLength = filterData.length;
          for (var j = 0; j < filterDataLength; j++) {
            foreachFilterCol(grid, filterData[j]);
          }
          if (grid.api.core.raise.rowsVisibleChanged) {
            grid.api.core.raise.rowsVisibleChanged();
          }
        }
        return rows;
      };
      return rowSearcher;
    }]);
  })();
  (function() {
    var module = angular.module('ui.grid');
    module.service('rowSorter', ['$parse', 'uiGridConstants', function($parse, uiGridConstants) {
      var currencyRegexStr = '(' + uiGridConstants.CURRENCY_SYMBOLS.map(function(a) {
        return '\\' + a;
      }).join('|') + ')?';
      var numberStrRegex = new RegExp('^[-+]?' + currencyRegexStr + '[\\d,.]+' + currencyRegexStr + '%?$');
      var rowSorter = {colSortFnCache: {}};
      rowSorter.guessSortFn = function guessSortFn(itemType) {
        switch (itemType) {
          case "number":
            return rowSorter.sortNumber;
          case "numberStr":
            return rowSorter.sortNumberStr;
          case "boolean":
            return rowSorter.sortBool;
          case "string":
            return rowSorter.sortAlpha;
          case "date":
            return rowSorter.sortDate;
          case "object":
            return rowSorter.basicSort;
          default:
            throw new Error('No sorting function found for type:' + itemType);
        }
      };
      rowSorter.handleNulls = function handleNulls(a, b) {
        if ((!a && a !== 0 && a !== false) || (!b && b !== 0 && b !== false)) {
          if ((!a && a !== 0 && a !== false) && (!b && b !== 0 && b !== false)) {
            return 0;
          } else if (!a && a !== 0 && a !== false) {
            return 1;
          } else if (!b && b !== 0 && b !== false) {
            return -1;
          }
        }
        return null;
      };
      rowSorter.basicSort = function basicSort(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          if (a === b) {
            return 0;
          }
          if (a < b) {
            return -1;
          }
          return 1;
        }
      };
      rowSorter.sortNumber = function sortNumber(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          return a - b;
        }
      };
      rowSorter.sortNumberStr = function sortNumberStr(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          var numA,
              numB,
              badA = false,
              badB = false;
          numA = parseFloat(a.replace(/[^0-9.-]/g, ''));
          if (isNaN(numA)) {
            badA = true;
          }
          numB = parseFloat(b.replace(/[^0-9.-]/g, ''));
          if (isNaN(numB)) {
            badB = true;
          }
          if (badA && badB) {
            return 0;
          }
          if (badA) {
            return 1;
          }
          if (badB) {
            return -1;
          }
          return numA - numB;
        }
      };
      rowSorter.sortAlpha = function sortAlpha(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          var strA = a.toString().toLowerCase(),
              strB = b.toString().toLowerCase();
          return strA === strB ? 0 : (strA < strB ? -1 : 1);
        }
      };
      rowSorter.sortDate = function sortDate(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          if (!(a instanceof Date)) {
            a = new Date(a);
          }
          if (!(b instanceof Date)) {
            b = new Date(b);
          }
          var timeA = a.getTime(),
              timeB = b.getTime();
          return timeA === timeB ? 0 : (timeA < timeB ? -1 : 1);
        }
      };
      rowSorter.sortBool = function sortBool(a, b) {
        var nulls = rowSorter.handleNulls(a, b);
        if (nulls !== null) {
          return nulls;
        } else {
          if (a && b) {
            return 0;
          }
          if (!a && !b) {
            return 0;
          } else {
            return a ? 1 : -1;
          }
        }
      };
      rowSorter.getSortFn = function getSortFn(grid, col, rows) {
        var sortFn,
            item;
        if (rowSorter.colSortFnCache[col.colDef.name]) {
          sortFn = rowSorter.colSortFnCache[col.colDef.name];
        } else if (col.sortingAlgorithm !== undefined) {
          sortFn = col.sortingAlgorithm;
          rowSorter.colSortFnCache[col.colDef.name] = col.sortingAlgorithm;
        } else if (col.sortCellFiltered && col.cellFilter) {
          sortFn = rowSorter.sortAlpha;
          rowSorter.colSortFnCache[col.colDef.name] = sortFn;
        } else {
          sortFn = rowSorter.guessSortFn(col.colDef.type);
          if (sortFn) {
            rowSorter.colSortFnCache[col.colDef.name] = sortFn;
          } else {
            sortFn = rowSorter.sortAlpha;
          }
        }
        return sortFn;
      };
      rowSorter.prioritySort = function(a, b) {
        if (a.sort.priority !== undefined && b.sort.priority !== undefined) {
          if (a.sort.priority < b.sort.priority) {
            return -1;
          } else if (a.sort.priority === b.sort.priority) {
            return 0;
          } else {
            return 1;
          }
        } else if (a.sort.priority || a.sort.priority === 0) {
          return -1;
        } else if (b.sort.priority || b.sort.priority === 0) {
          return 1;
        } else {
          return 0;
        }
      };
      rowSorter.sort = function rowSorterSort(grid, rows, columns) {
        if (!rows) {
          return ;
        }
        if (grid.options.useExternalSorting) {
          return rows;
        }
        var sortCols = [];
        columns.forEach(function(col) {
          if (col.sort && !col.sort.ignoreSort && col.sort.direction && (col.sort.direction === uiGridConstants.ASC || col.sort.direction === uiGridConstants.DESC)) {
            sortCols.push(col);
          }
        });
        sortCols = sortCols.sort(rowSorter.prioritySort);
        if (sortCols.length === 0) {
          return rows;
        }
        var col,
            direction;
        var setIndex = function(row, idx) {
          row.entity.$$uiGridIndex = idx;
        };
        rows.forEach(setIndex);
        var r = rows.slice(0);
        var rowSortFn = function(rowA, rowB) {
          var tem = 0,
              idx = 0,
              sortFn;
          while (tem === 0 && idx < sortCols.length) {
            col = sortCols[idx];
            direction = sortCols[idx].sort.direction;
            sortFn = rowSorter.getSortFn(grid, col, r);
            var propA,
                propB;
            if (col.sortCellFiltered) {
              propA = grid.getCellDisplayValue(rowA, col);
              propB = grid.getCellDisplayValue(rowB, col);
            } else {
              propA = grid.getCellValue(rowA, col);
              propB = grid.getCellValue(rowB, col);
            }
            tem = sortFn(propA, propB);
            idx++;
          }
          if (tem === 0) {
            return rowA.entity.$$uiGridIndex - rowB.entity.$$uiGridIndex;
          }
          if (direction === uiGridConstants.ASC) {
            return tem;
          } else {
            return 0 - tem;
          }
        };
        var newRows = rows.sort(rowSortFn);
        var clearIndex = function(row, idx) {
          delete row.entity.$$uiGridIndex;
        };
        rows.forEach(clearIndex);
        return newRows;
      };
      return rowSorter;
    }]);
  })();
  (function() {
    var module = angular.module('ui.grid');
    var bindPolyfill;
    if (typeof Function.prototype.bind !== "function") {
      bindPolyfill = function() {
        var slice = Array.prototype.slice;
        return function(context) {
          var fn = this,
              args = slice.call(arguments, 1);
          if (args.length) {
            return function() {
              return arguments.length ? fn.apply(context, args.concat(slice.call(arguments))) : fn.apply(context, args);
            };
          }
          return function() {
            return arguments.length ? fn.apply(context, arguments) : fn.call(context);
          };
        };
      };
    }
    function getStyles(elem) {
      var e = elem;
      if (typeof(e.length) !== 'undefined' && e.length) {
        e = elem[0];
      }
      return e.ownerDocument.defaultView.getComputedStyle(e, null);
    }
    var rnumnonpx = new RegExp("^(" + (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source + ")(?!px)[a-z%]+$", "i"),
        rdisplayswap = /^(block|none|table(?!-c[ea]).+)/,
        cssShow = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
        };
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
      var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0,
          val = 0;
      var sides = ['Top', 'Right', 'Bottom', 'Left'];
      for (; i < 4; i += 2) {
        var side = sides[i];
        if (extra === 'margin') {
          var marg = parseFloat(styles[extra + side]);
          if (!isNaN(marg)) {
            val += marg;
          }
        }
        if (isBorderBox) {
          if (extra === 'content') {
            var padd = parseFloat(styles['padding' + side]);
            if (!isNaN(padd)) {
              val -= padd;
            }
          }
          if (extra !== 'margin') {
            var bordermarg = parseFloat(styles['border' + side + 'Width']);
            if (!isNaN(bordermarg)) {
              val -= bordermarg;
            }
          }
        } else {
          var nocontentPad = parseFloat(styles['padding' + side]);
          if (!isNaN(nocontentPad)) {
            val += nocontentPad;
          }
          if (extra !== 'padding') {
            var nocontentnopad = parseFloat(styles['border' + side + 'Width']);
            if (!isNaN(nocontentnopad)) {
              val += nocontentnopad;
            }
          }
        }
      }
      return val;
    }
    function getWidthOrHeight(elem, name, extra) {
      var valueIsBorderBox = true,
          val,
          styles = getStyles(elem),
          isBorderBox = styles['boxSizing'] === 'border-box';
      if (val <= 0 || val == null) {
        val = styles[name];
        if (val < 0 || val == null) {
          val = elem.style[name];
        }
        if (rnumnonpx.test(val)) {
          return val;
        }
        valueIsBorderBox = isBorderBox && (true || val === elem.style[name]);
        val = parseFloat(val) || 0;
      }
      var ret = (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles));
      return ret;
    }
    function getLineHeight(elm) {
      elm = angular.element(elm)[0];
      var parent = elm.parentElement;
      if (!parent) {
        parent = document.getElementsByTagName('body')[0];
      }
      return parseInt(getStyles(parent).fontSize) || parseInt(getStyles(elm).fontSize) || 16;
    }
    var uid = ['0', '0', '0', '0'];
    var uidPrefix = 'uiGrid-';
    module.service('gridUtil', ['$log', '$window', '$document', '$http', '$templateCache', '$timeout', '$interval', '$injector', '$q', '$interpolate', 'uiGridConstants', function($log, $window, $document, $http, $templateCache, $timeout, $interval, $injector, $q, $interpolate, uiGridConstants) {
      var s = {
        augmentWidthOrHeight: augmentWidthOrHeight,
        getStyles: getStyles,
        createBoundedWrapper: function(object, method) {
          return function() {
            return method.apply(object, arguments);
          };
        },
        readableColumnName: function(columnName) {
          if (typeof(columnName) === 'undefined' || columnName === undefined || columnName === null) {
            return columnName;
          }
          if (typeof(columnName) !== 'string') {
            columnName = String(columnName);
          }
          return columnName.replace(/_+/g, ' ').replace(/^[A-Z]+$/, function(match) {
            return angular.lowercase(angular.uppercase(match.charAt(0)) + match.slice(1));
          }).replace(/([\w\u00C0-\u017F]+)/g, function(match) {
            return angular.uppercase(match.charAt(0)) + match.slice(1);
          }).replace(/(\w+?(?=[A-Z]))/g, '$1 ');
        },
        getColumnsFromData: function(data, excludeProperties) {
          var columnDefs = [];
          if (!data || typeof(data[0]) === 'undefined' || data[0] === undefined) {
            return [];
          }
          if (angular.isUndefined(excludeProperties)) {
            excludeProperties = [];
          }
          var item = data[0];
          angular.forEach(item, function(prop, propName) {
            if (excludeProperties.indexOf(propName) === -1) {
              columnDefs.push({name: propName});
            }
          });
          return columnDefs;
        },
        newId: (function() {
          var seedId = new Date().getTime();
          return function() {
            return seedId += 1;
          };
        })(),
        getTemplate: function(template) {
          if ($templateCache.get(template)) {
            return s.postProcessTemplate($templateCache.get(template));
          }
          if (template.hasOwnProperty('then')) {
            return template.then(s.postProcessTemplate);
          }
          try {
            if (angular.element(template).length > 0) {
              return $q.when(template).then(s.postProcessTemplate);
            }
          } catch (err) {}
          s.logDebug('fetching url', template);
          return $http({
            method: 'GET',
            url: template
          }).then(function(result) {
            var templateHtml = result.data.trim();
            $templateCache.put(template, templateHtml);
            return templateHtml;
          }, function(err) {
            throw new Error("Could not get template " + template + ": " + err);
          }).then(s.postProcessTemplate);
        },
        postProcessTemplate: function(template) {
          var startSym = $interpolate.startSymbol(),
              endSym = $interpolate.endSymbol();
          if (startSym !== '{{' || endSym !== '}}') {
            template = template.replace(/\{\{/g, startSym);
            template = template.replace(/\}\}/g, endSym);
          }
          return $q.when(template);
        },
        guessType: function(item) {
          var itemType = typeof(item);
          switch (itemType) {
            case "number":
            case "boolean":
            case "string":
              return itemType;
            default:
              if (angular.isDate(item)) {
                return "date";
              }
              return "object";
          }
        },
        elementWidth: function(elem) {},
        elementHeight: function(elem) {},
        getScrollbarWidth: function() {
          var outer = document.createElement("div");
          outer.style.visibility = "hidden";
          outer.style.width = "100px";
          outer.style.msOverflowStyle = "scrollbar";
          document.body.appendChild(outer);
          var widthNoScroll = outer.offsetWidth;
          outer.style.overflow = "scroll";
          var inner = document.createElement("div");
          inner.style.width = "100%";
          outer.appendChild(inner);
          var widthWithScroll = inner.offsetWidth;
          outer.parentNode.removeChild(outer);
          return widthNoScroll - widthWithScroll;
        },
        swap: function(elem, options, callback, args) {
          var ret,
              name,
              old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.apply(elem, args || []);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        },
        fakeElement: function(elem, options, callback, args) {
          var ret,
              name,
              newElement = angular.element(elem).clone()[0];
          for (name in options) {
            newElement.style[name] = options[name];
          }
          angular.element(document.body).append(newElement);
          ret = callback.call(newElement, newElement);
          angular.element(newElement).remove();
          return ret;
        },
        normalizeWheelEvent: function(event) {
          var lowestDelta,
              lowestDeltaXY;
          var orgEvent = event || window.event,
              args = [].slice.call(arguments, 1),
              delta = 0,
              deltaX = 0,
              deltaY = 0,
              absDelta = 0,
              absDeltaXY = 0,
              fn;
          if (orgEvent.originalEvent) {
            orgEvent = orgEvent.originalEvent;
          }
          if (orgEvent.wheelDelta) {
            delta = orgEvent.wheelDelta;
          }
          if (orgEvent.detail) {
            delta = orgEvent.detail * -1;
          }
          deltaY = delta;
          if (orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaY = 0;
            deltaX = delta * -1;
          }
          if (orgEvent.deltaY) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
          }
          if (orgEvent.deltaX) {
            deltaX = orgEvent.deltaX;
            delta = deltaX * -1;
          }
          if (orgEvent.wheelDeltaY !== undefined) {
            deltaY = orgEvent.wheelDeltaY;
          }
          if (orgEvent.wheelDeltaX !== undefined) {
            deltaX = orgEvent.wheelDeltaX;
          }
          absDelta = Math.abs(delta);
          if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;
          }
          absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
          if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
            lowestDeltaXY = absDeltaXY;
          }
          fn = delta > 0 ? 'floor' : 'ceil';
          delta = Math[fn](delta / lowestDelta);
          deltaX = Math[fn](deltaX / lowestDeltaXY);
          deltaY = Math[fn](deltaY / lowestDeltaXY);
          return {
            delta: delta,
            deltaX: deltaX,
            deltaY: deltaY
          };
        },
        isTouchEnabled: function() {
          var bool;
          if (('ontouchstart' in $window) || $window.DocumentTouch && $document instanceof DocumentTouch) {
            bool = true;
          }
          return bool;
        },
        isNullOrUndefined: function(obj) {
          if (obj === undefined || obj === null) {
            return true;
          }
          return false;
        },
        endsWith: function(str, suffix) {
          if (!str || !suffix || typeof str !== "string") {
            return false;
          }
          return str.indexOf(suffix, str.length - suffix.length) !== -1;
        },
        arrayContainsObjectWithProperty: function(array, propertyName, propertyValue) {
          var found = false;
          angular.forEach(array, function(object) {
            if (object[propertyName] === propertyValue) {
              found = true;
            }
          });
          return found;
        },
        numericAndNullSort: function(a, b) {
          if (a === null) {
            return 1;
          }
          if (b === null) {
            return -1;
          }
          if (a === null && b === null) {
            return 0;
          }
          return a - b;
        },
        disableAnimations: function(element) {
          var $animate;
          try {
            $animate = $injector.get('$animate');
            if (angular.version.major > 1 || (angular.version.major === 1 && angular.version.minor >= 4)) {
              $animate.enabled(element, false);
            } else {
              $animate.enabled(false, element);
            }
          } catch (e) {}
        },
        enableAnimations: function(element) {
          var $animate;
          try {
            $animate = $injector.get('$animate');
            if (angular.version.major > 1 || (angular.version.major === 1 && angular.version.minor >= 4)) {
              $animate.enabled(element, true);
            } else {
              $animate.enabled(true, element);
            }
            return $animate;
          } catch (e) {}
        },
        nextUid: function nextUid() {
          var index = uid.length;
          var digit;
          while (index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit === 57) {
              uid[index] = 'A';
              return uidPrefix + uid.join('');
            }
            if (digit === 90) {
              uid[index] = '0';
            } else {
              uid[index] = String.fromCharCode(digit + 1);
              return uidPrefix + uid.join('');
            }
          }
          uid.unshift('0');
          return uidPrefix + uid.join('');
        },
        hashKey: function hashKey(obj) {
          var objType = typeof obj,
              key;
          if (objType === 'object' && obj !== null) {
            if (typeof(key = obj.$$hashKey) === 'function') {
              key = obj.$$hashKey();
            } else if (typeof(obj.$$hashKey) !== 'undefined' && obj.$$hashKey) {
              key = obj.$$hashKey;
            } else if (key === undefined) {
              key = obj.$$hashKey = s.nextUid();
            }
          } else {
            key = obj;
          }
          return objType + ':' + key;
        },
        resetUids: function() {
          uid = ['0', '0', '0'];
        },
        logError: function(logMessage) {
          if (uiGridConstants.LOG_ERROR_MESSAGES) {
            $log.error(logMessage);
          }
        },
        logWarn: function(logMessage) {
          if (uiGridConstants.LOG_WARN_MESSAGES) {
            $log.warn(logMessage);
          }
        },
        logDebug: function() {
          if (uiGridConstants.LOG_DEBUG_MESSAGES) {
            $log.debug.apply($log, arguments);
          }
        }
      };
      s.focus = {
        queue: [],
        byId: function(id, Grid) {
          this._purgeQueue();
          var promise = $timeout(function() {
            var elementID = (Grid && Grid.id ? Grid.id + '-' : '') + id;
            var element = $window.document.getElementById(elementID);
            if (element) {
              element.focus();
            } else {
              s.logWarn('[focus.byId] Element id ' + elementID + ' was not found.');
            }
          });
          this.queue.push(promise);
          return promise;
        },
        byElement: function(element) {
          if (!angular.isElement(element)) {
            s.logWarn("Trying to focus on an element that isn\'t an element.");
            return $q.reject('not-element');
          }
          element = angular.element(element);
          this._purgeQueue();
          var promise = $timeout(function() {
            if (element) {
              element[0].focus();
            }
          });
          this.queue.push(promise);
          return promise;
        },
        bySelector: function(parentElement, querySelector, aSync) {
          var self = this;
          if (!angular.isElement(parentElement)) {
            throw new Error("The parent element is not an element.");
          }
          parentElement = angular.element(parentElement);
          var focusBySelector = function() {
            var element = parentElement[0].querySelector(querySelector);
            return self.byElement(element);
          };
          this._purgeQueue();
          if (aSync) {
            var promise = $timeout(focusBySelector);
            this.queue.push($timeout(focusBySelector));
            return promise;
          } else {
            return focusBySelector();
          }
        },
        _purgeQueue: function() {
          this.queue.forEach(function(element) {
            $timeout.cancel(element);
          });
          this.queue = [];
        }
      };
      ['width', 'height'].forEach(function(name) {
        var capsName = angular.uppercase(name.charAt(0)) + name.substr(1);
        s['element' + capsName] = function(elem, extra) {
          var e = elem;
          if (e && typeof(e.length) !== 'undefined' && e.length) {
            e = elem[0];
          }
          if (e) {
            var styles = getStyles(e);
            return e.offsetWidth === 0 && rdisplayswap.test(styles.display) ? s.swap(e, cssShow, function() {
              return getWidthOrHeight(e, name, extra);
            }) : getWidthOrHeight(e, name, extra);
          } else {
            return null;
          }
        };
        s['outerElement' + capsName] = function(elem, margin) {
          return elem ? s['element' + capsName].call(this, elem, margin ? 'margin' : 'border') : null;
        };
      });
      s.closestElm = function closestElm(el, selector) {
        if (typeof(el.length) !== 'undefined' && el.length) {
          el = el[0];
        }
        var matchesFn;
        ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function(fn) {
          if (typeof document.body[fn] === 'function') {
            matchesFn = fn;
            return true;
          }
          return false;
        });
        var parent;
        while (el !== null) {
          parent = el.parentElement;
          if (parent !== null && parent[matchesFn](selector)) {
            return parent;
          }
          el = parent;
        }
        return null;
      };
      s.type = function(obj) {
        var text = Function.prototype.toString.call(obj.constructor);
        return text.match(/function (.*?)\(/)[1];
      };
      s.getBorderSize = function getBorderSize(elem, borderType) {
        if (typeof(elem.length) !== 'undefined' && elem.length) {
          elem = elem[0];
        }
        var styles = getStyles(elem);
        if (borderType) {
          borderType = 'border' + borderType.charAt(0).toUpperCase() + borderType.slice(1);
        } else {
          borderType = 'border';
        }
        borderType += 'Width';
        var val = parseInt(styles[borderType], 10);
        if (isNaN(val)) {
          return 0;
        } else {
          return val;
        }
      };
      s.detectBrowser = function detectBrowser() {
        var userAgent = $window.navigator.userAgent;
        var browsers = {
          chrome: /chrome/i,
          safari: /safari/i,
          firefox: /firefox/i,
          ie: /internet explorer|trident\//i
        };
        for (var key in browsers) {
          if (browsers[key].test(userAgent)) {
            return key;
          }
        }
        return 'unknown';
      };
      s.rtlScrollType = function rtlScrollType() {
        if (rtlScrollType.type) {
          return rtlScrollType.type;
        }
        var definer = angular.element('<div dir="rtl" style="font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll">A</div>')[0],
            type = 'reverse';
        document.body.appendChild(definer);
        if (definer.scrollLeft > 0) {
          type = 'default';
        } else {
          definer.scrollLeft = 1;
          if (definer.scrollLeft === 0) {
            type = 'negative';
          }
        }
        angular.element(definer).remove();
        rtlScrollType.type = type;
        return type;
      };
      s.normalizeScrollLeft = function normalizeScrollLeft(element, grid) {
        if (typeof(element.length) !== 'undefined' && element.length) {
          element = element[0];
        }
        var scrollLeft = element.scrollLeft;
        if (grid.isRTL()) {
          switch (s.rtlScrollType()) {
            case 'default':
              return element.scrollWidth - scrollLeft - element.clientWidth;
            case 'negative':
              return Math.abs(scrollLeft);
            case 'reverse':
              return scrollLeft;
          }
        }
        return scrollLeft;
      };
      s.denormalizeScrollLeft = function denormalizeScrollLeft(element, scrollLeft, grid) {
        if (typeof(element.length) !== 'undefined' && element.length) {
          element = element[0];
        }
        if (grid.isRTL()) {
          switch (s.rtlScrollType()) {
            case 'default':
              var maxScrollLeft = element.scrollWidth - element.clientWidth;
              return maxScrollLeft - scrollLeft;
            case 'negative':
              return scrollLeft * -1;
            case 'reverse':
              return scrollLeft;
          }
        }
        return scrollLeft;
      };
      s.preEval = function(path) {
        var m = uiGridConstants.BRACKET_REGEXP.exec(path);
        if (m) {
          return (m[1] ? s.preEval(m[1]) : m[1]) + m[2] + (m[3] ? s.preEval(m[3]) : m[3]);
        } else {
          path = path.replace(uiGridConstants.APOS_REGEXP, '\\\'');
          var parts = path.split(uiGridConstants.DOT_REGEXP);
          var preparsed = [parts.shift()];
          angular.forEach(parts, function(part) {
            preparsed.push(part.replace(uiGridConstants.FUNC_REGEXP, '\']$1'));
          });
          return preparsed.join('[\'');
        }
      };
      s.debounce = function(func, wait, immediate) {
        var timeout,
            args,
            context,
            result;
        function debounce() {
          context = this;
          args = arguments;
          var later = function() {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
            }
          };
          var callNow = immediate && !timeout;
          if (timeout) {
            $timeout.cancel(timeout);
          }
          timeout = $timeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
          }
          return result;
        }
        debounce.cancel = function() {
          $timeout.cancel(timeout);
          timeout = null;
        };
        return debounce;
      };
      s.throttle = function(func, wait, options) {
        options = options || {};
        var lastCall = 0,
            queued = null,
            context,
            args;
        function runFunc(endDate) {
          lastCall = +new Date();
          func.apply(context, args);
          $interval(function() {
            queued = null;
          }, 0, 1);
        }
        return function() {
          context = this;
          args = arguments;
          if (queued === null) {
            var sinceLast = +new Date() - lastCall;
            if (sinceLast > wait) {
              runFunc();
            } else if (options.trailing) {
              queued = $interval(runFunc, wait - sinceLast, 1);
            }
          }
        };
      };
      s.on = {};
      s.off = {};
      s._events = {};
      s.addOff = function(eventName) {
        s.off[eventName] = function(elm, fn) {
          var idx = s._events[eventName].indexOf(fn);
          if (idx > 0) {
            s._events[eventName].removeAt(idx);
          }
        };
      };
      var mouseWheeltoBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
          nullLowestDeltaTimeout,
          lowestDelta;
      s.on.mousewheel = function(elm, fn) {
        if (!elm || !fn) {
          return ;
        }
        var $elm = angular.element(elm);
        $elm.data('mousewheel-line-height', getLineHeight($elm));
        $elm.data('mousewheel-page-height', s.elementHeight($elm));
        if (!$elm.data('mousewheel-callbacks')) {
          $elm.data('mousewheel-callbacks', {});
        }
        var cbs = $elm.data('mousewheel-callbacks');
        cbs[fn] = (Function.prototype.bind || bindPolyfill).call(mousewheelHandler, $elm[0], fn);
        for (var i = mouseWheeltoBind.length; i; ) {
          $elm.on(mouseWheeltoBind[--i], cbs[fn]);
        }
      };
      s.off.mousewheel = function(elm, fn) {
        var $elm = angular.element(this);
        var cbs = $elm.data('mousewheel-callbacks');
        var handler = cbs[fn];
        if (handler) {
          for (var i = mouseWheeltoBind.length; i; ) {
            $elm.off(mouseWheeltoBind[--i], handler);
          }
        }
        delete cbs[fn];
        if (Object.keys(cbs).length === 0) {
          $elm.removeData('mousewheel-line-height');
          $elm.removeData('mousewheel-page-height');
          $elm.removeData('mousewheel-callbacks');
        }
      };
      function mousewheelHandler(fn, event) {
        var $elm = angular.element(this);
        var delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            offsetX = 0,
            offsetY = 0;
        if (event.originalEvent) {
          event = event.originalEvent;
        }
        if ('detail' in event) {
          deltaY = event.detail * -1;
        }
        if ('wheelDelta' in event) {
          deltaY = event.wheelDelta;
        }
        if ('wheelDeltaY' in event) {
          deltaY = event.wheelDeltaY;
        }
        if ('wheelDeltaX' in event) {
          deltaX = event.wheelDeltaX * -1;
        }
        if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
          deltaX = deltaY * -1;
          deltaY = 0;
        }
        delta = deltaY === 0 ? deltaX : deltaY;
        if ('deltaY' in event) {
          deltaY = event.deltaY * -1;
          delta = deltaY;
        }
        if ('deltaX' in event) {
          deltaX = event.deltaX;
          if (deltaY === 0) {
            delta = deltaX * -1;
          }
        }
        if (deltaY === 0 && deltaX === 0) {
          return ;
        }
        if (event.deltaMode === 1) {
          var lineHeight = $elm.data('mousewheel-line-height');
          delta *= lineHeight;
          deltaY *= lineHeight;
          deltaX *= lineHeight;
        } else if (event.deltaMode === 2) {
          var pageHeight = $elm.data('mousewheel-page-height');
          delta *= pageHeight;
          deltaY *= pageHeight;
          deltaX *= pageHeight;
        }
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if (!lowestDelta || absDelta < lowestDelta) {
          lowestDelta = absDelta;
          if (shouldAdjustOldDeltas(event, absDelta)) {
            lowestDelta /= 40;
          }
        }
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);
        event.deltaMode = 0;
        var newEvent = {
          originalEvent: event,
          deltaX: deltaX,
          deltaY: deltaY,
          deltaFactor: lowestDelta,
          preventDefault: function() {
            event.preventDefault();
          },
          stopPropagation: function() {
            event.stopPropagation();
          }
        };
        if (nullLowestDeltaTimeout) {
          clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
        fn.call($elm[0], newEvent);
      }
      function nullLowestDelta() {
        lowestDelta = null;
      }
      function shouldAdjustOldDeltas(orgEvent, absDelta) {
        return orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
      }
      return s;
    }]);
    module.filter('px', function() {
      return function(str) {
        if (str.match(/^[\d\.]+$/)) {
          return str + 'px';
        } else {
          return str;
        }
      };
    });
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        var lang = {
          aggregate: {label: 'položky'},
          groupPanel: {description: 'Přesuntě záhlaví zde pro vytvoření skupiny dle sloupce.'},
          search: {
            placeholder: 'Hledat...',
            showingItems: 'Zobrazuji položky:',
            selectedItems: 'Vybrané položky:',
            totalItems: 'Celkem položek:',
            size: 'Velikost strany:',
            first: 'První strana',
            next: 'Další strana',
            previous: 'Předchozí strana',
            last: 'Poslední strana'
          },
          menu: {text: 'Vyberte sloupec:'},
          sort: {
            ascending: 'Seřadit od A-Z',
            descending: 'Seřadit od Z-A',
            remove: 'Odebrat seřazení'
          },
          column: {hide: 'Schovat sloupec'},
          aggregation: {
            count: 'celkem řádků: ',
            sum: 'celkem: ',
            avg: 'avg: ',
            min: 'min.: ',
            max: 'max.: '
          },
          pinning: {
            pinLeft: 'Zamknout v levo',
            pinRight: 'Zamknout v pravo',
            unpin: 'Odemknout'
          },
          gridMenu: {
            columns: 'Sloupce:',
            importerTitle: 'Importovat soubor',
            exporterAllAsCsv: 'Exportovat všechny data do csv',
            exporterVisibleAsCsv: 'Exportovat viditelné data do csv',
            exporterSelectedAsCsv: 'Exportovat vybranné data do csv',
            exporterAllAsPdf: 'Exportovat všechny data do pdf',
            exporterVisibleAsPdf: 'Exportovat viditelné data do pdf',
            exporterSelectedAsPdf: 'Exportovat vybranné data do pdf',
            clearAllFilters: 'Vyčistěte všechny filtry'
          },
          importer: {
            noHeaders: 'Názvy sloupců se nepodařilo získat, obsahuje soubor záhlaví?',
            noObjects: 'Data se nepodařilo zpracovat, obsahuje soubor řádky mimo záhlaví?',
            invalidCsv: 'Soubor nelze zpracovat, jedná se CSV?',
            invalidJson: 'Soubor nelze zpracovat, je to JSON?',
            jsonNotArray: 'Soubor musí obsahovat json. Ukončuji..'
          },
          pagination: {
            sizes: 'položek na stránku',
            totalItems: 'položek'
          },
          grouping: {
            group: 'Seskupit',
            ungroup: 'Odebrat seskupení',
            aggregate_count: 'Agregace: Count',
            aggregate_sum: 'Agregace: Sum',
            aggregate_max: 'Agregace: Max',
            aggregate_min: 'Agregace: Min',
            aggregate_avg: 'Agregace: Avg',
            aggregate_remove: 'Agregace: Odebrat'
          }
        };
        $delegate.add('cs', lang);
        $delegate.add('cz', lang);
        $delegate.add('cs-cz', lang);
        $delegate.add('cs-CZ', lang);
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('da', {
          aggregate: {label: 'artikler'},
          groupPanel: {description: 'Grupér rækker udfra en kolonne ved at trække dens overskift hertil.'},
          search: {
            placeholder: 'Søg...',
            showingItems: 'Viste rækker:',
            selectedItems: 'Valgte rækker:',
            totalItems: 'Rækker totalt:',
            size: 'Side størrelse:',
            first: 'Første side',
            next: 'Næste side',
            previous: 'Forrige side',
            last: 'Sidste side'
          },
          menu: {text: 'Vælg kolonner:'},
          column: {hide: 'Skjul kolonne'},
          aggregation: {
            count: 'samlede rækker: ',
            sum: 'smalede: ',
            avg: 'gns: ',
            min: 'min: ',
            max: 'max: '
          },
          gridMenu: {
            columns: 'Columns:',
            importerTitle: 'Import file',
            exporterAllAsCsv: 'Export all data as csv',
            exporterVisibleAsCsv: 'Export visible data as csv',
            exporterSelectedAsCsv: 'Export selected data as csv',
            exporterAllAsPdf: 'Export all data as pdf',
            exporterVisibleAsPdf: 'Export visible data as pdf',
            exporterSelectedAsPdf: 'Export selected data as pdf',
            clearAllFilters: 'Clear all filters'
          },
          importer: {
            noHeaders: 'Column names were unable to be derived, does the file have a header?',
            noObjects: 'Objects were not able to be derived, was there data in the file other than headers?',
            invalidCsv: 'File was unable to be processed, is it valid CSV?',
            invalidJson: 'File was unable to be processed, is it valid Json?',
            jsonNotArray: 'Imported json file must contain an array, aborting.'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('de', {
          aggregate: {label: 'Eintrag'},
          groupPanel: {description: 'Ziehen Sie eine Spaltenüberschrift hierhin, um nach dieser Spalte zu gruppieren.'},
          search: {
            placeholder: 'Suche...',
            showingItems: 'Zeige Einträge:',
            selectedItems: 'Ausgewählte Einträge:',
            totalItems: 'Einträge gesamt:',
            size: 'Einträge pro Seite:',
            first: 'Erste Seite',
            next: 'Nächste Seite',
            previous: 'Vorherige Seite',
            last: 'Letzte Seite'
          },
          menu: {text: 'Spalten auswählen:'},
          sort: {
            ascending: 'aufsteigend sortieren',
            descending: 'absteigend sortieren',
            remove: 'Sortierung zurücksetzen'
          },
          column: {hide: 'Spalte ausblenden'},
          aggregation: {
            count: 'Zeilen insgesamt: ',
            sum: 'gesamt: ',
            avg: 'Durchschnitt: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Links anheften',
            pinRight: 'Rechts anheften',
            unpin: 'Lösen'
          },
          gridMenu: {
            columns: 'Spalten:',
            importerTitle: 'Datei importieren',
            exporterAllAsCsv: 'Alle Daten als CSV exportieren',
            exporterVisibleAsCsv: 'sichtbare Daten als CSV exportieren',
            exporterSelectedAsCsv: 'markierte Daten als CSV exportieren',
            exporterAllAsPdf: 'Alle Daten als PDF exportieren',
            exporterVisibleAsPdf: 'sichtbare Daten als PDF exportieren',
            exporterSelectedAsPdf: 'markierte Daten als CSV exportieren',
            clearAllFilters: 'Alle filter reinigen'
          },
          importer: {
            noHeaders: 'Es konnten keine Spaltennamen ermittelt werden. Sind in der Datei Spaltendefinitionen enthalten?',
            noObjects: 'Es konnten keine Zeileninformationen gelesen werden, Sind in der Datei außer den Spaltendefinitionen auch Daten enthalten?',
            invalidCsv: 'Die Datei konnte nicht eingelesen werden, ist es eine gültige CSV-Datei?',
            invalidJson: 'Die Datei konnte nicht eingelesen werden. Enthält sie gültiges JSON?',
            jsonNotArray: 'Die importierte JSON-Datei muß ein Array enthalten. Breche Import ab.'
          },
          pagination: {
            sizes: 'Einträge pro Seite',
            totalItems: 'Einträge'
          },
          grouping: {
            group: 'Gruppieren',
            ungroup: 'Gruppierung aufheben',
            aggregate_count: 'Agg: Anzahl',
            aggregate_sum: 'Agg: Summe',
            aggregate_max: 'Agg: Maximum',
            aggregate_min: 'Agg: Minimum',
            aggregate_avg: 'Agg: Mittelwert',
            aggregate_remove: 'Aggregation entfernen'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('en', {
          headerCell: {
            aria: {
              defaultFilterLabel: 'Filter for column',
              removeFilter: 'Remove Filter',
              columnMenuButtonLabel: 'Column Menu'
            },
            priority: 'Priority:',
            filterLabel: "Filter for column: "
          },
          aggregate: {label: 'items'},
          groupPanel: {description: 'Drag a column header here and drop it to group by that column.'},
          search: {
            placeholder: 'Search...',
            showingItems: 'Showing Items:',
            selectedItems: 'Selected Items:',
            totalItems: 'Total Items:',
            size: 'Page Size:',
            first: 'First Page',
            next: 'Next Page',
            previous: 'Previous Page',
            last: 'Last Page'
          },
          menu: {text: 'Choose Columns:'},
          sort: {
            ascending: 'Sort Ascending',
            descending: 'Sort Descending',
            none: 'Sort None',
            remove: 'Remove Sort'
          },
          column: {hide: 'Hide Column'},
          aggregation: {
            count: 'total rows: ',
            sum: 'total: ',
            avg: 'avg: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Pin Left',
            pinRight: 'Pin Right',
            unpin: 'Unpin'
          },
          columnMenu: {close: 'Close'},
          gridMenu: {
            aria: {buttonLabel: 'Grid Menu'},
            columns: 'Columns:',
            importerTitle: 'Import file',
            exporterAllAsCsv: 'Export all data as csv',
            exporterVisibleAsCsv: 'Export visible data as csv',
            exporterSelectedAsCsv: 'Export selected data as csv',
            exporterAllAsPdf: 'Export all data as pdf',
            exporterVisibleAsPdf: 'Export visible data as pdf',
            exporterSelectedAsPdf: 'Export selected data as pdf',
            clearAllFilters: 'Clear all filters'
          },
          importer: {
            noHeaders: 'Column names were unable to be derived, does the file have a header?',
            noObjects: 'Objects were not able to be derived, was there data in the file other than headers?',
            invalidCsv: 'File was unable to be processed, is it valid CSV?',
            invalidJson: 'File was unable to be processed, is it valid Json?',
            jsonNotArray: 'Imported json file must contain an array, aborting.'
          },
          pagination: {
            aria: {
              pageToFirst: 'Page to first',
              pageBack: 'Page back',
              pageSelected: 'Selected page',
              pageForward: 'Page forward',
              pageToLast: 'Page to last'
            },
            sizes: 'items per page',
            totalItems: 'items',
            through: 'through',
            of: 'of'
          },
          grouping: {
            group: 'Group',
            ungroup: 'Ungroup',
            aggregate_count: 'Agg: Count',
            aggregate_sum: 'Agg: Sum',
            aggregate_max: 'Agg: Max',
            aggregate_min: 'Agg: Min',
            aggregate_avg: 'Agg: Avg',
            aggregate_remove: 'Agg: Remove'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('es', {
          aggregate: {label: 'Artículos'},
          groupPanel: {description: 'Arrastre un encabezado de columna aquí y suéltelo para agrupar por esa columna.'},
          search: {
            placeholder: 'Buscar...',
            showingItems: 'Artículos Mostrados:',
            selectedItems: 'Artículos Seleccionados:',
            totalItems: 'Artículos Totales:',
            size: 'Tamaño de Página:',
            first: 'Primera Página',
            next: 'Página Siguiente',
            previous: 'Página Anterior',
            last: 'Última Página'
          },
          menu: {text: 'Elegir columnas:'},
          sort: {
            ascending: 'Orden Ascendente',
            descending: 'Orden Descendente',
            remove: 'Sin Ordenar'
          },
          column: {hide: 'Ocultar la columna'},
          aggregation: {
            count: 'filas totales: ',
            sum: 'total: ',
            avg: 'media: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Fijar a la Izquierda',
            pinRight: 'Fijar a la Derecha',
            unpin: 'Quitar Fijación'
          },
          gridMenu: {
            columns: 'Columnas:',
            importerTitle: 'Importar archivo',
            exporterAllAsCsv: 'Exportar todo como csv',
            exporterVisibleAsCsv: 'Exportar vista como csv',
            exporterSelectedAsCsv: 'Exportar selección como csv',
            exporterAllAsPdf: 'Exportar todo como pdf',
            exporterVisibleAsPdf: 'Exportar vista como pdf',
            exporterSelectedAsPdf: 'Exportar selección como pdf',
            clearAllFilters: 'Limpiar todos los filtros'
          },
          importer: {
            noHeaders: 'No fue posible derivar los nombres de las columnas, ¿tiene encabezados el archivo?',
            noObjects: 'No fue posible obtener registros, ¿contiene datos el archivo, aparte de los encabezados?',
            invalidCsv: 'No fue posible procesar el archivo, ¿es un CSV válido?',
            invalidJson: 'No fue posible procesar el archivo, ¿es un Json válido?',
            jsonNotArray: 'El archivo json importado debe contener un array, abortando.'
          },
          pagination: {
            sizes: 'registros por página',
            totalItems: 'registros',
            of: 'de'
          },
          grouping: {
            group: 'Agrupar',
            ungroup: 'Desagrupar',
            aggregate_count: 'Agr: Cont',
            aggregate_sum: 'Agr: Sum',
            aggregate_max: 'Agr: Máx',
            aggregate_min: 'Agr: Min',
            aggregate_avg: 'Agr: Prom',
            aggregate_remove: 'Agr: Quitar'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('fa', {
          aggregate: {label: 'قلم'},
          groupPanel: {description: 'عنوان یک ستون را بگیر و به گروهی از آن ستون رها کن.'},
          search: {
            placeholder: 'جستجو...',
            showingItems: 'نمایش اقلام:',
            selectedItems: 'قلم\u200cهای انتخاب شده:',
            totalItems: 'مجموع اقلام:',
            size: 'اندازه\u200cی صفحه:',
            first: 'اولین صفحه',
            next: 'صفحه\u200cی\u200cبعدی',
            previous: 'صفحه\u200cی\u200c قبلی',
            last: 'آخرین صفحه'
          },
          menu: {text: 'ستون\u200cهای انتخابی:'},
          sort: {
            ascending: 'ترتیب صعودی',
            descending: 'ترتیب نزولی',
            remove: 'حذف مرتب کردن'
          },
          column: {hide: 'پنهان\u200cکردن ستون'},
          aggregation: {
            count: 'تعداد: ',
            sum: 'مجموع: ',
            avg: 'میانگین: ',
            min: 'کمترین: ',
            max: 'بیشترین: '
          },
          pinning: {
            pinLeft: 'پین کردن سمت چپ',
            pinRight: 'پین کردن سمت راست',
            unpin: 'حذف پین'
          },
          gridMenu: {
            columns: 'ستون\u200cها:',
            importerTitle: 'وارد کردن فایل',
            exporterAllAsCsv: 'خروجی تمام داده\u200cها در فایل csv',
            exporterVisibleAsCsv: 'خروجی داده\u200cهای قابل مشاهده در فایل csv',
            exporterSelectedAsCsv: 'خروجی داده\u200cهای انتخاب\u200cشده در فایل csv',
            exporterAllAsPdf: 'خروجی تمام داده\u200cها در فایل pdf',
            exporterVisibleAsPdf: 'خروجی داده\u200cهای قابل مشاهده در فایل pdf',
            exporterSelectedAsPdf: 'خروجی داده\u200cهای انتخاب\u200cشده در فایل pdf',
            clearAllFilters: 'پاک کردن تمام فیلتر'
          },
          importer: {
            noHeaders: 'نام ستون قابل استخراج نیست. آیا فایل عنوان دارد؟',
            noObjects: 'اشیا قابل استخراج نیستند. آیا به جز عنوان\u200cها در فایل داده وجود دارد؟',
            invalidCsv: 'فایل قابل پردازش نیست. آیا فرمت  csv  معتبر است؟',
            invalidJson: 'فایل قابل پردازش نیست. آیا فرمت json   معتبر است؟',
            jsonNotArray: 'فایل json وارد شده باید حاوی آرایه باشد. عملیات ساقط شد.'
          },
          pagination: {
            sizes: 'اقلام در هر صفحه',
            totalItems: 'اقلام',
            of: 'از'
          },
          grouping: {
            group: 'گروه\u200cبندی',
            ungroup: 'حذف گروه\u200cبندی',
            aggregate_count: 'Agg: تعداد',
            aggregate_sum: 'Agg: جمع',
            aggregate_max: 'Agg: بیشینه',
            aggregate_min: 'Agg: کمینه',
            aggregate_avg: 'Agg: میانگین',
            aggregate_remove: 'Agg: حذف'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('fi', {
          aggregate: {label: 'rivit'},
          groupPanel: {description: 'Raahaa ja pudota otsikko tähän ryhmittääksesi sarakkeen mukaan.'},
          search: {
            placeholder: 'Hae...',
            showingItems: 'Näytetään rivejä:',
            selectedItems: 'Valitut rivit:',
            totalItems: 'Rivejä yht.:',
            size: 'Näytä:',
            first: 'Ensimmäinen sivu',
            next: 'Seuraava sivu',
            previous: 'Edellinen sivu',
            last: 'Viimeinen sivu'
          },
          menu: {text: 'Valitse sarakkeet:'},
          sort: {
            ascending: 'Järjestä nouseva',
            descending: 'Järjestä laskeva',
            remove: 'Poista järjestys'
          },
          column: {hide: 'Piilota sarake'},
          aggregation: {
            count: 'Rivejä yht.: ',
            sum: 'Summa: ',
            avg: 'K.a.: ',
            min: 'Min: ',
            max: 'Max: '
          },
          pinning: {
            pinLeft: 'Lukitse vasemmalle',
            pinRight: 'Lukitse oikealle',
            unpin: 'Poista lukitus'
          },
          gridMenu: {
            columns: 'Sarakkeet:',
            importerTitle: 'Tuo tiedosto',
            exporterAllAsCsv: 'Vie tiedot csv-muodossa',
            exporterVisibleAsCsv: 'Vie näkyvä tieto csv-muodossa',
            exporterSelectedAsCsv: 'Vie valittu tieto csv-muodossa',
            exporterAllAsPdf: 'Vie tiedot pdf-muodossa',
            exporterVisibleAsPdf: 'Vie näkyvä tieto pdf-muodossa',
            exporterSelectedAsPdf: 'Vie valittu tieto pdf-muodossa',
            clearAllFilters: 'Puhdista kaikki suodattimet'
          },
          importer: {
            noHeaders: 'Sarakkeen nimiä ei voitu päätellä, onko tiedostossa otsikkoriviä?',
            noObjects: 'Tietoja ei voitu lukea, onko tiedostossa muuta kuin otsikkot?',
            invalidCsv: 'Tiedostoa ei voitu käsitellä, oliko se CSV-muodossa?',
            invalidJson: 'Tiedostoa ei voitu käsitellä, oliko se JSON-muodossa?',
            jsonNotArray: 'Tiedosto ei sisältänyt taulukkoa, lopetetaan.'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('fr', {
          aggregate: {label: 'éléments'},
          groupPanel: {description: 'Faites glisser une en-tête de colonne ici pour créer un groupe de colonnes.'},
          search: {
            placeholder: 'Recherche...',
            showingItems: 'Affichage des éléments :',
            selectedItems: 'Éléments sélectionnés :',
            totalItems: 'Nombre total d\'éléments:',
            size: 'Taille de page:',
            first: 'Première page',
            next: 'Page Suivante',
            previous: 'Page précédente',
            last: 'Dernière page'
          },
          menu: {text: 'Choisir des colonnes :'},
          sort: {
            ascending: 'Trier par ordre croissant',
            descending: 'Trier par ordre décroissant',
            remove: 'Enlever le tri'
          },
          column: {hide: 'Cacher la colonne'},
          aggregation: {
            count: 'lignes totales: ',
            sum: 'total: ',
            avg: 'moy: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Épingler à gauche',
            pinRight: 'Épingler à droite',
            unpin: 'Détacher'
          },
          gridMenu: {
            columns: 'Colonnes:',
            importerTitle: 'Importer un fichier',
            exporterAllAsCsv: 'Exporter toutes les données en CSV',
            exporterVisibleAsCsv: 'Exporter les données visibles en CSV',
            exporterSelectedAsCsv: 'Exporter les données sélectionnées en CSV',
            exporterAllAsPdf: 'Exporter toutes les données en PDF',
            exporterVisibleAsPdf: 'Exporter les données visibles en PDF',
            exporterSelectedAsPdf: 'Exporter les données sélectionnées en PDF',
            clearAllFilters: 'Nettoyez tous les filtres'
          },
          importer: {
            noHeaders: 'Impossible de déterminer le nom des colonnes, le fichier possède-t-il une en-tête ?',
            noObjects: 'Aucun objet trouvé, le fichier possède-t-il des données autres que l\'en-tête ?',
            invalidCsv: 'Le fichier n\'a pas pu être traité, le CSV est-il valide ?',
            invalidJson: 'Le fichier n\'a pas pu être traité, le JSON est-il valide ?',
            jsonNotArray: 'Le fichier JSON importé doit contenir un tableau, abandon.'
          },
          pagination: {
            sizes: 'éléments par page',
            totalItems: 'éléments',
            of: 'sur'
          },
          grouping: {
            group: 'Grouper',
            ungroup: 'Dégrouper',
            aggregate_count: 'Agg: Compte',
            aggregate_sum: 'Agg: Somme',
            aggregate_max: 'Agg: Max',
            aggregate_min: 'Agg: Min',
            aggregate_avg: 'Agg: Moy',
            aggregate_remove: 'Agg: Retirer'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('he', {
          aggregate: {label: 'items'},
          groupPanel: {description: 'גרור עמודה לכאן ושחרר בכדי לקבץ עמודה זו.'},
          search: {
            placeholder: 'חפש...',
            showingItems: 'מציג:',
            selectedItems: 'סה"כ נבחרו:',
            totalItems: 'סה"כ רשומות:',
            size: 'תוצאות בדף:',
            first: 'דף ראשון',
            next: 'דף הבא',
            previous: 'דף קודם',
            last: 'דף אחרון'
          },
          menu: {text: 'בחר עמודות:'},
          sort: {
            ascending: 'סדר עולה',
            descending: 'סדר יורד',
            remove: 'בטל'
          },
          column: {hide: 'טור הסתר'},
          aggregation: {
            count: 'total rows: ',
            sum: 'total: ',
            avg: 'avg: ',
            min: 'min: ',
            max: 'max: '
          },
          gridMenu: {
            columns: 'Columns:',
            importerTitle: 'Import file',
            exporterAllAsCsv: 'Export all data as csv',
            exporterVisibleAsCsv: 'Export visible data as csv',
            exporterSelectedAsCsv: 'Export selected data as csv',
            exporterAllAsPdf: 'Export all data as pdf',
            exporterVisibleAsPdf: 'Export visible data as pdf',
            exporterSelectedAsPdf: 'Export selected data as pdf',
            clearAllFilters: 'Clean all filters'
          },
          importer: {
            noHeaders: 'Column names were unable to be derived, does the file have a header?',
            noObjects: 'Objects were not able to be derived, was there data in the file other than headers?',
            invalidCsv: 'File was unable to be processed, is it valid CSV?',
            invalidJson: 'File was unable to be processed, is it valid Json?',
            jsonNotArray: 'Imported json file must contain an array, aborting.'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('hy', {
          aggregate: {label: 'տվյալներ'},
          groupPanel: {description: 'Ըստ սյան խմբավորելու համար քաշեք և գցեք վերնագիրն այստեղ։'},
          search: {
            placeholder: 'Փնտրում...',
            showingItems: 'Ցուցադրված տվյալներ՝',
            selectedItems: 'Ընտրված:',
            totalItems: 'Ընդամենը՝',
            size: 'Տողերի քանակը էջում՝',
            first: 'Առաջին էջ',
            next: 'Հաջորդ էջ',
            previous: 'Նախորդ էջ',
            last: 'Վերջին էջ'
          },
          menu: {text: 'Ընտրել սյուները:'},
          sort: {
            ascending: 'Աճման կարգով',
            descending: 'Նվազման կարգով',
            remove: 'Հանել '
          },
          column: {hide: 'Թաքցնել սյունը'},
          aggregation: {
            count: 'ընդամենը տող՝ ',
            sum: 'ընդամենը՝ ',
            avg: 'միջին՝ ',
            min: 'մին՝ ',
            max: 'մաքս՝ '
          },
          pinning: {
            pinLeft: 'Կպցնել ձախ կողմում',
            pinRight: 'Կպցնել աջ կողմում',
            unpin: 'Արձակել'
          },
          gridMenu: {
            columns: 'Սյուներ:',
            importerTitle: 'Ներմուծել ֆայլ',
            exporterAllAsCsv: 'Արտահանել ամբողջը CSV',
            exporterVisibleAsCsv: 'Արտահանել երևացող տվյալները CSV',
            exporterSelectedAsCsv: 'Արտահանել ընտրված տվյալները CSV',
            exporterAllAsPdf: 'Արտահանել PDF',
            exporterVisibleAsPdf: 'Արտահանել երևացող տվյալները PDF',
            exporterSelectedAsPdf: 'Արտահանել ընտրված տվյալները PDF',
            clearAllFilters: 'Մաքրել բոլոր ֆիլտրերը'
          },
          importer: {
            noHeaders: 'Հնարավոր չեղավ որոշել սյան վերնագրերը։ Արդյո՞ք ֆայլը ունի վերնագրեր։',
            noObjects: 'Հնարավոր չեղավ կարդալ տվյալները։ Արդյո՞ք ֆայլում կան տվյալներ։',
            invalidCsv: 'Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր CSV է։',
            invalidJson: 'Հնարավոր չեղավ մշակել ֆայլը։ Արդյո՞ք այն վավեր Json է։',
            jsonNotArray: 'Ներմուծված json ֆայլը պետք է պարունակի զանգված, կասեցվում է։'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('it', {
          aggregate: {label: 'elementi'},
          groupPanel: {description: 'Trascina un\'intestazione all\'interno del gruppo della colonna.'},
          search: {
            placeholder: 'Ricerca...',
            showingItems: 'Mostra:',
            selectedItems: 'Selezionati:',
            totalItems: 'Totali:',
            size: 'Tot Pagine:',
            first: 'Prima',
            next: 'Prossima',
            previous: 'Precedente',
            last: 'Ultima'
          },
          menu: {text: 'Scegli le colonne:'},
          sort: {
            ascending: 'Asc.',
            descending: 'Desc.',
            remove: 'Annulla ordinamento'
          },
          column: {hide: 'Nascondi'},
          aggregation: {
            count: 'righe totali: ',
            sum: 'tot: ',
            avg: 'media: ',
            min: 'minimo: ',
            max: 'massimo: '
          },
          pinning: {
            pinLeft: 'Blocca a sx',
            pinRight: 'Blocca a dx',
            unpin: 'Blocca in alto'
          },
          gridMenu: {
            columns: 'Colonne:',
            importerTitle: 'Importa',
            exporterAllAsCsv: 'Esporta tutti i dati in CSV',
            exporterVisibleAsCsv: 'Esporta i dati visibili in CSV',
            exporterSelectedAsCsv: 'Esporta i dati selezionati in CSV',
            exporterAllAsPdf: 'Esporta tutti i dati in PDF',
            exporterVisibleAsPdf: 'Esporta i dati visibili in PDF',
            exporterSelectedAsPdf: 'Esporta i dati selezionati in PDF',
            clearAllFilters: 'Pulire tutti i filtri'
          },
          importer: {
            noHeaders: 'Impossibile reperire i nomi delle colonne, sicuro che siano indicati all\'interno del file?',
            noObjects: 'Impossibile reperire gli oggetti, sicuro che siano indicati all\'interno del file?',
            invalidCsv: 'Impossibile elaborare il file, sicuro che sia un CSV?',
            invalidJson: 'Impossibile elaborare il file, sicuro che sia un JSON valido?',
            jsonNotArray: 'Errore! Il file JSON da importare deve contenere un array.'
          },
          grouping: {
            group: 'Raggruppa',
            ungroup: 'Separa',
            aggregate_count: 'Agg: N. Elem.',
            aggregate_sum: 'Agg: Somma',
            aggregate_max: 'Agg: Massimo',
            aggregate_min: 'Agg: Minimo',
            aggregate_avg: 'Agg: Media',
            aggregate_remove: 'Agg: Rimuovi'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('ja', {
          aggregate: {label: '項目'},
          groupPanel: {description: 'ここに列ヘッダをドラッグアンドドロップして、その列でグループ化します。'},
          search: {
            placeholder: '検索...',
            showingItems: '表示中の項目:',
            selectedItems: '選択した項目:',
            totalItems: '項目の総数:',
            size: 'ページサイズ:',
            first: '最初のページ',
            next: '次のページ',
            previous: '前のページ',
            last: '前のページ'
          },
          menu: {text: '列の選択:'},
          sort: {
            ascending: '昇順に並べ替え',
            descending: '降順に並べ替え',
            remove: '並べ替えの解除'
          },
          column: {hide: '列の非表示'},
          aggregation: {
            count: '合計行数: ',
            sum: '合計: ',
            avg: '平均: ',
            min: '最小: ',
            max: '最大: '
          },
          pinning: {
            pinLeft: '左に固定',
            pinRight: '右に固定',
            unpin: '固定解除'
          },
          gridMenu: {
            columns: '列:',
            importerTitle: 'ファイルのインポート',
            exporterAllAsCsv: 'すべてのデータをCSV形式でエクスポート',
            exporterVisibleAsCsv: '表示中のデータをCSV形式でエクスポート',
            exporterSelectedAsCsv: '選択したデータをCSV形式でエクスポート',
            exporterAllAsPdf: 'すべてのデータをPDF形式でエクスポート',
            exporterVisibleAsPdf: '表示中のデータをPDF形式でエクスポート',
            exporterSelectedAsPdf: '選択したデータをPDF形式でエクスポート',
            clearAllFilters: 'すべてのフィルタを清掃してください'
          },
          importer: {
            noHeaders: '列名を取得できません。ファイルにヘッダが含まれていることを確認してください。',
            noObjects: 'オブジェクトを取得できません。ファイルにヘッダ以外のデータが含まれていることを確認してください。',
            invalidCsv: 'ファイルを処理できません。ファイルが有効なCSV形式であることを確認してください。',
            invalidJson: 'ファイルを処理できません。ファイルが有効なJSON形式であることを確認してください。',
            jsonNotArray: 'インポートしたJSONファイルには配列が含まれている必要があります。処理を中止します。'
          },
          pagination: {
            sizes: '項目/ページ',
            totalItems: '項目'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('ko', {
          aggregate: {label: '아이템'},
          groupPanel: {description: '컬럼으로 그룹핑하기 위해서는 컬럼 헤더를 끌어 떨어뜨려 주세요.'},
          search: {
            placeholder: '검색...',
            showingItems: '항목 보여주기:',
            selectedItems: '선택 항목:',
            totalItems: '전체 항목:',
            size: '페이지 크기:',
            first: '첫번째 페이지',
            next: '다음 페이지',
            previous: '이전 페이지',
            last: '마지막 페이지'
          },
          menu: {text: '컬럼을 선택하세요:'},
          sort: {
            ascending: '오름차순 정렬',
            descending: '내림차순 정렬',
            remove: '소팅 제거'
          },
          column: {hide: '컬럼 제거'},
          aggregation: {
            count: '전체 갯수: ',
            sum: '전체: ',
            avg: '평균: ',
            min: '최소: ',
            max: '최대: '
          },
          pinning: {
            pinLeft: '왼쪽 핀',
            pinRight: '오른쪽 핀',
            unpin: '핀 제거'
          },
          gridMenu: {
            columns: '컬럼:',
            importerTitle: '파일 가져오기',
            exporterAllAsCsv: 'csv로 모든 데이터 내보내기',
            exporterVisibleAsCsv: 'csv로 보이는 데이터 내보내기',
            exporterSelectedAsCsv: 'csv로 선택된 데이터 내보내기',
            exporterAllAsPdf: 'pdf로 모든 데이터 내보내기',
            exporterVisibleAsPdf: 'pdf로 보이는 데이터 내보내기',
            exporterSelectedAsPdf: 'pdf로 선택 데이터 내보내기',
            clearAllFilters: '모든 필터를 청소'
          },
          importer: {
            noHeaders: '컬럼명이 지정되어 있지 않습니다. 파일에 헤더가 명시되어 있는지 확인해 주세요.',
            noObjects: '데이터가 지정되어 있지 않습니다. 데이터가 파일에 있는지 확인해 주세요.',
            invalidCsv: '파일을 처리할 수 없습니다. 올바른 csv인지 확인해 주세요.',
            invalidJson: '파일을 처리할 수 없습니다. 올바른 json인지 확인해 주세요.',
            jsonNotArray: 'json 파일은 배열을 포함해야 합니다.'
          },
          pagination: {
            sizes: '페이지당 항목',
            totalItems: '전체 항목'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('nl', {
          aggregate: {label: 'items'},
          groupPanel: {description: 'Sleep hier een kolomnaam heen om op te groeperen.'},
          search: {
            placeholder: 'Zoeken...',
            showingItems: 'Getoonde items:',
            selectedItems: 'Geselecteerde items:',
            totalItems: 'Totaal aantal items:',
            size: 'Items per pagina:',
            first: 'Eerste pagina',
            next: 'Volgende pagina',
            previous: 'Vorige pagina',
            last: 'Laatste pagina'
          },
          menu: {text: 'Kies kolommen:'},
          sort: {
            ascending: 'Sorteer oplopend',
            descending: 'Sorteer aflopend',
            remove: 'Verwijder sortering'
          },
          column: {hide: 'Verberg kolom'},
          aggregation: {
            count: 'Aantal rijen: ',
            sum: 'Som: ',
            avg: 'Gemiddelde: ',
            min: 'Min: ',
            max: 'Max: '
          },
          pinning: {
            pinLeft: 'Zet links vast',
            pinRight: 'Zet rechts vast',
            unpin: 'Maak los'
          },
          gridMenu: {
            columns: 'Kolommen:',
            importerTitle: 'Importeer bestand',
            exporterAllAsCsv: 'Exporteer alle data als csv',
            exporterVisibleAsCsv: 'Exporteer zichtbare data als csv',
            exporterSelectedAsCsv: 'Exporteer geselecteerde data als csv',
            exporterAllAsPdf: 'Exporteer alle data als pdf',
            exporterVisibleAsPdf: 'Exporteer zichtbare data als pdf',
            exporterSelectedAsPdf: 'Exporteer geselecteerde data als pdf',
            clearAllFilters: 'Reinig alle filters'
          },
          importer: {
            noHeaders: 'Kolomnamen kunnen niet worden afgeleid. Heeft het bestand een header?',
            noObjects: 'Objecten kunnen niet worden afgeleid. Bevat het bestand data naast de headers?',
            invalidCsv: 'Het bestand kan niet verwerkt worden. Is het een valide csv bestand?',
            invalidJson: 'Het bestand kan niet verwerkt worden. Is het valide json?',
            jsonNotArray: 'Het json bestand moet een array bevatten. De actie wordt geannuleerd.'
          },
          pagination: {
            sizes: 'items per pagina',
            totalItems: 'items'
          },
          grouping: {
            group: 'Groepeer',
            ungroup: 'Groepering opheffen',
            aggregate_count: 'Agg: Aantal',
            aggregate_sum: 'Agg: Som',
            aggregate_max: 'Agg: Max',
            aggregate_min: 'Agg: Min',
            aggregate_avg: 'Agg: Gem',
            aggregate_remove: 'Agg: Verwijder'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('pt-br', {
          aggregate: {label: 'itens'},
          groupPanel: {description: 'Arraste e solte uma coluna aqui para agrupar por essa coluna'},
          search: {
            placeholder: 'Procurar...',
            showingItems: 'Mostrando os Itens:',
            selectedItems: 'Items Selecionados:',
            totalItems: 'Total de Itens:',
            size: 'Tamanho da Página:',
            first: 'Primeira Página',
            next: 'Próxima Página',
            previous: 'Página Anterior',
            last: 'Última Página'
          },
          menu: {text: 'Selecione as colunas:'},
          sort: {
            ascending: 'Ordenar Ascendente',
            descending: 'Ordenar Descendente',
            remove: 'Remover Ordenação'
          },
          column: {hide: 'Esconder coluna'},
          aggregation: {
            count: 'total de linhas: ',
            sum: 'total: ',
            avg: 'med: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Fixar Esquerda',
            pinRight: 'Fixar Direita',
            unpin: 'Desprender'
          },
          gridMenu: {
            columns: 'Colunas:',
            importerTitle: 'Importar arquivo',
            exporterAllAsCsv: 'Exportar todos os dados como csv',
            exporterVisibleAsCsv: 'Exportar dados visíveis como csv',
            exporterSelectedAsCsv: 'Exportar dados selecionados como csv',
            exporterAllAsPdf: 'Exportar todos os dados como pdf',
            exporterVisibleAsPdf: 'Exportar dados visíveis como pdf',
            exporterSelectedAsPdf: 'Exportar dados selecionados como pdf',
            clearAllFilters: 'Limpar todos os filtros'
          },
          importer: {
            noHeaders: 'Nomes de colunas não puderam ser derivados. O arquivo tem um cabeçalho?',
            noObjects: 'Objetos não puderam ser derivados. Havia dados no arquivo, além dos cabeçalhos?',
            invalidCsv: 'Arquivo não pode ser processado. É um CSV válido?',
            invalidJson: 'Arquivo não pode ser processado. É um Json válido?',
            jsonNotArray: 'Arquivo json importado tem que conter um array. Abortando.'
          },
          pagination: {
            sizes: 'itens por página',
            totalItems: 'itens'
          },
          grouping: {
            group: 'Agrupar',
            ungroup: 'Desagrupar',
            aggregate_count: 'Agr: Contar',
            aggregate_sum: 'Agr: Soma',
            aggregate_max: 'Agr: Max',
            aggregate_min: 'Agr: Min',
            aggregate_avg: 'Agr: Med',
            aggregate_remove: 'Agr: Remover'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('pt', {
          aggregate: {label: 'itens'},
          groupPanel: {description: 'Arraste e solte uma coluna aqui para agrupar por essa coluna'},
          search: {
            placeholder: 'Procurar...',
            showingItems: 'Mostrando os Itens:',
            selectedItems: 'Itens Selecionados:',
            totalItems: 'Total de Itens:',
            size: 'Tamanho da Página:',
            first: 'Primeira Página',
            next: 'Próxima Página',
            previous: 'Página Anterior',
            last: 'Última Página'
          },
          menu: {text: 'Selecione as colunas:'},
          sort: {
            ascending: 'Ordenar Ascendente',
            descending: 'Ordenar Descendente',
            remove: 'Remover Ordenação'
          },
          column: {hide: 'Esconder coluna'},
          aggregation: {
            count: 'total de linhas: ',
            sum: 'total: ',
            avg: 'med: ',
            min: 'min: ',
            max: 'max: '
          },
          pinning: {
            pinLeft: 'Fixar Esquerda',
            pinRight: 'Fixar Direita',
            unpin: 'Desprender'
          },
          gridMenu: {
            columns: 'Colunas:',
            importerTitle: 'Importar ficheiro',
            exporterAllAsCsv: 'Exportar todos os dados como csv',
            exporterVisibleAsCsv: 'Exportar dados visíveis como csv',
            exporterSelectedAsCsv: 'Exportar dados selecionados como csv',
            exporterAllAsPdf: 'Exportar todos os dados como pdf',
            exporterVisibleAsPdf: 'Exportar dados visíveis como pdf',
            exporterSelectedAsPdf: 'Exportar dados selecionados como pdf',
            clearAllFilters: 'Limpar todos os filtros'
          },
          importer: {
            noHeaders: 'Nomes de colunas não puderam ser derivados. O ficheiro tem um cabeçalho?',
            noObjects: 'Objetos não puderam ser derivados. Havia dados no ficheiro, além dos cabeçalhos?',
            invalidCsv: 'Ficheiro não pode ser processado. É um CSV válido?',
            invalidJson: 'Ficheiro não pode ser processado. É um Json válido?',
            jsonNotArray: 'Ficheiro json importado tem que conter um array. Interrompendo.'
          },
          pagination: {
            sizes: 'itens por página',
            totalItems: 'itens',
            of: 'de'
          },
          grouping: {
            group: 'Agrupar',
            ungroup: 'Desagrupar',
            aggregate_count: 'Agr: Contar',
            aggregate_sum: 'Agr: Soma',
            aggregate_max: 'Agr: Max',
            aggregate_min: 'Agr: Min',
            aggregate_avg: 'Agr: Med',
            aggregate_remove: 'Agr: Remover'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('ru', {
          aggregate: {label: 'элементы'},
          groupPanel: {description: 'Для группировки по столбцу перетащите сюда его название.'},
          search: {
            placeholder: 'Поиск...',
            showingItems: 'Показать элементы:',
            selectedItems: 'Выбранные элементы:',
            totalItems: 'Всего элементов:',
            size: 'Размер страницы:',
            first: 'Первая страница',
            next: 'Следующая страница',
            previous: 'Предыдущая страница',
            last: 'Последняя страница'
          },
          menu: {text: 'Выбрать столбцы:'},
          sort: {
            ascending: 'По возрастанию',
            descending: 'По убыванию',
            remove: 'Убрать сортировку'
          },
          column: {hide: 'Спрятать столбец'},
          aggregation: {
            count: 'всего строк: ',
            sum: 'итого: ',
            avg: 'среднее: ',
            min: 'мин: ',
            max: 'макс: '
          },
          pinning: {
            pinLeft: 'Закрепить слева',
            pinRight: 'Закрепить справа',
            unpin: 'Открепить'
          },
          gridMenu: {
            columns: 'Столбцы:',
            importerTitle: 'Import file',
            exporterAllAsCsv: 'Экспортировать всё в CSV',
            exporterVisibleAsCsv: 'Экспортировать видимые данные в CSV',
            exporterSelectedAsCsv: 'Экспортировать выбранные данные в CSV',
            exporterAllAsPdf: 'Экспортировать всё в PDF',
            exporterVisibleAsPdf: 'Экспортировать видимые данные в PDF',
            exporterSelectedAsPdf: 'Экспортировать выбранные данные в PDF',
            clearAllFilters: 'Очистите все фильтры'
          },
          importer: {
            noHeaders: 'Column names were unable to be derived, does the file have a header?',
            noObjects: 'Objects were not able to be derived, was there data in the file other than headers?',
            invalidCsv: 'File was unable to be processed, is it valid CSV?',
            invalidJson: 'File was unable to be processed, is it valid Json?',
            jsonNotArray: 'Imported json file must contain an array, aborting.'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('sk', {
          aggregate: {label: 'items'},
          groupPanel: {description: 'Pretiahni sem názov stĺpca pre zoskupenie podľa toho stĺpca.'},
          search: {
            placeholder: 'Hľadaj...',
            showingItems: 'Zobrazujem položky:',
            selectedItems: 'Vybraté položky:',
            totalItems: 'Počet položiek:',
            size: 'Počet:',
            first: 'Prvá strana',
            next: 'Ďalšia strana',
            previous: 'Predchádzajúca strana',
            last: 'Posledná strana'
          },
          menu: {text: 'Vyberte stĺpce:'},
          sort: {
            ascending: 'Zotriediť vzostupne',
            descending: 'Zotriediť zostupne',
            remove: 'Vymazať triedenie'
          },
          aggregation: {
            count: 'total rows: ',
            sum: 'total: ',
            avg: 'avg: ',
            min: 'min: ',
            max: 'max: '
          },
          gridMenu: {
            columns: 'Columns:',
            importerTitle: 'Import file',
            exporterAllAsCsv: 'Export all data as csv',
            exporterVisibleAsCsv: 'Export visible data as csv',
            exporterSelectedAsCsv: 'Export selected data as csv',
            exporterAllAsPdf: 'Export all data as pdf',
            exporterVisibleAsPdf: 'Export visible data as pdf',
            exporterSelectedAsPdf: 'Export selected data as pdf',
            clearAllFilters: 'Clear all filters'
          },
          importer: {
            noHeaders: 'Column names were unable to be derived, does the file have a header?',
            noObjects: 'Objects were not able to be derived, was there data in the file other than headers?',
            invalidCsv: 'File was unable to be processed, is it valid CSV?',
            invalidJson: 'File was unable to be processed, is it valid Json?',
            jsonNotArray: 'Imported json file must contain an array, aborting.'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('sv', {
          aggregate: {label: 'Artiklar'},
          groupPanel: {description: 'Dra en kolumnrubrik hit och släpp den för att gruppera efter den kolumnen.'},
          search: {
            placeholder: 'Sök...',
            showingItems: 'Visar artiklar:',
            selectedItems: 'Valda artiklar:',
            totalItems: 'Antal artiklar:',
            size: 'Sidstorlek:',
            first: 'Första sidan',
            next: 'Nästa sida',
            previous: 'Föregående sida',
            last: 'Sista sidan'
          },
          menu: {text: 'Välj kolumner:'},
          sort: {
            ascending: 'Sortera stigande',
            descending: 'Sortera fallande',
            remove: 'Inaktivera sortering'
          },
          column: {hide: 'Göm kolumn'},
          aggregation: {
            count: 'Antal rader: ',
            sum: 'Summa: ',
            avg: 'Genomsnitt: ',
            min: 'Min: ',
            max: 'Max: '
          },
          pinning: {
            pinLeft: 'Fäst vänster',
            pinRight: 'Fäst höger',
            unpin: 'Lösgör'
          },
          gridMenu: {
            columns: 'Kolumner:',
            importerTitle: 'Importera fil',
            exporterAllAsCsv: 'Exportera all data som CSV',
            exporterVisibleAsCsv: 'Exportera synlig data som CSV',
            exporterSelectedAsCsv: 'Exportera markerad data som CSV',
            exporterAllAsPdf: 'Exportera all data som PDF',
            exporterVisibleAsPdf: 'Exportera synlig data som PDF',
            exporterSelectedAsPdf: 'Exportera markerad data som PDF',
            clearAllFilters: 'Rengör alla filter'
          },
          importer: {
            noHeaders: 'Kolumnnamn kunde inte härledas. Har filen ett sidhuvud?',
            noObjects: 'Objekt kunde inte härledas. Har filen data undantaget sidhuvud?',
            invalidCsv: 'Filen kunde inte behandlas, är den en giltig CSV?',
            invalidJson: 'Filen kunde inte behandlas, är den en giltig JSON?',
            jsonNotArray: 'Importerad JSON-fil måste innehålla ett fält. Import avbruten.'
          },
          pagination: {
            sizes: 'Artiklar per sida',
            totalItems: 'Artiklar'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('ta', {
          aggregate: {label: 'உருப்படிகள்'},
          groupPanel: {description: 'ஒரு பத்தியை குழுவாக அமைக்க அப்பத்தியின் தலைப்பை இங்கே  இழுத்து வரவும் '},
          search: {
            placeholder: 'தேடல் ...',
            showingItems: 'உருப்படிகளை காண்பித்தல்:',
            selectedItems: 'தேர்ந்தெடுக்கப்பட்ட  உருப்படிகள்:',
            totalItems: 'மொத்த உருப்படிகள்:',
            size: 'பக்க அளவு: ',
            first: 'முதல் பக்கம்',
            next: 'அடுத்த பக்கம்',
            previous: 'முந்தைய பக்கம் ',
            last: 'இறுதி பக்கம்'
          },
          menu: {text: 'பத்திகளை தேர்ந்தெடு:'},
          sort: {
            ascending: 'மேலிருந்து கீழாக',
            descending: 'கீழிருந்து மேலாக',
            remove: 'வரிசையை நீக்கு'
          },
          column: {hide: 'பத்தியை மறைத்து வை '},
          aggregation: {
            count: 'மொத்த வரிகள்:',
            sum: 'மொத்தம்: ',
            avg: 'சராசரி: ',
            min: 'குறைந்தபட்ச: ',
            max: 'அதிகபட்ச: '
          },
          pinning: {
            pinLeft: 'இடதுபுறமாக தைக்க ',
            pinRight: 'வலதுபுறமாக தைக்க',
            unpin: 'பிரி'
          },
          gridMenu: {
            columns: 'பத்திகள்:',
            importerTitle: 'கோப்பு : படித்தல்',
            exporterAllAsCsv: 'எல்லா தரவுகளையும் கோப்பாக்கு: csv',
            exporterVisibleAsCsv: 'இருக்கும் தரவுகளை கோப்பாக்கு: csv',
            exporterSelectedAsCsv: 'தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: csv',
            exporterAllAsPdf: 'எல்லா தரவுகளையும் கோப்பாக்கு: pdf',
            exporterVisibleAsPdf: 'இருக்கும் தரவுகளை கோப்பாக்கு: pdf',
            exporterSelectedAsPdf: 'தேர்ந்தெடுத்த தரவுகளை கோப்பாக்கு: pdf',
            clearAllFilters: 'Clear all filters'
          },
          importer: {
            noHeaders: 'பத்தியின் தலைப்புகளை பெற இயலவில்லை, கோப்பிற்கு தலைப்பு உள்ளதா?',
            noObjects: 'இலக்குகளை உருவாக்க முடியவில்லை, கோப்பில் தலைப்புகளை தவிர தரவு ஏதேனும் உள்ளதா? ',
            invalidCsv: 'சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - csv',
            invalidJson: 'சரிவர நடைமுறை படுத்த இயலவில்லை, கோப்பு சரிதானா? - json',
            jsonNotArray: 'படித்த கோப்பில் வரிசைகள் உள்ளது, நடைமுறை ரத்து செய் : json'
          },
          pagination: {
            sizes: 'உருப்படிகள் / பக்கம்',
            totalItems: 'உருப்படிகள் '
          },
          grouping: {
            group: 'குழு',
            ungroup: 'பிரி',
            aggregate_count: 'மதிப்பீட்டு : எண்ணு',
            aggregate_sum: 'மதிப்பீட்டு : கூட்டல்',
            aggregate_max: 'மதிப்பீட்டு : அதிகபட்சம்',
            aggregate_min: 'மதிப்பீட்டு : குறைந்தபட்சம்',
            aggregate_avg: 'மதிப்பீட்டு : சராசரி',
            aggregate_remove: 'மதிப்பீட்டு : நீக்கு'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    var DIRECTIVE_ALIASES = ['uiT', 'uiTranslate'];
    var FILTER_ALIASES = ['t', 'uiTranslate'];
    var module = angular.module('ui.grid.i18n');
    module.constant('i18nConstants', {
      MISSING: '[MISSING]',
      UPDATE_EVENT: '$uiI18n',
      LOCALE_DIRECTIVE_ALIAS: 'uiI18n',
      DEFAULT_LANG: 'en'
    });
    module.service('i18nService', ['$log', 'i18nConstants', '$rootScope', function($log, i18nConstants, $rootScope) {
      var langCache = {
        _langs: {},
        current: null,
        get: function(lang) {
          return this._langs[lang.toLowerCase()];
        },
        add: function(lang, strings) {
          var lower = lang.toLowerCase();
          if (!this._langs[lower]) {
            this._langs[lower] = {};
          }
          angular.extend(this._langs[lower], strings);
        },
        getAllLangs: function() {
          var langs = [];
          if (!this._langs) {
            return langs;
          }
          for (var key in this._langs) {
            langs.push(key);
          }
          return langs;
        },
        setCurrent: function(lang) {
          this.current = lang.toLowerCase();
        },
        getCurrentLang: function() {
          return this.current;
        }
      };
      var service = {
        add: function(langs, stringMaps) {
          if (typeof(langs) === 'object') {
            angular.forEach(langs, function(lang) {
              if (lang) {
                langCache.add(lang, stringMaps);
              }
            });
          } else {
            langCache.add(langs, stringMaps);
          }
        },
        getAllLangs: function() {
          return langCache.getAllLangs();
        },
        get: function(lang) {
          var language = lang ? lang : service.getCurrentLang();
          return langCache.get(language);
        },
        getSafeText: function(path, lang) {
          var language = lang ? lang : service.getCurrentLang();
          var trans = langCache.get(language);
          if (!trans) {
            return i18nConstants.MISSING;
          }
          var paths = path.split('.');
          var current = trans;
          for (var i = 0; i < paths.length; ++i) {
            if (current[paths[i]] === undefined || current[paths[i]] === null) {
              return i18nConstants.MISSING;
            } else {
              current = current[paths[i]];
            }
          }
          return current;
        },
        setCurrentLang: function(lang) {
          if (lang) {
            langCache.setCurrent(lang);
            $rootScope.$broadcast(i18nConstants.UPDATE_EVENT);
          }
        },
        getCurrentLang: function() {
          var lang = langCache.getCurrentLang();
          if (!lang) {
            lang = i18nConstants.DEFAULT_LANG;
            langCache.setCurrent(lang);
          }
          return lang;
        }
      };
      return service;
    }]);
    var localeDirective = function(i18nService, i18nConstants) {
      return {compile: function() {
          return {pre: function($scope, $elm, $attrs) {
              var alias = i18nConstants.LOCALE_DIRECTIVE_ALIAS;
              var lang = $scope.$eval($attrs[alias]);
              if (lang) {
                $scope.$watch($attrs[alias], function() {
                  i18nService.setCurrentLang(lang);
                });
              } else if ($attrs.$$observers) {
                $attrs.$observe(alias, function() {
                  i18nService.setCurrentLang($attrs[alias] || i18nConstants.DEFAULT_LANG);
                });
              }
            }};
        }};
    };
    module.directive('uiI18n', ['i18nService', 'i18nConstants', localeDirective]);
    var uitDirective = function($parse, i18nService, i18nConstants) {
      return {
        restrict: 'EA',
        compile: function() {
          return {pre: function($scope, $elm, $attrs) {
              var alias1 = DIRECTIVE_ALIASES[0],
                  alias2 = DIRECTIVE_ALIASES[1];
              var token = $attrs[alias1] || $attrs[alias2] || $elm.html();
              var missing = i18nConstants.MISSING + token;
              var observer;
              if ($attrs.$$observers) {
                var prop = $attrs[alias1] ? alias1 : alias2;
                observer = $attrs.$observe(prop, function(result) {
                  if (result) {
                    $elm.html($parse(result)(i18nService.getCurrentLang()) || missing);
                  }
                });
              }
              var getter = $parse(token);
              var listener = $scope.$on(i18nConstants.UPDATE_EVENT, function(evt) {
                if (observer) {
                  observer($attrs[alias1] || $attrs[alias2]);
                } else {
                  $elm.html(getter(i18nService.get()) || missing);
                }
              });
              $scope.$on('$destroy', listener);
              $elm.html(getter(i18nService.get()) || missing);
            }};
        }
      };
    };
    angular.forEach(DIRECTIVE_ALIASES, function(alias) {
      module.directive(alias, ['$parse', 'i18nService', 'i18nConstants', uitDirective]);
    });
    var uitFilter = function($parse, i18nService, i18nConstants) {
      return function(data) {
        var getter = $parse(data);
        return getter(i18nService.get()) || i18nConstants.MISSING + data;
      };
    };
    angular.forEach(FILTER_ALIASES, function(alias) {
      module.filter(alias, ['$parse', 'i18nService', 'i18nConstants', uitFilter]);
    });
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('zh-cn', {
          headerCell: {
            aria: {
              defaultFilterLabel: '列过滤器',
              removeFilter: '移除过滤器',
              columnMenuButtonLabel: '列菜单'
            },
            priority: '优先级:',
            filterLabel: "列过滤器: "
          },
          aggregate: {label: '行'},
          groupPanel: {description: '拖曳表头到此处进行分组'},
          search: {
            placeholder: '查找',
            showingItems: '已显示行数：',
            selectedItems: '已选择行数：',
            totalItems: '总行数：',
            size: '每页显示行数：',
            first: '首页',
            next: '下一页',
            previous: '上一页',
            last: '末页'
          },
          menu: {text: '选择列：'},
          sort: {
            ascending: '升序',
            descending: '降序',
            none: '无序',
            remove: '取消排序'
          },
          column: {hide: '隐藏列'},
          aggregation: {
            count: '计数：',
            sum: '求和：',
            avg: '均值：',
            min: '最小值：',
            max: '最大值：'
          },
          pinning: {
            pinLeft: '左侧固定',
            pinRight: '右侧固定',
            unpin: '取消固定'
          },
          columnMenu: {close: '关闭'},
          gridMenu: {
            aria: {buttonLabel: '表格菜单'},
            columns: '列：',
            importerTitle: '导入文件',
            exporterAllAsCsv: '导出全部数据到CSV',
            exporterVisibleAsCsv: '导出可见数据到CSV',
            exporterSelectedAsCsv: '导出已选数据到CSV',
            exporterAllAsPdf: '导出全部数据到PDF',
            exporterVisibleAsPdf: '导出可见数据到PDF',
            exporterSelectedAsPdf: '导出已选数据到PDF',
            clearAllFilters: '清除所有过滤器'
          },
          importer: {
            noHeaders: '无法获取列名，确定文件包含表头？',
            noObjects: '无法获取数据，确定文件包含数据？',
            invalidCsv: '无法处理文件，确定是合法的CSV文件？',
            invalidJson: '无法处理文件，确定是合法的JSON文件？',
            jsonNotArray: '导入的文件不是JSON数组！'
          },
          pagination: {
            aria: {
              pageToFirst: '第一页',
              pageBack: '上一页',
              pageSelected: '当前页',
              pageForward: '下一页',
              pageToLast: '最后一页'
            },
            sizes: '行每页',
            totalItems: '行',
            through: '至',
            of: '共'
          },
          grouping: {
            group: '分组',
            ungroup: '取消分组',
            aggregate_count: '合计: 计数',
            aggregate_sum: '合计: 求和',
            aggregate_max: '合计: 最大',
            aggregate_min: '合计: 最小',
            aggregate_avg: '合计: 平均',
            aggregate_remove: '合计: 移除'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('i18nService', ['$delegate', function($delegate) {
        $delegate.add('zh-tw', {
          aggregate: {label: '行'},
          groupPanel: {description: '拖曳表頭到此處進行分組'},
          search: {
            placeholder: '查找',
            showingItems: '已顯示行數：',
            selectedItems: '已選擇行數：',
            totalItems: '總行數：',
            size: '每頁顯示行數：',
            first: '首頁',
            next: '下壹頁',
            previous: '上壹頁',
            last: '末頁'
          },
          menu: {text: '選擇列：'},
          sort: {
            ascending: '升序',
            descending: '降序',
            remove: '取消排序'
          },
          column: {hide: '隱藏列'},
          aggregation: {
            count: '計數：',
            sum: '求和：',
            avg: '均值：',
            min: '最小值：',
            max: '最大值：'
          },
          pinning: {
            pinLeft: '左側固定',
            pinRight: '右側固定',
            unpin: '取消固定'
          },
          gridMenu: {
            columns: '列：',
            importerTitle: '導入文件',
            exporterAllAsCsv: '導出全部數據到CSV',
            exporterVisibleAsCsv: '導出可見數據到CSV',
            exporterSelectedAsCsv: '導出已選數據到CSV',
            exporterAllAsPdf: '導出全部數據到PDF',
            exporterVisibleAsPdf: '導出可見數據到PDF',
            exporterSelectedAsPdf: '導出已選數據到PDF',
            clearAllFilters: '清除所有过滤器'
          },
          importer: {
            noHeaders: '無法獲取列名，確定文件包含表頭？',
            noObjects: '無法獲取數據，確定文件包含數據？',
            invalidCsv: '無法處理文件，確定是合法的CSV文件？',
            invalidJson: '無法處理文件，確定是合法的JSON文件？',
            jsonNotArray: '導入的文件不是JSON數組！'
          },
          pagination: {
            sizes: '行每頁',
            totalItems: '行'
          }
        });
        return $delegate;
      }]);
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.autoResize', ['ui.grid']);
    module.directive('uiGridAutoResize', ['$timeout', 'gridUtil', function($timeout, gridUtil) {
      return {
        require: 'uiGrid',
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var prevGridWidth,
              prevGridHeight;
          function getDimensions() {
            prevGridHeight = gridUtil.elementHeight($elm);
            prevGridWidth = gridUtil.elementWidth($elm);
          }
          getDimensions();
          var resizeTimeoutId;
          function startTimeout() {
            clearTimeout(resizeTimeoutId);
            resizeTimeoutId = setTimeout(function() {
              var newGridHeight = gridUtil.elementHeight($elm);
              var newGridWidth = gridUtil.elementWidth($elm);
              if (newGridHeight !== prevGridHeight || newGridWidth !== prevGridWidth) {
                uiGridCtrl.grid.gridHeight = newGridHeight;
                uiGridCtrl.grid.gridWidth = newGridWidth;
                $scope.$apply(function() {
                  uiGridCtrl.grid.refresh().then(function() {
                    getDimensions();
                    startTimeout();
                  });
                });
              } else {
                startTimeout();
              }
            }, 250);
          }
          startTimeout();
          $scope.$on('$destroy', function() {
            clearTimeout(resizeTimeoutId);
          });
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.cellNav', ['ui.grid']);
    module.constant('uiGridCellNavConstants', {
      FEATURE_NAME: 'gridCellNav',
      CELL_NAV_EVENT: 'cellNav',
      direction: {
        LEFT: 0,
        RIGHT: 1,
        UP: 2,
        DOWN: 3,
        PG_UP: 4,
        PG_DOWN: 5
      },
      EVENT_TYPE: {
        KEYDOWN: 0,
        CLICK: 1,
        CLEAR: 2
      }
    });
    module.factory('uiGridCellNavFactory', ['gridUtil', 'uiGridConstants', 'uiGridCellNavConstants', 'GridRowColumn', '$q', function(gridUtil, uiGridConstants, uiGridCellNavConstants, GridRowColumn, $q) {
      var UiGridCellNav = function UiGridCellNav(rowContainer, colContainer, leftColContainer, rightColContainer) {
        this.rows = rowContainer.visibleRowCache;
        this.columns = colContainer.visibleColumnCache;
        this.leftColumns = leftColContainer ? leftColContainer.visibleColumnCache : [];
        this.rightColumns = rightColContainer ? rightColContainer.visibleColumnCache : [];
        this.bodyContainer = rowContainer;
      };
      UiGridCellNav.prototype.getFocusableCols = function() {
        var allColumns = this.leftColumns.concat(this.columns, this.rightColumns);
        return allColumns.filter(function(col) {
          return col.colDef.allowCellFocus;
        });
      };
      UiGridCellNav.prototype.getFocusableRows = function() {
        return this.rows.filter(function(row) {
          return row.allowCellFocus !== false;
        });
      };
      UiGridCellNav.prototype.getNextRowCol = function(direction, curRow, curCol) {
        switch (direction) {
          case uiGridCellNavConstants.direction.LEFT:
            return this.getRowColLeft(curRow, curCol);
          case uiGridCellNavConstants.direction.RIGHT:
            return this.getRowColRight(curRow, curCol);
          case uiGridCellNavConstants.direction.UP:
            return this.getRowColUp(curRow, curCol);
          case uiGridCellNavConstants.direction.DOWN:
            return this.getRowColDown(curRow, curCol);
          case uiGridCellNavConstants.direction.PG_UP:
            return this.getRowColPageUp(curRow, curCol);
          case uiGridCellNavConstants.direction.PG_DOWN:
            return this.getRowColPageDown(curRow, curCol);
        }
      };
      UiGridCellNav.prototype.initializeSelection = function() {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        if (focusableCols.length === 0 || focusableRows.length === 0) {
          return null;
        }
        var curRowIndex = 0;
        var curColIndex = 0;
        return new GridRowColumn(focusableRows[0], focusableCols[0]);
      };
      UiGridCellNav.prototype.getRowColLeft = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 1;
        }
        var nextColIndex = curColIndex === 0 ? focusableCols.length - 1 : curColIndex - 1;
        if (nextColIndex > curColIndex) {
          if (curRowIndex === 0) {
            return new GridRowColumn(curRow, focusableCols[nextColIndex]);
          } else {
            return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[nextColIndex]);
          }
        } else {
          return new GridRowColumn(curRow, focusableCols[nextColIndex]);
        }
      };
      UiGridCellNav.prototype.getRowColRight = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 0;
        }
        var nextColIndex = curColIndex === focusableCols.length - 1 ? 0 : curColIndex + 1;
        if (nextColIndex < curColIndex) {
          if (curRowIndex === focusableRows.length - 1) {
            return new GridRowColumn(curRow, focusableCols[nextColIndex]);
          } else {
            return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[nextColIndex]);
          }
        } else {
          return new GridRowColumn(curRow, focusableCols[nextColIndex]);
        }
      };
      UiGridCellNav.prototype.getRowColDown = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 0;
        }
        if (curRowIndex === focusableRows.length - 1) {
          return new GridRowColumn(curRow, focusableCols[curColIndex]);
        } else {
          return new GridRowColumn(focusableRows[curRowIndex + 1], focusableCols[curColIndex]);
        }
      };
      UiGridCellNav.prototype.getRowColPageDown = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 0;
        }
        var pageSize = this.bodyContainer.minRowsToRender();
        if (curRowIndex >= focusableRows.length - pageSize) {
          return new GridRowColumn(focusableRows[focusableRows.length - 1], focusableCols[curColIndex]);
        } else {
          return new GridRowColumn(focusableRows[curRowIndex + pageSize], focusableCols[curColIndex]);
        }
      };
      UiGridCellNav.prototype.getRowColUp = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 0;
        }
        if (curRowIndex === 0) {
          return new GridRowColumn(curRow, focusableCols[curColIndex]);
        } else {
          return new GridRowColumn(focusableRows[curRowIndex - 1], focusableCols[curColIndex]);
        }
      };
      UiGridCellNav.prototype.getRowColPageUp = function(curRow, curCol) {
        var focusableCols = this.getFocusableCols();
        var focusableRows = this.getFocusableRows();
        var curColIndex = focusableCols.indexOf(curCol);
        var curRowIndex = focusableRows.indexOf(curRow);
        if (curColIndex === -1) {
          curColIndex = 0;
        }
        var pageSize = this.bodyContainer.minRowsToRender();
        if (curRowIndex - pageSize < 0) {
          return new GridRowColumn(focusableRows[0], focusableCols[curColIndex]);
        } else {
          return new GridRowColumn(focusableRows[curRowIndex - pageSize], focusableCols[curColIndex]);
        }
      };
      return UiGridCellNav;
    }]);
    module.service('uiGridCellNavService', ['gridUtil', 'uiGridConstants', 'uiGridCellNavConstants', '$q', 'uiGridCellNavFactory', 'GridRowColumn', 'ScrollEvent', function(gridUtil, uiGridConstants, uiGridCellNavConstants, $q, UiGridCellNav, GridRowColumn, ScrollEvent) {
      var service = {
        initializeGrid: function(grid) {
          grid.registerColumnBuilder(service.cellNavColumnBuilder);
          grid.cellNav = {};
          grid.cellNav.lastRowCol = null;
          grid.cellNav.focusedCells = [];
          service.defaultGridOptions(grid.options);
          var publicApi = {
            events: {cellNav: {
                navigate: function(newRowCol, oldRowCol) {},
                viewPortKeyDown: function(event, rowCol) {},
                viewPortKeyPress: function(event, rowCol) {}
              }},
            methods: {cellNav: {
                scrollToFocus: function(rowEntity, colDef) {
                  return service.scrollToFocus(grid, rowEntity, colDef);
                },
                getFocusedCell: function() {
                  return grid.cellNav.lastRowCol;
                },
                getCurrentSelection: function() {
                  return grid.cellNav.focusedCells;
                },
                rowColSelectIndex: function(rowCol) {
                  var index = -1;
                  for (var i = 0; i < grid.cellNav.focusedCells.length; i++) {
                    if (grid.cellNav.focusedCells[i].col.uid === rowCol.col.uid && grid.cellNav.focusedCells[i].row.uid === rowCol.row.uid) {
                      index = i;
                      break;
                    }
                  }
                  return index;
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.modifierKeysToMultiSelectCells = gridOptions.modifierKeysToMultiSelectCells === true;
        },
        decorateRenderContainers: function(grid) {
          var rightContainer = grid.hasRightContainer() ? grid.renderContainers.right : null;
          var leftContainer = grid.hasLeftContainer() ? grid.renderContainers.left : null;
          if (leftContainer !== null) {
            grid.renderContainers.left.cellNav = new UiGridCellNav(grid.renderContainers.body, leftContainer, rightContainer, grid.renderContainers.body);
          }
          if (rightContainer !== null) {
            grid.renderContainers.right.cellNav = new UiGridCellNav(grid.renderContainers.body, rightContainer, grid.renderContainers.body, leftContainer);
          }
          grid.renderContainers.body.cellNav = new UiGridCellNav(grid.renderContainers.body, grid.renderContainers.body, leftContainer, rightContainer);
        },
        getDirection: function(evt) {
          if (evt.keyCode === uiGridConstants.keymap.LEFT || (evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey)) {
            return uiGridCellNavConstants.direction.LEFT;
          }
          if (evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB) {
            return uiGridCellNavConstants.direction.RIGHT;
          }
          if (evt.keyCode === uiGridConstants.keymap.UP || (evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey)) {
            return uiGridCellNavConstants.direction.UP;
          }
          if (evt.keyCode === uiGridConstants.keymap.PG_UP) {
            return uiGridCellNavConstants.direction.PG_UP;
          }
          if (evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER && !(evt.ctrlKey || evt.altKey)) {
            return uiGridCellNavConstants.direction.DOWN;
          }
          if (evt.keyCode === uiGridConstants.keymap.PG_DOWN) {
            return uiGridCellNavConstants.direction.PG_DOWN;
          }
          return null;
        },
        cellNavColumnBuilder: function(colDef, col, gridOptions) {
          var promises = [];
          colDef.allowCellFocus = colDef.allowCellFocus === undefined ? true : colDef.allowCellFocus;
          return $q.all(promises);
        },
        scrollToFocus: function(grid, rowEntity, colDef) {
          var gridRow = null,
              gridCol = null;
          if (typeof(rowEntity) !== 'undefined' && rowEntity !== null) {
            gridRow = grid.getRow(rowEntity);
          }
          if (typeof(colDef) !== 'undefined' && colDef !== null) {
            gridCol = grid.getColumn(colDef.name ? colDef.name : colDef.field);
          }
          return grid.api.core.scrollToIfNecessary(gridRow, gridCol).then(function() {
            var rowCol = {
              row: gridRow,
              col: gridCol
            };
            if (gridRow !== null && gridCol !== null) {
              grid.cellNav.broadcastCellNav(rowCol);
            }
          });
        },
        getLeftWidth: function(grid, upToCol) {
          var width = 0;
          if (!upToCol) {
            return width;
          }
          var lastIndex = grid.renderContainers.body.visibleColumnCache.indexOf(upToCol);
          grid.renderContainers.body.visibleColumnCache.forEach(function(col, index) {
            if (index < lastIndex) {
              width += col.drawnWidth;
            }
          });
          var percentage = lastIndex === 0 ? 0 : (lastIndex + 1) / grid.renderContainers.body.visibleColumnCache.length;
          width += upToCol.drawnWidth * percentage;
          return width;
        }
      };
      return service;
    }]);
    module.directive('uiGridCellnav', ['gridUtil', 'uiGridCellNavService', 'uiGridCellNavConstants', 'uiGridConstants', 'GridRowColumn', '$timeout', '$compile', function(gridUtil, uiGridCellNavService, uiGridCellNavConstants, uiGridConstants, GridRowColumn, $timeout, $compile) {
      return {
        replace: true,
        priority: -150,
        require: '^uiGrid',
        scope: false,
        controller: function() {},
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              var _scope = $scope;
              var grid = uiGridCtrl.grid;
              uiGridCellNavService.initializeGrid(grid);
              uiGridCtrl.cellNav = {};
              uiGridCtrl.cellNav.makeRowCol = function(obj) {
                if (!(obj instanceof GridRowColumn)) {
                  obj = new GridRowColumn(obj.row, obj.col);
                }
                return obj;
              };
              uiGridCtrl.cellNav.getActiveCell = function() {
                var elms = $elm[0].getElementsByClassName('ui-grid-cell-focus');
                if (elms.length > 0) {
                  return elms[0];
                }
                return undefined;
              };
              uiGridCtrl.cellNav.broadcastCellNav = grid.cellNav.broadcastCellNav = function(newRowCol, modifierDown, originEvt) {
                modifierDown = !(modifierDown === undefined || !modifierDown);
                newRowCol = uiGridCtrl.cellNav.makeRowCol(newRowCol);
                uiGridCtrl.cellNav.broadcastFocus(newRowCol, modifierDown, originEvt);
                _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT, newRowCol, modifierDown, originEvt);
              };
              uiGridCtrl.cellNav.clearFocus = grid.cellNav.clearFocus = function() {
                grid.cellNav.focusedCells = [];
                _scope.$broadcast(uiGridCellNavConstants.CELL_NAV_EVENT);
              };
              uiGridCtrl.cellNav.broadcastFocus = function(rowCol, modifierDown, originEvt) {
                modifierDown = !(modifierDown === undefined || !modifierDown);
                rowCol = uiGridCtrl.cellNav.makeRowCol(rowCol);
                var row = rowCol.row,
                    col = rowCol.col;
                var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                if (grid.cellNav.lastRowCol === null || rowColSelectIndex === -1) {
                  var newRowCol = new GridRowColumn(row, col);
                  grid.api.cellNav.raise.navigate(newRowCol, grid.cellNav.lastRowCol);
                  grid.cellNav.lastRowCol = newRowCol;
                  if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells && modifierDown) {
                    grid.cellNav.focusedCells.push(rowCol);
                  } else {
                    grid.cellNav.focusedCells = [rowCol];
                  }
                } else if (grid.options.modifierKeysToMultiSelectCells && modifierDown && rowColSelectIndex >= 0) {
                  grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                }
              };
              uiGridCtrl.cellNav.handleKeyDown = function(evt) {
                var direction = uiGridCellNavService.getDirection(evt);
                if (direction === null) {
                  return null;
                }
                var containerId = 'body';
                if (evt.uiGridTargetRenderContainerId) {
                  containerId = evt.uiGridTargetRenderContainerId;
                }
                var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                if (lastRowCol) {
                  var rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(direction, lastRowCol.row, lastRowCol.col);
                  var focusableCols = uiGridCtrl.grid.renderContainers[containerId].cellNav.getFocusableCols();
                  var rowColSelectIndex = uiGridCtrl.grid.api.cellNav.rowColSelectIndex(rowCol);
                  if (direction === uiGridCellNavConstants.direction.LEFT && rowCol.col === focusableCols[focusableCols.length - 1] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) {
                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                    uiGridCtrl.cellNav.clearFocus();
                    return true;
                  } else if (direction === uiGridCellNavConstants.direction.RIGHT && rowCol.col === focusableCols[0] && rowCol.row === lastRowCol.row && evt.keyCode === uiGridConstants.keymap.TAB && !evt.shiftKey) {
                    grid.cellNav.focusedCells.splice(rowColSelectIndex, 1);
                    uiGridCtrl.cellNav.clearFocus();
                    return true;
                  }
                  grid.scrollToIfNecessary(rowCol.row, rowCol.col).then(function() {
                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                  });
                  evt.stopPropagation();
                  evt.preventDefault();
                  return false;
                }
              };
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {
              var _scope = $scope;
              var grid = uiGridCtrl.grid;
              function addAriaLiveRegion() {
                var ariaNotifierDomElt = '<div ' + 'id="' + grid.id + '-aria-speakable" ' + 'class="ui-grid-a11y-ariascreenreader-speakable ui-grid-offscreen" ' + 'aria-live="assertive" ' + 'role="region" ' + 'aria-atomic="true" ' + 'aria-hidden="false" ' + 'aria-relevant="additions" ' + '>' + '&nbsp;' + '</div>';
                var ariaNotifier = $compile(ariaNotifierDomElt)($scope);
                $elm.prepend(ariaNotifier);
                $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown, originEvt) {
                  if (originEvt && originEvt.type === 'focus') {
                    return ;
                  }
                  function setNotifyText(text) {
                    if (text === ariaNotifier.text()) {
                      return ;
                    }
                    ariaNotifier[0].style.clip = 'rect(0px,0px,0px,0px)';
                    ariaNotifier[0].innerHTML = "";
                    ariaNotifier[0].style.visibility = 'hidden';
                    ariaNotifier[0].style.visibility = 'visible';
                    if (text !== '') {
                      ariaNotifier[0].style.clip = 'auto';
                      ariaNotifier[0].appendChild(document.createTextNode(text + " "));
                      ariaNotifier[0].style.visibility = 'hidden';
                      ariaNotifier[0].style.visibility = 'visible';
                    }
                  }
                  var values = [];
                  var currentSelection = grid.api.cellNav.getCurrentSelection();
                  for (var i = 0; i < currentSelection.length; i++) {
                    values.push(currentSelection[i].getIntersectionValueFiltered());
                  }
                  var cellText = values.toString();
                  setNotifyText(cellText);
                });
              }
              addAriaLiveRegion();
            }
          };
        }
      };
    }]);
    module.directive('uiGridRenderContainer', ['$timeout', '$document', 'gridUtil', 'uiGridConstants', 'uiGridCellNavService', '$compile', 'uiGridCellNavConstants', function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, $compile, uiGridCellNavConstants) {
      return {
        replace: true,
        priority: -99999,
        require: ['^uiGrid', 'uiGridRenderContainer', '?^uiGridCellnav'],
        scope: false,
        compile: function() {
          return {post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0],
                  renderContainerCtrl = controllers[1],
                  uiGridCellnavCtrl = controllers[2];
              if (!uiGridCtrl.grid.api.cellNav) {
                return ;
              }
              var containerId = renderContainerCtrl.containerId;
              var grid = uiGridCtrl.grid;
              uiGridCellNavService.decorateRenderContainers(grid);
              if (containerId !== 'body') {
                return ;
              }
              if (uiGridCtrl.grid.options.modifierKeysToMultiSelectCells) {
                $elm.attr('aria-multiselectable', true);
              } else {
                $elm.attr('aria-multiselectable', false);
              }
              var focuser = $compile('<div class="ui-grid-focuser" role="region" aria-live="assertive" aria-atomic="false" tabindex="0" aria-controls="' + grid.id + '-aria-speakable ' + grid.id + '-grid-container' + '" aria-owns="' + grid.id + '-grid-container' + '"></div>')($scope);
              $elm.append(focuser);
              focuser.on('focus', function(evt) {
                evt.uiGridTargetRenderContainerId = containerId;
                var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                if (rowCol === null) {
                  rowCol = uiGridCtrl.grid.renderContainers[containerId].cellNav.getNextRowCol(uiGridCellNavConstants.direction.DOWN, null, null);
                  if (rowCol.row && rowCol.col) {
                    uiGridCtrl.cellNav.broadcastCellNav(rowCol);
                  }
                }
              });
              uiGridCellnavCtrl.setAriaActivedescendant = function(id) {
                $elm.attr('aria-activedescendant', id);
              };
              uiGridCellnavCtrl.removeAriaActivedescendant = function(id) {
                if ($elm.attr('aria-activedescendant') === id) {
                  $elm.attr('aria-activedescendant', '');
                }
              };
              uiGridCtrl.focus = function() {
                gridUtil.focus.byElement(focuser[0]);
              };
              var viewPortKeyDownWasRaisedForRowCol = null;
              focuser.on('keydown', function(evt) {
                evt.uiGridTargetRenderContainerId = containerId;
                var rowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                var result = uiGridCtrl.cellNav.handleKeyDown(evt);
                if (result === null) {
                  uiGridCtrl.grid.api.cellNav.raise.viewPortKeyDown(evt, rowCol);
                  viewPortKeyDownWasRaisedForRowCol = rowCol;
                }
              });
              focuser.on('keypress', function(evt) {
                if (viewPortKeyDownWasRaisedForRowCol) {
                  $timeout(function() {
                    uiGridCtrl.grid.api.cellNav.raise.viewPortKeyPress(evt, viewPortKeyDownWasRaisedForRowCol);
                  }, 4);
                  viewPortKeyDownWasRaisedForRowCol = null;
                }
              });
              $scope.$on('$destroy', function() {
                focuser.off();
              });
            }};
        }
      };
    }]);
    module.directive('uiGridViewport', ['$timeout', '$document', 'gridUtil', 'uiGridConstants', 'uiGridCellNavService', 'uiGridCellNavConstants', '$log', '$compile', function($timeout, $document, gridUtil, uiGridConstants, uiGridCellNavService, uiGridCellNavConstants, $log, $compile) {
      return {
        replace: true,
        priority: -99999,
        require: ['^uiGrid', '^uiGridRenderContainer', '?^uiGridCellnav'],
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {},
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0],
                  renderContainerCtrl = controllers[1];
              if (!uiGridCtrl.grid.api.cellNav) {
                return ;
              }
              var containerId = renderContainerCtrl.containerId;
              if (containerId !== 'body') {
                return ;
              }
              var grid = uiGridCtrl.grid;
              grid.api.core.on.scrollBegin($scope, function(args) {
                var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                if (lastRowCol === null) {
                  return ;
                }
                if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                  return ;
                }
                uiGridCtrl.cellNav.clearFocus();
              });
              grid.api.core.on.scrollEnd($scope, function(args) {
                var lastRowCol = uiGridCtrl.grid.api.cellNav.getFocusedCell();
                if (lastRowCol === null) {
                  return ;
                }
                if (!renderContainerCtrl.colContainer.containsColumn(lastRowCol.col)) {
                  return ;
                }
                uiGridCtrl.cellNav.broadcastCellNav(lastRowCol);
              });
              grid.api.cellNav.on.navigate($scope, function() {
                uiGridCtrl.focus();
              });
            }
          };
        }
      };
    }]);
    module.directive('uiGridCell', ['$timeout', '$document', 'uiGridCellNavService', 'gridUtil', 'uiGridCellNavConstants', 'uiGridConstants', 'GridRowColumn', function($timeout, $document, uiGridCellNavService, gridUtil, uiGridCellNavConstants, uiGridConstants, GridRowColumn) {
      return {
        priority: -150,
        restrict: 'A',
        require: ['^uiGrid', '?^uiGridCellnav'],
        scope: false,
        link: function($scope, $elm, $attrs, controllers) {
          var uiGridCtrl = controllers[0],
              uiGridCellnavCtrl = controllers[1];
          if (!uiGridCtrl.grid.api.cellNav) {
            return ;
          }
          if (!$scope.col.colDef.allowCellFocus) {
            return ;
          }
          var grid = uiGridCtrl.grid;
          $scope.focused = false;
          $elm.attr('tabindex', -1);
          $elm.find('div').on('click', function(evt) {
            uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), evt.ctrlKey || evt.metaKey, evt);
            evt.stopPropagation();
            $scope.$apply();
          });
          $elm.on('mousedown', preventMouseDown);
          if (uiGridCtrl.grid.api.edit) {
            uiGridCtrl.grid.api.edit.on.beginCellEdit($scope, function() {
              $elm.off('mousedown', preventMouseDown);
            });
            uiGridCtrl.grid.api.edit.on.afterCellEdit($scope, function() {
              $elm.on('mousedown', preventMouseDown);
            });
            uiGridCtrl.grid.api.edit.on.cancelCellEdit($scope, function() {
              $elm.on('mousedown', preventMouseDown);
            });
          }
          function preventMouseDown(evt) {
            evt.preventDefault();
          }
          $elm.on('focus', function(evt) {
            uiGridCtrl.cellNav.broadcastCellNav(new GridRowColumn($scope.row, $scope.col), false, evt);
            evt.stopPropagation();
            $scope.$apply();
          });
          $scope.$on(uiGridCellNavConstants.CELL_NAV_EVENT, function(evt, rowCol, modifierDown) {
            var isFocused = grid.cellNav.focusedCells.some(function(focusedRowCol, index) {
              return (focusedRowCol.row === $scope.row && focusedRowCol.col === $scope.col);
            });
            if (isFocused) {
              setFocused();
            } else {
              clearFocus();
            }
          });
          function setFocused() {
            if (!$scope.focused) {
              var div = $elm.find('div');
              div.addClass('ui-grid-cell-focus');
              $elm.attr('aria-selected', true);
              uiGridCellnavCtrl.setAriaActivedescendant($elm.attr('id'));
              $scope.focused = true;
            }
          }
          function clearFocus() {
            if ($scope.focused) {
              var div = $elm.find('div');
              div.removeClass('ui-grid-cell-focus');
              $elm.attr('aria-selected', false);
              uiGridCellnavCtrl.removeAriaActivedescendant($elm.attr('id'));
              $scope.focused = false;
            }
          }
          $scope.$on('$destroy', function() {
            $elm.find('div').off();
            $elm.off();
          });
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.edit', ['ui.grid']);
    module.constant('uiGridEditConstants', {
      EDITABLE_CELL_TEMPLATE: /EDITABLE_CELL_TEMPLATE/g,
      EDITABLE_CELL_DIRECTIVE: /editable_cell_directive/g,
      events: {
        BEGIN_CELL_EDIT: 'uiGridEventBeginCellEdit',
        END_CELL_EDIT: 'uiGridEventEndCellEdit',
        CANCEL_CELL_EDIT: 'uiGridEventCancelCellEdit'
      }
    });
    module.service('uiGridEditService', ['$q', 'uiGridConstants', 'gridUtil', function($q, uiGridConstants, gridUtil) {
      var service = {
        initializeGrid: function(grid) {
          service.defaultGridOptions(grid.options);
          grid.registerColumnBuilder(service.editColumnBuilder);
          grid.edit = {};
          var publicApi = {
            events: {edit: {
                afterCellEdit: function(rowEntity, colDef, newValue, oldValue) {},
                beginCellEdit: function(rowEntity, colDef, triggerEvent) {},
                cancelCellEdit: function(rowEntity, colDef) {}
              }},
            methods: {edit: {}}
          };
          grid.api.registerEventsFromObject(publicApi.events);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.cellEditableCondition = gridOptions.cellEditableCondition === undefined ? true : gridOptions.cellEditableCondition;
          gridOptions.enableCellEditOnFocus = gridOptions.enableCellEditOnFocus === undefined ? false : gridOptions.enableCellEditOnFocus;
        },
        editColumnBuilder: function(colDef, col, gridOptions) {
          var promises = [];
          colDef.enableCellEdit = colDef.enableCellEdit === undefined ? (gridOptions.enableCellEdit === undefined ? (colDef.type !== 'object') : gridOptions.enableCellEdit) : colDef.enableCellEdit;
          colDef.cellEditableCondition = colDef.cellEditableCondition === undefined ? gridOptions.cellEditableCondition : colDef.cellEditableCondition;
          if (colDef.enableCellEdit) {
            colDef.editableCellTemplate = colDef.editableCellTemplate || gridOptions.editableCellTemplate || 'ui-grid/cellEditor';
            promises.push(gridUtil.getTemplate(colDef.editableCellTemplate).then(function(template) {
              col.editableCellTemplate = template;
            }, function(res) {
              throw new Error("Couldn't fetch/use colDef.editableCellTemplate '" + colDef.editableCellTemplate + "'");
            }));
          }
          colDef.enableCellEditOnFocus = colDef.enableCellEditOnFocus === undefined ? gridOptions.enableCellEditOnFocus : colDef.enableCellEditOnFocus;
          return $q.all(promises);
        },
        isStartEditKey: function(evt) {
          if (evt.metaKey || evt.keyCode === uiGridConstants.keymap.ESC || evt.keyCode === uiGridConstants.keymap.SHIFT || evt.keyCode === uiGridConstants.keymap.CTRL || evt.keyCode === uiGridConstants.keymap.ALT || evt.keyCode === uiGridConstants.keymap.WIN || evt.keyCode === uiGridConstants.keymap.CAPSLOCK || evt.keyCode === uiGridConstants.keymap.LEFT || (evt.keyCode === uiGridConstants.keymap.TAB && evt.shiftKey) || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.TAB || evt.keyCode === uiGridConstants.keymap.UP || (evt.keyCode === uiGridConstants.keymap.ENTER && evt.shiftKey) || evt.keyCode === uiGridConstants.keymap.DOWN || evt.keyCode === uiGridConstants.keymap.ENTER) {
            return false;
          }
          return true;
        }
      };
      return service;
    }]);
    module.directive('uiGridEdit', ['gridUtil', 'uiGridEditService', function(gridUtil, uiGridEditService) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridEditService.initializeGrid(uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridViewport', ['uiGridEditConstants', function(uiGridEditConstants) {
      return {
        replace: true,
        priority: -99998,
        require: ['^uiGrid', '^uiGridRenderContainer'],
        scope: false,
        compile: function() {
          return {post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              if (!uiGridCtrl.grid.api.edit || !uiGridCtrl.grid.api.cellNav) {
                return ;
              }
              var containerId = controllers[1].containerId;
              if (containerId !== 'body') {
                return ;
              }
              $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
                uiGridCtrl.focus();
              });
              $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
                uiGridCtrl.focus();
              });
            }};
        }
      };
    }]);
    module.directive('uiGridCell', ['$compile', '$injector', '$timeout', 'uiGridConstants', 'uiGridEditConstants', 'gridUtil', '$parse', 'uiGridEditService', '$rootScope', function($compile, $injector, $timeout, uiGridConstants, uiGridEditConstants, gridUtil, $parse, uiGridEditService, $rootScope) {
      var touchstartTimeout = 500;
      if ($injector.has('uiGridCellNavService')) {
        var uiGridCellNavService = $injector.get('uiGridCellNavService');
      }
      return {
        priority: -100,
        restrict: 'A',
        scope: false,
        require: '?^uiGrid',
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var html;
          var origCellValue;
          var inEdit = false;
          var cellModel;
          var cancelTouchstartTimeout;
          var editCellScope;
          if (!$scope.col.colDef.enableCellEdit) {
            return ;
          }
          var cellNavNavigateDereg = function() {};
          var viewPortKeyDownDereg = function() {};
          var setEditable = function() {
            if ($scope.col.colDef.enableCellEdit && $scope.row.enableCellEdit !== false) {
              if (!$scope.beginEditEventsWired) {
                registerBeginEditEvents();
              }
            } else {
              if ($scope.beginEditEventsWired) {
                cancelBeginEditEvents();
              }
            }
          };
          setEditable();
          var rowWatchDereg = $scope.$watch('row', function(n, o) {
            if (n !== o) {
              setEditable();
            }
          });
          $scope.$on('$destroy', rowWatchDereg);
          function registerBeginEditEvents() {
            $elm.on('dblclick', beginEdit);
            $elm.on('touchstart', touchStart);
            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
              viewPortKeyDownDereg = uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
                if (rowCol === null) {
                  return ;
                }
                if (rowCol.row === $scope.row && rowCol.col === $scope.col && !$scope.col.colDef.enableCellEditOnFocus) {
                  beginEditKeyDown(evt);
                }
              });
              cellNavNavigateDereg = uiGridCtrl.grid.api.cellNav.on.navigate($scope, function(newRowCol, oldRowCol) {
                if ($scope.col.colDef.enableCellEditOnFocus) {
                  if ((!oldRowCol || newRowCol.row !== oldRowCol.row || newRowCol.col !== oldRowCol.col) && newRowCol.row === $scope.row && newRowCol.col === $scope.col) {
                    $timeout(function() {
                      beginEdit();
                    });
                  }
                }
              });
            }
            $scope.beginEditEventsWired = true;
          }
          function touchStart(event) {
            if (typeof(event.originalEvent) !== 'undefined' && event.originalEvent !== undefined) {
              event = event.originalEvent;
            }
            $elm.on('touchend', touchEnd);
            cancelTouchstartTimeout = $timeout(function() {}, touchstartTimeout);
            cancelTouchstartTimeout.then(function() {
              setTimeout(beginEdit, 0);
              $elm.off('touchend', touchEnd);
            });
          }
          function touchEnd(event) {
            $timeout.cancel(cancelTouchstartTimeout);
            $elm.off('touchend', touchEnd);
          }
          function cancelBeginEditEvents() {
            $elm.off('dblclick', beginEdit);
            $elm.off('keydown', beginEditKeyDown);
            $elm.off('touchstart', touchStart);
            cellNavNavigateDereg();
            viewPortKeyDownDereg();
            $scope.beginEditEventsWired = false;
          }
          function beginEditKeyDown(evt) {
            if (uiGridEditService.isStartEditKey(evt)) {
              beginEdit(evt);
            }
          }
          function shouldEdit(col, row) {
            return !row.isSaving && (angular.isFunction(col.colDef.cellEditableCondition) ? col.colDef.cellEditableCondition($scope) : col.colDef.cellEditableCondition);
          }
          function beginEdit(triggerEvent) {
            $scope.grid.api.core.scrollToIfNecessary($scope.row, $scope.col).then(function() {
              beginEditAfterScroll(triggerEvent);
            });
          }
          function beginEditAfterScroll(triggerEvent) {
            if (inEdit) {
              return ;
            }
            if (!shouldEdit($scope.col, $scope.row)) {
              return ;
            }
            cellModel = $parse($scope.row.getQualifiedColField($scope.col));
            origCellValue = cellModel($scope);
            html = $scope.col.editableCellTemplate;
            if ($scope.col.colDef.editModelField) {
              html = html.replace(uiGridConstants.MODEL_COL_FIELD, gridUtil.preEval('row.entity.' + $scope.col.colDef.editModelField));
            } else {
              html = html.replace(uiGridConstants.MODEL_COL_FIELD, $scope.row.getQualifiedColField($scope.col));
            }
            html = html.replace(uiGridConstants.COL_FIELD, 'grid.getCellValue(row, col)');
            var optionFilter = $scope.col.colDef.editDropdownFilter ? '|' + $scope.col.colDef.editDropdownFilter : '';
            html = html.replace(uiGridConstants.CUSTOM_FILTERS, optionFilter);
            var inputType = 'text';
            switch ($scope.col.colDef.type) {
              case 'boolean':
                inputType = 'checkbox';
                break;
              case 'number':
                inputType = 'number';
                break;
              case 'date':
                inputType = 'date';
                break;
            }
            html = html.replace('INPUT_TYPE', inputType);
            var editDropdownRowEntityOptionsArrayPath = $scope.col.colDef.editDropdownRowEntityOptionsArrayPath;
            if (editDropdownRowEntityOptionsArrayPath) {
              $scope.editDropdownOptionsArray = resolveObjectFromPath($scope.row.entity, editDropdownRowEntityOptionsArrayPath);
            } else {
              $scope.editDropdownOptionsArray = $scope.col.colDef.editDropdownOptionsArray;
            }
            $scope.editDropdownIdLabel = $scope.col.colDef.editDropdownIdLabel ? $scope.col.colDef.editDropdownIdLabel : 'id';
            $scope.editDropdownValueLabel = $scope.col.colDef.editDropdownValueLabel ? $scope.col.colDef.editDropdownValueLabel : 'value';
            var cellElement;
            var createEditor = function() {
              inEdit = true;
              cancelBeginEditEvents();
              var cellElement = angular.element(html);
              $elm.append(cellElement);
              editCellScope = $scope.$new();
              $compile(cellElement)(editCellScope);
              var gridCellContentsEl = angular.element($elm.children()[0]);
              gridCellContentsEl.addClass('ui-grid-cell-contents-hidden');
            };
            if (!$rootScope.$$phase) {
              $scope.$apply(createEditor);
            } else {
              createEditor();
            }
            var deregOnGridScroll = $scope.col.grid.api.core.on.scrollBegin($scope, function() {
              endEdit();
              $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
              deregOnGridScroll();
              deregOnEndCellEdit();
              deregOnCancelCellEdit();
            });
            var deregOnEndCellEdit = $scope.$on(uiGridEditConstants.events.END_CELL_EDIT, function() {
              endEdit();
              $scope.grid.api.edit.raise.afterCellEdit($scope.row.entity, $scope.col.colDef, cellModel($scope), origCellValue);
              deregOnEndCellEdit();
              deregOnGridScroll();
              deregOnCancelCellEdit();
            });
            var deregOnCancelCellEdit = $scope.$on(uiGridEditConstants.events.CANCEL_CELL_EDIT, function() {
              cancelEdit();
              deregOnCancelCellEdit();
              deregOnGridScroll();
              deregOnEndCellEdit();
            });
            $scope.$broadcast(uiGridEditConstants.events.BEGIN_CELL_EDIT, triggerEvent);
            $timeout(function() {
              $scope.grid.api.edit.raise.beginCellEdit($scope.row.entity, $scope.col.colDef, triggerEvent);
            });
          }
          function endEdit() {
            $scope.grid.disableScrolling = false;
            if (!inEdit) {
              return ;
            }
            if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
              uiGridCtrl.focus();
            }
            var gridCellContentsEl = angular.element($elm.children()[0]);
            editCellScope.$destroy();
            angular.element($elm.children()[1]).remove();
            gridCellContentsEl.removeClass('ui-grid-cell-contents-hidden');
            inEdit = false;
            registerBeginEditEvents();
            $scope.grid.api.core.notifyDataChange(uiGridConstants.dataChange.EDIT);
          }
          function cancelEdit() {
            $scope.grid.disableScrolling = false;
            if (!inEdit) {
              return ;
            }
            cellModel.assign($scope, origCellValue);
            $scope.$apply();
            $scope.grid.api.edit.raise.cancelCellEdit($scope.row.entity, $scope.col.colDef);
            endEdit();
          }
          function resolveObjectFromPath(object, path) {
            path = path.replace(/\[(\w+)\]/g, '.$1');
            path = path.replace(/^\./, '');
            var a = path.split('.');
            while (a.length) {
              var n = a.shift();
              if (n in object) {
                object = object[n];
              } else {
                return ;
              }
            }
            return object;
          }
        }
      };
    }]);
    module.directive('uiGridEditor', ['gridUtil', 'uiGridConstants', 'uiGridEditConstants', '$timeout', 'uiGridEditService', function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout, uiGridEditService) {
      return {
        scope: true,
        require: ['?^uiGrid', '?^uiGridRenderContainer', 'ngModel'],
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs) {},
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl,
                  renderContainerCtrl,
                  ngModel;
              if (controllers[0]) {
                uiGridCtrl = controllers[0];
              }
              if (controllers[1]) {
                renderContainerCtrl = controllers[1];
              }
              if (controllers[2]) {
                ngModel = controllers[2];
              }
              $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function(evt, triggerEvent) {
                $timeout(function() {
                  $elm[0].focus();
                  if ($scope.col.colDef.enableCellEditOnFocus || !(uiGridCtrl && uiGridCtrl.grid.api.cellNav)) {
                    $elm[0].select();
                  } else {
                    try {
                      $elm[0].setSelectionRange($elm[0].value.length, $elm[0].value.length);
                    } catch (ex) {}
                  }
                });
                if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                  var viewPortKeyDownUnregister = uiGridCtrl.grid.api.cellNav.on.viewPortKeyPress($scope, function(evt, rowCol) {
                    if (uiGridEditService.isStartEditKey(evt)) {
                      ngModel.$setViewValue(String.fromCharCode(evt.keyCode), evt);
                      ngModel.$render();
                    }
                    viewPortKeyDownUnregister();
                  });
                }
                $elm.on('blur', function(evt) {
                  $scope.stopEdit(evt);
                });
              });
              $scope.deepEdit = false;
              $scope.stopEdit = function(evt) {
                if ($scope.inputForm && !$scope.inputForm.$valid) {
                  evt.stopPropagation();
                  $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                } else {
                  $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                }
                $scope.deepEdit = false;
              };
              $elm.on('click', function(evt) {
                if ($elm[0].type !== 'checkbox') {
                  $scope.deepEdit = true;
                  $timeout(function() {
                    $scope.grid.disableScrolling = true;
                  });
                }
              });
              $elm.on('keydown', function(evt) {
                switch (evt.keyCode) {
                  case uiGridConstants.keymap.ESC:
                    evt.stopPropagation();
                    $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                    break;
                }
                if ($scope.deepEdit && (evt.keyCode === uiGridConstants.keymap.LEFT || evt.keyCode === uiGridConstants.keymap.RIGHT || evt.keyCode === uiGridConstants.keymap.UP || evt.keyCode === uiGridConstants.keymap.DOWN)) {
                  evt.stopPropagation();
                } else if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                  evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                  if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                    $scope.stopEdit(evt);
                  }
                } else {
                  switch (evt.keyCode) {
                    case uiGridConstants.keymap.ENTER:
                    case uiGridConstants.keymap.TAB:
                      evt.stopPropagation();
                      evt.preventDefault();
                      $scope.stopEdit(evt);
                      break;
                  }
                }
                return true;
              });
            }
          };
        }
      };
    }]);
    module.directive('uiGridEditor', ['$filter', function($filter) {
      function parseDateString(dateString) {
        if (typeof(dateString) === 'undefined' || dateString === '') {
          return null;
        }
        var parts = dateString.split('-');
        if (parts.length !== 3) {
          return null;
        }
        var year = parseInt(parts[0], 10);
        var month = parseInt(parts[1], 10);
        var day = parseInt(parts[2], 10);
        if (month < 1 || year < 1 || day < 1) {
          return null;
        }
        return new Date(year, (month - 1), day);
      }
      return {
        priority: -100,
        require: '?ngModel',
        link: function(scope, element, attrs, ngModel) {
          if (angular.version.minor === 2 && attrs.type && attrs.type === 'date' && ngModel) {
            ngModel.$formatters.push(function(modelValue) {
              ngModel.$setValidity(null, (!modelValue || !isNaN(modelValue.getTime())));
              return $filter('date')(modelValue, 'yyyy-MM-dd');
            });
            ngModel.$parsers.push(function(viewValue) {
              if (viewValue && viewValue.length > 0) {
                var dateValue = parseDateString(viewValue);
                ngModel.$setValidity(null, (dateValue && !isNaN(dateValue.getTime())));
                return dateValue;
              } else {
                ngModel.$setValidity(null, true);
                return null;
              }
            });
          }
        }
      };
    }]);
    module.directive('uiGridEditDropdown', ['uiGridConstants', 'uiGridEditConstants', function(uiGridConstants, uiGridEditConstants) {
      return {
        require: ['?^uiGrid', '?^uiGridRenderContainer'],
        scope: true,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs) {},
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl = controllers[0];
              var renderContainerCtrl = controllers[1];
              $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                $elm[0].focus();
                $elm[0].style.width = ($elm[0].parentElement.offsetWidth - 1) + 'px';
                $elm.on('blur', function(evt) {
                  $scope.stopEdit(evt);
                });
              });
              $scope.stopEdit = function(evt) {
                $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
              };
              $elm.on('keydown', function(evt) {
                switch (evt.keyCode) {
                  case uiGridConstants.keymap.ESC:
                    evt.stopPropagation();
                    $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                    break;
                }
                if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                  evt.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                  if (uiGridCtrl.cellNav.handleKeyDown(evt) !== null) {
                    $scope.stopEdit(evt);
                  }
                } else {
                  switch (evt.keyCode) {
                    case uiGridConstants.keymap.ENTER:
                    case uiGridConstants.keymap.TAB:
                      evt.stopPropagation();
                      evt.preventDefault();
                      $scope.stopEdit(evt);
                      break;
                  }
                }
                return true;
              });
            }
          };
        }
      };
    }]);
    module.directive('uiGridEditFileChooser', ['gridUtil', 'uiGridConstants', 'uiGridEditConstants', '$timeout', function(gridUtil, uiGridConstants, uiGridEditConstants, $timeout) {
      return {
        scope: true,
        require: ['?^uiGrid', '?^uiGridRenderContainer'],
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs) {},
            post: function($scope, $elm, $attrs, controllers) {
              var uiGridCtrl,
                  renderContainerCtrl;
              if (controllers[0]) {
                uiGridCtrl = controllers[0];
              }
              if (controllers[1]) {
                renderContainerCtrl = controllers[1];
              }
              var grid = uiGridCtrl.grid;
              var handleFileSelect = function(event) {
                var target = event.srcElement || event.target;
                if (target && target.files && target.files.length > 0) {
                  if (typeof($scope.col.colDef.editFileChooserCallback) === 'function') {
                    $scope.col.colDef.editFileChooserCallback($scope.row, $scope.col, target.files);
                  } else {
                    gridUtil.logError('You need to set colDef.editFileChooserCallback to use the file chooser');
                  }
                  target.form.reset();
                  $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                } else {
                  $scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                }
              };
              $elm[0].addEventListener('change', handleFileSelect, false);
              $scope.$on(uiGridEditConstants.events.BEGIN_CELL_EDIT, function() {
                $elm[0].focus();
                $elm[0].select();
                $elm.on('blur', function(evt) {
                  $scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                });
              });
            }
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.expandable', ['ui.grid']);
    module.service('uiGridExpandableService', ['gridUtil', '$compile', function(gridUtil, $compile) {
      var service = {
        initializeGrid: function(grid) {
          grid.expandable = {};
          grid.expandable.expandedAll = false;
          grid.options.enableExpandable = grid.options.enableExpandable !== false;
          grid.options.expandableRowHeight = grid.options.expandableRowHeight || 150;
          grid.options.expandableRowHeaderWidth = grid.options.expandableRowHeaderWidth || 40;
          if (grid.options.enableExpandable && !grid.options.expandableRowTemplate) {
            gridUtil.logError('You have not set the expandableRowTemplate, disabling expandable module');
            grid.options.enableExpandable = false;
          }
          var publicApi = {
            events: {expandable: {rowExpandedStateChanged: function(scope, row) {}}},
            methods: {expandable: {
                toggleRowExpansion: function(rowEntity) {
                  var row = grid.getRow(rowEntity);
                  if (row !== null) {
                    service.toggleRowExpansion(grid, row);
                  }
                },
                expandAllRows: function() {
                  service.expandAllRows(grid);
                },
                collapseAllRows: function() {
                  service.collapseAllRows(grid);
                },
                toggleAllRows: function() {
                  service.toggleAllRows(grid);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        toggleRowExpansion: function(grid, row) {
          row.isExpanded = !row.isExpanded;
          if (row.isExpanded) {
            row.height = row.grid.options.rowHeight + grid.options.expandableRowHeight;
          } else {
            row.height = row.grid.options.rowHeight;
            grid.expandable.expandedAll = false;
          }
          grid.api.expandable.raise.rowExpandedStateChanged(row);
        },
        expandAllRows: function(grid, $scope) {
          grid.renderContainers.body.visibleRowCache.forEach(function(row) {
            if (!row.isExpanded) {
              service.toggleRowExpansion(grid, row);
            }
          });
          grid.expandable.expandedAll = true;
          grid.queueGridRefresh();
        },
        collapseAllRows: function(grid) {
          grid.renderContainers.body.visibleRowCache.forEach(function(row) {
            if (row.isExpanded) {
              service.toggleRowExpansion(grid, row);
            }
          });
          grid.expandable.expandedAll = false;
          grid.queueGridRefresh();
        },
        toggleAllRows: function(grid) {
          if (grid.expandable.expandedAll) {
            service.collapseAllRows(grid);
          } else {
            service.expandAllRows(grid);
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridExpandable', ['uiGridExpandableService', '$templateCache', function(uiGridExpandableService, $templateCache) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              if (uiGridCtrl.grid.options.enableExpandableRowHeader !== false) {
                var expandableRowHeaderColDef = {
                  name: 'expandableButtons',
                  displayName: '',
                  exporterSuppressExport: true,
                  enableColumnResizing: false,
                  enableColumnMenu: false,
                  width: uiGridCtrl.grid.options.expandableRowHeaderWidth || 40
                };
                expandableRowHeaderColDef.cellTemplate = $templateCache.get('ui-grid/expandableRowHeader');
                expandableRowHeaderColDef.headerCellTemplate = $templateCache.get('ui-grid/expandableTopRowHeader');
                uiGridCtrl.grid.addRowHeaderColumn(expandableRowHeaderColDef);
              }
              uiGridExpandableService.initializeGrid(uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGrid', ['uiGridExpandableService', '$templateCache', function(uiGridExpandableService, $templateCache) {
      return {
        replace: true,
        priority: 599,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridCtrl.grid.api.core.on.renderingComplete($scope, function() {
                if ($scope.row && $scope.row.grid && $scope.row.grid.options && $scope.row.grid.options.enableExpandable) {
                  uiGridCtrl.grid.parentRow = $scope.row;
                }
              });
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridExpandableRow', ['uiGridExpandableService', '$timeout', '$compile', 'uiGridConstants', 'gridUtil', '$interval', '$log', function(uiGridExpandableService, $timeout, $compile, uiGridConstants, gridUtil, $interval, $log) {
      return {
        replace: false,
        priority: 0,
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              gridUtil.getTemplate($scope.grid.options.expandableRowTemplate).then(function(template) {
                if ($scope.grid.options.expandableRowScope) {
                  var expandableRowScope = $scope.grid.options.expandableRowScope;
                  for (var property in expandableRowScope) {
                    if (expandableRowScope.hasOwnProperty(property)) {
                      $scope[property] = expandableRowScope[property];
                    }
                  }
                }
                var expandedRowElement = $compile(template)($scope);
                $elm.append(expandedRowElement);
                $scope.row.expandedRendered = true;
              });
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {
              $scope.$on('$destroy', function() {
                $scope.row.expandedRendered = false;
              });
            }
          };
        }
      };
    }]);
    module.directive('uiGridRow', ['$compile', 'gridUtil', '$templateCache', function($compile, gridUtil, $templateCache) {
      return {
        priority: -200,
        scope: false,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, controllers) {
              $scope.expandableRow = {};
              $scope.expandableRow.shouldRenderExpand = function() {
                var ret = $scope.colContainer.name === 'body' && $scope.grid.options.enableExpandable !== false && $scope.row.isExpanded && (!$scope.grid.isScrollingVertically || $scope.row.expandedRendered);
                return ret;
              };
              $scope.expandableRow.shouldRenderFiller = function() {
                var ret = $scope.row.isExpanded && ($scope.colContainer.name !== 'body' || ($scope.grid.isScrollingVertically && !$scope.row.expandedRendered));
                return ret;
              };
            },
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
    module.directive('uiGridViewport', ['$compile', 'gridUtil', '$templateCache', function($compile, gridUtil, $templateCache) {
      return {
        priority: -200,
        scope: false,
        compile: function($elm, $attrs) {
          var rowRepeatDiv = angular.element($elm.children().children()[0]);
          var expandedRowFillerElement = $templateCache.get('ui-grid/expandableScrollFiller');
          var expandedRowElement = $templateCache.get('ui-grid/expandableRow');
          rowRepeatDiv.append(expandedRowElement);
          rowRepeatDiv.append(expandedRowFillerElement);
          return {
            pre: function($scope, $elm, $attrs, controllers) {},
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.exporter', ['ui.grid']);
    module.constant('uiGridExporterConstants', {
      featureName: 'exporter',
      ALL: 'all',
      VISIBLE: 'visible',
      SELECTED: 'selected',
      CSV_CONTENT: 'CSV_CONTENT',
      BUTTON_LABEL: 'BUTTON_LABEL',
      FILE_NAME: 'FILE_NAME'
    });
    module.service('uiGridExporterService', ['$q', 'uiGridExporterConstants', 'gridUtil', '$compile', '$interval', 'i18nService', function($q, uiGridExporterConstants, gridUtil, $compile, $interval, i18nService) {
      var service = {
        delay: 100,
        initializeGrid: function(grid) {
          grid.exporter = {};
          this.defaultGridOptions(grid.options);
          var publicApi = {
            events: {exporter: {}},
            methods: {exporter: {
                csvExport: function(rowTypes, colTypes) {
                  service.csvExport(grid, rowTypes, colTypes);
                },
                pdfExport: function(rowTypes, colTypes) {
                  service.pdfExport(grid, rowTypes, colTypes);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
          if (grid.api.core.addToGridMenu) {
            service.addToMenu(grid);
          } else {
            $interval(function() {
              if (grid.api.core.addToGridMenu) {
                service.addToMenu(grid);
              }
            }, this.delay, 1);
          }
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.exporterSuppressMenu = gridOptions.exporterSuppressMenu === true;
          gridOptions.exporterMenuLabel = gridOptions.exporterMenuLabel ? gridOptions.exporterMenuLabel : 'Export';
          gridOptions.exporterSuppressColumns = gridOptions.exporterSuppressColumns ? gridOptions.exporterSuppressColumns : [];
          gridOptions.exporterCsvColumnSeparator = gridOptions.exporterCsvColumnSeparator ? gridOptions.exporterCsvColumnSeparator : ',';
          gridOptions.exporterCsvFilename = gridOptions.exporterCsvFilename ? gridOptions.exporterCsvFilename : 'download.csv';
          gridOptions.exporterPdfFilename = gridOptions.exporterPdfFilename ? gridOptions.exporterPdfFilename : 'download.pdf';
          gridOptions.exporterOlderExcelCompatibility = gridOptions.exporterOlderExcelCompatibility === true;
          gridOptions.exporterPdfDefaultStyle = gridOptions.exporterPdfDefaultStyle ? gridOptions.exporterPdfDefaultStyle : {fontSize: 11};
          gridOptions.exporterPdfTableStyle = gridOptions.exporterPdfTableStyle ? gridOptions.exporterPdfTableStyle : {margin: [0, 5, 0, 15]};
          gridOptions.exporterPdfTableHeaderStyle = gridOptions.exporterPdfTableHeaderStyle ? gridOptions.exporterPdfTableHeaderStyle : {
            bold: true,
            fontSize: 12,
            color: 'black'
          };
          gridOptions.exporterPdfHeader = gridOptions.exporterPdfHeader ? gridOptions.exporterPdfHeader : null;
          gridOptions.exporterPdfFooter = gridOptions.exporterPdfFooter ? gridOptions.exporterPdfFooter : null;
          gridOptions.exporterPdfOrientation = gridOptions.exporterPdfOrientation ? gridOptions.exporterPdfOrientation : 'landscape';
          gridOptions.exporterPdfPageSize = gridOptions.exporterPdfPageSize ? gridOptions.exporterPdfPageSize : 'A4';
          gridOptions.exporterPdfMaxGridWidth = gridOptions.exporterPdfMaxGridWidth ? gridOptions.exporterPdfMaxGridWidth : 720;
          gridOptions.exporterMenuAllData = gridOptions.exporterMenuAllData !== undefined ? gridOptions.exporterMenuAllData : true;
          gridOptions.exporterMenuCsv = gridOptions.exporterMenuCsv !== undefined ? gridOptions.exporterMenuCsv : true;
          gridOptions.exporterMenuPdf = gridOptions.exporterMenuPdf !== undefined ? gridOptions.exporterMenuPdf : true;
          gridOptions.exporterPdfCustomFormatter = (gridOptions.exporterPdfCustomFormatter && typeof(gridOptions.exporterPdfCustomFormatter) === 'function') ? gridOptions.exporterPdfCustomFormatter : function(docDef) {
            return docDef;
          };
          gridOptions.exporterHeaderFilterUseName = gridOptions.exporterHeaderFilterUseName === true;
          gridOptions.exporterFieldCallback = gridOptions.exporterFieldCallback ? gridOptions.exporterFieldCallback : function(grid, row, col, value) {
            return value;
          };
          gridOptions.exporterAllDataFn = gridOptions.exporterAllDataFn ? gridOptions.exporterAllDataFn : null;
          if (gridOptions.exporterAllDataFn == null && gridOptions.exporterAllDataPromise) {
            gridOptions.exporterAllDataFn = gridOptions.exporterAllDataPromise;
          }
        },
        addToMenu: function(grid) {
          grid.api.core.addToGridMenu(grid, [{
            title: i18nService.getSafeText('gridMenu.exporterAllAsCsv'),
            action: function($event) {
              this.grid.api.exporter.csvExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
            },
            shown: function() {
              return this.grid.options.exporterMenuCsv && this.grid.options.exporterMenuAllData;
            },
            order: 200
          }, {
            title: i18nService.getSafeText('gridMenu.exporterVisibleAsCsv'),
            action: function($event) {
              this.grid.api.exporter.csvExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
            },
            shown: function() {
              return this.grid.options.exporterMenuCsv;
            },
            order: 201
          }, {
            title: i18nService.getSafeText('gridMenu.exporterSelectedAsCsv'),
            action: function($event) {
              this.grid.api.exporter.csvExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
            },
            shown: function() {
              return this.grid.options.exporterMenuCsv && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
            },
            order: 202
          }, {
            title: i18nService.getSafeText('gridMenu.exporterAllAsPdf'),
            action: function($event) {
              this.grid.api.exporter.pdfExport(uiGridExporterConstants.ALL, uiGridExporterConstants.ALL);
            },
            shown: function() {
              return this.grid.options.exporterMenuPdf && this.grid.options.exporterMenuAllData;
            },
            order: 203
          }, {
            title: i18nService.getSafeText('gridMenu.exporterVisibleAsPdf'),
            action: function($event) {
              this.grid.api.exporter.pdfExport(uiGridExporterConstants.VISIBLE, uiGridExporterConstants.VISIBLE);
            },
            shown: function() {
              return this.grid.options.exporterMenuPdf;
            },
            order: 204
          }, {
            title: i18nService.getSafeText('gridMenu.exporterSelectedAsPdf'),
            action: function($event) {
              this.grid.api.exporter.pdfExport(uiGridExporterConstants.SELECTED, uiGridExporterConstants.VISIBLE);
            },
            shown: function() {
              return this.grid.options.exporterMenuPdf && (this.grid.api.selection && this.grid.api.selection.getSelectedRows().length > 0);
            },
            order: 205
          }]);
        },
        csvExport: function(grid, rowTypes, colTypes) {
          var self = this;
          this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
            var exportColumnHeaders = self.getColumnHeaders(grid, colTypes);
            var exportData = self.getData(grid, rowTypes, colTypes);
            var csvContent = self.formatAsCsv(exportColumnHeaders, exportData, grid.options.exporterCsvColumnSeparator);
            self.downloadFile(grid.options.exporterCsvFilename, csvContent, grid.options.exporterOlderExcelCompatibility);
          });
        },
        loadAllDataIfNeeded: function(grid, rowTypes, colTypes) {
          if (rowTypes === uiGridExporterConstants.ALL && grid.rows.length !== grid.options.totalItems && grid.options.exporterAllDataFn) {
            return grid.options.exporterAllDataFn().then(function() {
              grid.modifyRows(grid.options.data);
            });
          } else {
            var deferred = $q.defer();
            deferred.resolve();
            return deferred.promise;
          }
        },
        getColumnHeaders: function(grid, colTypes) {
          var headers = [];
          var columns;
          if (colTypes === uiGridExporterConstants.ALL) {
            columns = grid.columns;
          } else {
            columns = grid.renderContainers.body.visibleColumnCache.filter(function(column) {
              return column.visible;
            });
          }
          columns.forEach(function(gridCol, index) {
            if (gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
              headers.push({
                name: gridCol.field,
                displayName: grid.options.exporterHeaderFilter ? (grid.options.exporterHeaderFilterUseName ? grid.options.exporterHeaderFilter(gridCol.name) : grid.options.exporterHeaderFilter(gridCol.displayName)) : gridCol.displayName,
                width: gridCol.drawnWidth ? gridCol.drawnWidth : gridCol.width,
                align: gridCol.colDef.type === 'number' ? 'right' : 'left'
              });
            }
          });
          return headers;
        },
        getData: function(grid, rowTypes, colTypes) {
          var data = [];
          var rows;
          var columns;
          switch (rowTypes) {
            case uiGridExporterConstants.ALL:
              rows = grid.rows;
              break;
            case uiGridExporterConstants.VISIBLE:
              rows = grid.getVisibleRows();
              break;
            case uiGridExporterConstants.SELECTED:
              if (grid.api.selection) {
                rows = grid.api.selection.getSelectedGridRows();
              } else {
                gridUtil.logError('selection feature must be enabled to allow selected rows to be exported');
              }
              break;
          }
          if (colTypes === uiGridExporterConstants.ALL) {
            columns = grid.columns;
          } else {
            columns = grid.renderContainers.body.visibleColumnCache.filter(function(column) {
              return column.visible;
            });
          }
          rows.forEach(function(row, index) {
            if (row.exporterEnableExporting !== false) {
              var extractedRow = [];
              columns.forEach(function(gridCol, index) {
                if ((gridCol.visible || colTypes === uiGridExporterConstants.ALL) && gridCol.colDef.exporterSuppressExport !== true && grid.options.exporterSuppressColumns.indexOf(gridCol.name) === -1) {
                  var extractedField = {value: grid.options.exporterFieldCallback(grid, row, gridCol, grid.getCellValue(row, gridCol))};
                  if (gridCol.colDef.exporterPdfAlign) {
                    extractedField.alignment = gridCol.colDef.exporterPdfAlign;
                  }
                  extractedRow.push(extractedField);
                }
              });
              data.push(extractedRow);
            }
          });
          return data;
        },
        formatAsCsv: function(exportColumnHeaders, exportData, separator) {
          var self = this;
          var bareHeaders = exportColumnHeaders.map(function(header) {
            return {value: header.displayName};
          });
          var csv = self.formatRowAsCsv(this, separator)(bareHeaders) + '\n';
          csv += exportData.map(this.formatRowAsCsv(this, separator)).join('\n');
          return csv;
        },
        formatRowAsCsv: function(exporter, separator) {
          return function(row) {
            return row.map(exporter.formatFieldAsCsv).join(separator);
          };
        },
        formatFieldAsCsv: function(field) {
          if (field.value == null) {
            return '';
          }
          if (typeof(field.value) === 'number') {
            return field.value;
          }
          if (typeof(field.value) === 'boolean') {
            return (field.value ? 'TRUE' : 'FALSE');
          }
          if (typeof(field.value) === 'string') {
            return '"' + field.value.replace(/"/g, '""') + '"';
          }
          return JSON.stringify(field.value);
        },
        isIE: function() {
          var match = navigator.userAgent.match(/(?:MSIE |Trident\/.*; rv:)(\d+)/);
          return match ? parseInt(match[1]) : false;
        },
        downloadFile: function(fileName, csvContent, exporterOlderExcelCompatibility) {
          var D = document;
          var a = D.createElement('a');
          var strMimeType = 'application/octet-stream;charset=utf-8';
          var rawFile;
          var ieVersion;
          ieVersion = this.isIE();
          if (ieVersion && ieVersion < 10) {
            var frame = D.createElement('iframe');
            document.body.appendChild(frame);
            frame.contentWindow.document.open("text/html", "replace");
            frame.contentWindow.document.write('sep=,\r\n' + csvContent);
            frame.contentWindow.document.close();
            frame.contentWindow.focus();
            frame.contentWindow.document.execCommand('SaveAs', true, fileName);
            document.body.removeChild(frame);
            return true;
          }
          if (navigator.msSaveBlob) {
            return navigator.msSaveOrOpenBlob(new Blob([exporterOlderExcelCompatibility ? "\uFEFF" : '', csvContent], {type: strMimeType}), fileName);
          }
          if ('download' in a) {
            var blob = new Blob([exporterOlderExcelCompatibility ? "\uFEFF" : '', csvContent], {type: strMimeType});
            rawFile = URL.createObjectURL(blob);
            a.setAttribute('download', fileName);
          } else {
            rawFile = 'data:' + strMimeType + ',' + encodeURIComponent(csvContent);
            a.setAttribute('target', '_blank');
          }
          a.href = rawFile;
          a.setAttribute('style', 'display:none;');
          D.body.appendChild(a);
          setTimeout(function() {
            if (a.click) {
              a.click();
            } else if (document.createEvent) {
              var eventObj = document.createEvent('MouseEvents');
              eventObj.initEvent('click', true, true);
              a.dispatchEvent(eventObj);
            }
            D.body.removeChild(a);
          }, this.delay);
        },
        pdfExport: function(grid, rowTypes, colTypes) {
          var self = this;
          this.loadAllDataIfNeeded(grid, rowTypes, colTypes).then(function() {
            var exportColumnHeaders = self.getColumnHeaders(grid, colTypes);
            var exportData = self.getData(grid, rowTypes, colTypes);
            var docDefinition = self.prepareAsPdf(grid, exportColumnHeaders, exportData);
            if (self.isIE()) {
              self.downloadPDF(grid.options.exporterPdfFilename, docDefinition);
            } else {
              pdfMake.createPdf(docDefinition).open();
            }
          });
        },
        downloadPDF: function(fileName, docDefinition) {
          var D = document;
          var a = D.createElement('a');
          var strMimeType = 'application/octet-stream;charset=utf-8';
          var rawFile;
          var ieVersion;
          ieVersion = this.isIE();
          var doc = pdfMake.createPdf(docDefinition);
          var blob;
          doc.getBuffer(function(buffer) {
            blob = new Blob([buffer]);
            if (ieVersion && ieVersion < 10) {
              var frame = D.createElement('iframe');
              document.body.appendChild(frame);
              frame.contentWindow.document.open("text/html", "replace");
              frame.contentWindow.document.write(blob);
              frame.contentWindow.document.close();
              frame.contentWindow.focus();
              frame.contentWindow.document.execCommand('SaveAs', true, fileName);
              document.body.removeChild(frame);
              return true;
            }
            if (navigator.msSaveBlob) {
              return navigator.msSaveBlob(blob, fileName);
            }
          });
        },
        prepareAsPdf: function(grid, exportColumnHeaders, exportData) {
          var headerWidths = this.calculatePdfHeaderWidths(grid, exportColumnHeaders);
          var headerColumns = exportColumnHeaders.map(function(header) {
            return {
              text: header.displayName,
              style: 'tableHeader'
            };
          });
          var stringData = exportData.map(this.formatRowAsPdf(this));
          var allData = [headerColumns].concat(stringData);
          var docDefinition = {
            pageOrientation: grid.options.exporterPdfOrientation,
            pageSize: grid.options.exporterPdfPageSize,
            content: [{
              style: 'tableStyle',
              table: {
                headerRows: 1,
                widths: headerWidths,
                body: allData
              }
            }],
            styles: {
              tableStyle: grid.options.exporterPdfTableStyle,
              tableHeader: grid.options.exporterPdfTableHeaderStyle
            },
            defaultStyle: grid.options.exporterPdfDefaultStyle
          };
          if (grid.options.exporterPdfLayout) {
            docDefinition.layout = grid.options.exporterPdfLayout;
          }
          if (grid.options.exporterPdfHeader) {
            docDefinition.header = grid.options.exporterPdfHeader;
          }
          if (grid.options.exporterPdfFooter) {
            docDefinition.footer = grid.options.exporterPdfFooter;
          }
          if (grid.options.exporterPdfCustomFormatter) {
            docDefinition = grid.options.exporterPdfCustomFormatter(docDefinition);
          }
          return docDefinition;
        },
        calculatePdfHeaderWidths: function(grid, exportHeaders) {
          var baseGridWidth = 0;
          exportHeaders.forEach(function(value) {
            if (typeof(value.width) === 'number') {
              baseGridWidth += value.width;
            }
          });
          var extraColumns = 0;
          exportHeaders.forEach(function(value) {
            if (value.width === '*') {
              extraColumns += 100;
            }
            if (typeof(value.width) === 'string' && value.width.match(/(\d)*%/)) {
              var percent = parseInt(value.width.match(/(\d)*%/)[0]);
              value.width = baseGridWidth * percent / 100;
              extraColumns += value.width;
            }
          });
          var gridWidth = baseGridWidth + extraColumns;
          return exportHeaders.map(function(header) {
            return header.width === '*' ? header.width : header.width * grid.options.exporterPdfMaxGridWidth / gridWidth;
          });
        },
        formatRowAsPdf: function(exporter) {
          return function(row) {
            return row.map(exporter.formatFieldAsPdfString);
          };
        },
        formatFieldAsPdfString: function(field) {
          var returnVal;
          if (field.value == null) {
            returnVal = '';
          } else if (typeof(field.value) === 'number') {
            returnVal = field.value.toString();
          } else if (typeof(field.value) === 'boolean') {
            returnVal = (field.value ? 'TRUE' : 'FALSE');
          } else if (typeof(field.value) === 'string') {
            returnVal = field.value.replace(/"/g, '""');
          } else {
            returnVal = JSON.stringify(field.value).replace(/^"/, '').replace(/"$/, '');
          }
          if (field.alignment && typeof(field.alignment) === 'string') {
            returnVal = {
              text: returnVal,
              alignment: field.alignment
            };
          }
          return returnVal;
        }
      };
      return service;
    }]);
    module.directive('uiGridExporter', ['uiGridExporterConstants', 'uiGridExporterService', 'gridUtil', '$compile', function(uiGridExporterConstants, uiGridExporterService, gridUtil, $compile) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          uiGridExporterService.initializeGrid(uiGridCtrl.grid);
          uiGridCtrl.grid.exporter.$scope = $scope;
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.grouping', ['ui.grid', 'ui.grid.treeBase']);
    module.constant('uiGridGroupingConstants', {
      featureName: "grouping",
      rowHeaderColName: 'treeBaseRowHeaderCol',
      EXPANDED: 'expanded',
      COLLAPSED: 'collapsed',
      aggregation: {
        COUNT: 'count',
        SUM: 'sum',
        MAX: 'max',
        MIN: 'min',
        AVG: 'avg'
      }
    });
    module.service('uiGridGroupingService', ['$q', 'uiGridGroupingConstants', 'gridUtil', 'rowSorter', 'GridRow', 'gridClassFactory', 'i18nService', 'uiGridConstants', 'uiGridTreeBaseService', function($q, uiGridGroupingConstants, gridUtil, rowSorter, GridRow, gridClassFactory, i18nService, uiGridConstants, uiGridTreeBaseService) {
      var service = {
        initializeGrid: function(grid, $scope) {
          uiGridTreeBaseService.initializeGrid(grid, $scope);
          grid.grouping = {};
          grid.grouping.groupHeaderCache = {};
          service.defaultGridOptions(grid.options);
          grid.registerRowsProcessor(service.groupRows, 400);
          grid.registerColumnBuilder(service.groupingColumnBuilder);
          grid.registerColumnsProcessor(service.groupingColumnProcessor, 400);
          var publicApi = {
            events: {grouping: {
                aggregationChanged: {},
                groupingChanged: {}
              }},
            methods: {grouping: {
                getGrouping: function(getExpanded) {
                  var grouping = service.getGrouping(grid);
                  grouping.grouping.forEach(function(group) {
                    group.colName = group.col.name;
                    delete group.col;
                  });
                  grouping.aggregations.forEach(function(aggregation) {
                    aggregation.colName = aggregation.col.name;
                    delete aggregation.col;
                  });
                  grouping.aggregations = grouping.aggregations.filter(function(aggregation) {
                    return !aggregation.aggregation.source || aggregation.aggregation.source !== 'grouping';
                  });
                  if (getExpanded) {
                    grouping.rowExpandedStates = service.getRowExpandedStates(grid.grouping.groupingHeaderCache);
                  }
                  return grouping;
                },
                setGrouping: function(config) {
                  service.setGrouping(grid, config);
                },
                groupColumn: function(columnName) {
                  var column = grid.getColumn(columnName);
                  service.groupColumn(grid, column);
                },
                ungroupColumn: function(columnName) {
                  var column = grid.getColumn(columnName);
                  service.ungroupColumn(grid, column);
                },
                clearGrouping: function() {
                  service.clearGrouping(grid);
                },
                aggregateColumn: function(columnName, aggregationDef, aggregationLabel) {
                  var column = grid.getColumn(columnName);
                  service.aggregateColumn(grid, column, aggregationDef, aggregationLabel);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
          grid.api.core.on.sortChanged($scope, service.tidyPriorities);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableGrouping = gridOptions.enableGrouping !== false;
          gridOptions.groupingShowCounts = gridOptions.groupingShowCounts !== false;
          gridOptions.groupingNullLabel = typeof(gridOptions.groupingNullLabel) === 'undefined' ? 'Null' : gridOptions.groupingNullLabel;
          gridOptions.enableGroupHeaderSelection = gridOptions.enableGroupHeaderSelection === true;
        },
        groupingColumnBuilder: function(colDef, col, gridOptions) {
          if (colDef.enableGrouping === false) {
            return ;
          }
          if (typeof(col.grouping) === 'undefined' && typeof(colDef.grouping) !== 'undefined') {
            col.grouping = angular.copy(colDef.grouping);
            if (typeof(col.grouping.groupPriority) !== 'undefined' && col.grouping.groupPriority > -1) {
              col.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
              col.treeAggregationFinalizerFn = service.groupedFinalizerFn;
            }
          } else if (typeof(col.grouping) === 'undefined') {
            col.grouping = {};
          }
          if (typeof(col.grouping) !== 'undefined' && typeof(col.grouping.groupPriority) !== 'undefined' && col.grouping.groupPriority >= 0) {
            col.suppressRemoveSort = true;
          }
          var groupColumn = {
            name: 'ui.grid.grouping.group',
            title: i18nService.get().grouping.group,
            icon: 'ui-grid-icon-indent-right',
            shown: function() {
              return typeof(this.context.col.grouping) === 'undefined' || typeof(this.context.col.grouping.groupPriority) === 'undefined' || this.context.col.grouping.groupPriority < 0;
            },
            action: function() {
              service.groupColumn(this.context.col.grid, this.context.col);
            }
          };
          var ungroupColumn = {
            name: 'ui.grid.grouping.ungroup',
            title: i18nService.get().grouping.ungroup,
            icon: 'ui-grid-icon-indent-left',
            shown: function() {
              return typeof(this.context.col.grouping) !== 'undefined' && typeof(this.context.col.grouping.groupPriority) !== 'undefined' && this.context.col.grouping.groupPriority >= 0;
            },
            action: function() {
              service.ungroupColumn(this.context.col.grid, this.context.col);
            }
          };
          var aggregateRemove = {
            name: 'ui.grid.grouping.aggregateRemove',
            title: i18nService.get().grouping.aggregate_remove,
            shown: function() {
              return typeof(this.context.col.treeAggregationFn) !== 'undefined';
            },
            action: function() {
              service.aggregateColumn(this.context.col.grid, this.context.col, null);
            }
          };
          var addAggregationMenu = function(type, title) {
            title = title || i18nService.get().grouping['aggregate_' + type] || type;
            var menuItem = {
              name: 'ui.grid.grouping.aggregate' + type,
              title: title,
              shown: function() {
                return typeof(this.context.col.treeAggregation) === 'undefined' || typeof(this.context.col.treeAggregation.type) === 'undefined' || this.context.col.treeAggregation.type !== type;
              },
              action: function() {
                service.aggregateColumn(this.context.col.grid, this.context.col, type);
              }
            };
            if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.grouping.aggregate' + type)) {
              col.menuItems.push(menuItem);
            }
          };
          if (col.colDef.groupingShowGroupingMenu !== false) {
            if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.grouping.group')) {
              col.menuItems.push(groupColumn);
            }
            if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.grouping.ungroup')) {
              col.menuItems.push(ungroupColumn);
            }
          }
          if (col.colDef.groupingShowAggregationMenu !== false) {
            angular.forEach(uiGridTreeBaseService.nativeAggregations(), function(aggregationDef, name) {
              addAggregationMenu(name);
            });
            angular.forEach(gridOptions.treeCustomAggregations, function(aggregationDef, name) {
              addAggregationMenu(name, aggregationDef.menuTitle);
            });
            if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.grouping.aggregateRemove')) {
              col.menuItems.push(aggregateRemove);
            }
          }
        },
        groupingColumnProcessor: function(columns, rows) {
          var grid = this;
          columns = service.moveGroupColumns(this, columns, rows);
          return columns;
        },
        groupedFinalizerFn: function(aggregation) {
          var col = this;
          if (typeof(aggregation.groupVal) !== 'undefined') {
            aggregation.rendered = aggregation.groupVal;
            if (col.grid.options.groupingShowCounts && col.colDef.type !== 'date') {
              aggregation.rendered += (' (' + aggregation.value + ')');
            }
          } else {
            aggregation.rendered = null;
          }
        },
        moveGroupColumns: function(grid, columns, rows) {
          if (grid.options.moveGroupColumns === false) {
            return ;
          }
          columns.forEach(function(column, index) {
            column.groupingPosition = index;
          });
          columns.sort(function(a, b) {
            var a_group,
                b_group;
            if (a.isRowHeader) {
              a_group = -1000;
            } else if (typeof(a.grouping) === 'undefined' || typeof(a.grouping.groupPriority) === 'undefined' || a.grouping.groupPriority < 0) {
              a_group = null;
            } else {
              a_group = a.grouping.groupPriority;
            }
            if (b.isRowHeader) {
              b_group = -1000;
            } else if (typeof(b.grouping) === 'undefined' || typeof(b.grouping.groupPriority) === 'undefined' || b.grouping.groupPriority < 0) {
              b_group = null;
            } else {
              b_group = b.grouping.groupPriority;
            }
            if (a_group !== null && b_group === null) {
              return -1;
            }
            if (b_group !== null && a_group === null) {
              return 1;
            }
            if (a_group !== null && b_group !== null) {
              return a_group - b_group;
            }
            return a.groupingPosition - b.groupingPosition;
          });
          columns.forEach(function(column, index) {
            delete column.groupingPosition;
          });
          return columns;
        },
        groupColumn: function(grid, column) {
          if (typeof(column.grouping) === 'undefined') {
            column.grouping = {};
          }
          var existingGrouping = service.getGrouping(grid);
          column.grouping.groupPriority = existingGrouping.grouping.length;
          if (!column.sort) {
            column.sort = {direction: uiGridConstants.ASC};
          } else if (typeof(column.sort.direction) === 'undefined' || column.sort.direction === null) {
            column.sort.direction = uiGridConstants.ASC;
          }
          column.treeAggregation = {
            type: uiGridGroupingConstants.aggregation.COUNT,
            source: 'grouping'
          };
          column.treeAggregationFn = uiGridTreeBaseService.nativeAggregations()[uiGridGroupingConstants.aggregation.COUNT].aggregationFn;
          column.treeAggregationFinalizerFn = service.groupedFinalizerFn;
          grid.api.grouping.raise.groupingChanged(column);
          grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
          grid.queueGridRefresh();
        },
        ungroupColumn: function(grid, column) {
          if (typeof(column.grouping) === 'undefined') {
            return ;
          }
          delete column.grouping.groupPriority;
          delete column.treeAggregation;
          delete column.customTreeAggregationFinalizer;
          service.tidyPriorities(grid);
          grid.api.grouping.raise.groupingChanged(column);
          grid.queueGridRefresh();
        },
        aggregateColumn: function(grid, column, aggregationType) {
          if (typeof(column.grouping) !== 'undefined' && typeof(column.grouping.groupPriority) !== 'undefined' && column.grouping.groupPriority >= 0) {
            service.ungroupColumn(grid, column);
          }
          var aggregationDef = {};
          if (typeof(grid.options.treeCustomAggregations[aggregationType]) !== 'undefined') {
            aggregationDef = grid.options.treeCustomAggregations[aggregationType];
          } else if (typeof(uiGridTreeBaseService.nativeAggregations()[aggregationType]) !== 'undefined') {
            aggregationDef = uiGridTreeBaseService.nativeAggregations()[aggregationType];
          }
          column.treeAggregation = {
            type: aggregationType,
            label: i18nService.get().aggregation[aggregationDef.label] || aggregationDef.label
          };
          column.treeAggregationFn = aggregationDef.aggregationFn;
          column.treeAggregationFinalizerFn = aggregationDef.finalizerFn;
          grid.api.grouping.raise.aggregationChanged(column);
          grid.queueGridRefresh();
        },
        setGrouping: function(grid, config) {
          if (typeof(config) === 'undefined') {
            return ;
          }
          service.clearGrouping(grid);
          if (config.grouping && config.grouping.length && config.grouping.length > 0) {
            config.grouping.forEach(function(group) {
              var col = grid.getColumn(group.colName);
              if (col) {
                service.groupColumn(grid, col);
              }
            });
          }
          if (config.aggregations && config.aggregations.length) {
            config.aggregations.forEach(function(aggregation) {
              var col = grid.getColumn(aggregation.colName);
              if (col) {
                service.aggregateColumn(grid, col, aggregation.aggregation.type);
              }
            });
          }
          if (config.rowExpandedStates) {
            service.applyRowExpandedStates(grid.grouping.groupingHeaderCache, config.rowExpandedStates);
          }
        },
        clearGrouping: function(grid) {
          var currentGrouping = service.getGrouping(grid);
          if (currentGrouping.grouping.length > 0) {
            currentGrouping.grouping.forEach(function(group) {
              if (!group.col) {
                group.col = grid.getColumn(group.colName);
              }
              service.ungroupColumn(grid, group.col);
            });
          }
          if (currentGrouping.aggregations.length > 0) {
            currentGrouping.aggregations.forEach(function(aggregation) {
              if (!aggregation.col) {
                aggregation.col = grid.getColumn(aggregation.colName);
              }
              service.aggregateColumn(grid, aggregation.col, null);
            });
          }
        },
        tidyPriorities: function(grid) {
          if ((typeof(grid) === 'undefined' || typeof(grid.grid) !== 'undefined') && typeof(this.grid) !== 'undefined') {
            grid = this.grid;
          }
          var groupArray = [];
          var sortArray = [];
          grid.columns.forEach(function(column, index) {
            if (typeof(column.grouping) !== 'undefined' && typeof(column.grouping.groupPriority) !== 'undefined' && column.grouping.groupPriority >= 0) {
              groupArray.push(column);
            } else if (typeof(column.sort) !== 'undefined' && typeof(column.sort.priority) !== 'undefined' && column.sort.priority >= 0) {
              sortArray.push(column);
            }
          });
          groupArray.sort(function(a, b) {
            return a.grouping.groupPriority - b.grouping.groupPriority;
          });
          groupArray.forEach(function(column, index) {
            column.grouping.groupPriority = index;
            column.suppressRemoveSort = true;
            if (typeof(column.sort) === 'undefined') {
              column.sort = {};
            }
            column.sort.priority = index;
          });
          var i = groupArray.length;
          sortArray.sort(function(a, b) {
            return a.sort.priority - b.sort.priority;
          });
          sortArray.forEach(function(column, index) {
            column.sort.priority = i;
            column.suppressRemoveSort = column.colDef.suppressRemoveSort;
            i++;
          });
        },
        groupRows: function(renderableRows) {
          if (renderableRows.length === 0) {
            return renderableRows;
          }
          var grid = this;
          grid.grouping.oldGroupingHeaderCache = grid.grouping.groupingHeaderCache || {};
          grid.grouping.groupingHeaderCache = {};
          var processingState = service.initialiseProcessingState(grid);
          var updateProcessingState = function(groupFieldState, stateIndex) {
            var fieldValue = grid.getCellValue(row, groupFieldState.col);
            if (!groupFieldState.initialised || rowSorter.getSortFn(grid, groupFieldState.col, renderableRows)(fieldValue, groupFieldState.currentValue) !== 0) {
              service.insertGroupHeader(grid, renderableRows, i, processingState, stateIndex);
              i++;
            }
          };
          for (var i = 0; i < renderableRows.length; i++) {
            var row = renderableRows[i];
            if (row.visible) {
              processingState.forEach(updateProcessingState);
            }
          }
          delete grid.grouping.oldGroupingHeaderCache;
          return renderableRows;
        },
        initialiseProcessingState: function(grid) {
          var processingState = [];
          var columnSettings = service.getGrouping(grid);
          columnSettings.grouping.forEach(function(groupItem, index) {
            processingState.push({
              fieldName: groupItem.field,
              col: groupItem.col,
              initialised: false,
              currentValue: null,
              currentRow: null
            });
          });
          return processingState;
        },
        getGrouping: function(grid) {
          var groupArray = [];
          var aggregateArray = [];
          grid.columns.forEach(function(column, columnIndex) {
            if (column.grouping) {
              if (typeof(column.grouping.groupPriority) !== 'undefined' && column.grouping.groupPriority >= 0) {
                groupArray.push({
                  field: column.field,
                  col: column,
                  groupPriority: column.grouping.groupPriority,
                  grouping: column.grouping
                });
              }
            }
            if (column.treeAggregation && column.treeAggregation.type) {
              aggregateArray.push({
                field: column.field,
                col: column,
                aggregation: column.treeAggregation
              });
            }
          });
          groupArray.sort(function(a, b) {
            return a.groupPriority - b.groupPriority;
          });
          groupArray.forEach(function(group, index) {
            group.grouping.groupPriority = index;
            group.groupPriority = index;
            delete group.grouping;
          });
          return {
            grouping: groupArray,
            aggregations: aggregateArray
          };
        },
        insertGroupHeader: function(grid, renderableRows, rowIndex, processingState, stateIndex) {
          var fieldName = processingState[stateIndex].fieldName;
          var col = processingState[stateIndex].col;
          var newValue = grid.getCellValue(renderableRows[rowIndex], col);
          var newDisplayValue = newValue;
          if (typeof(newValue) === 'undefined' || newValue === null) {
            newDisplayValue = grid.options.groupingNullLabel;
          }
          var cacheItem = grid.grouping.oldGroupingHeaderCache;
          for (var i = 0; i < stateIndex; i++) {
            if (cacheItem && cacheItem[processingState[i].currentValue]) {
              cacheItem = cacheItem[processingState[i].currentValue].children;
            }
          }
          var headerRow;
          if (cacheItem && cacheItem[newValue]) {
            headerRow = cacheItem[newValue].row;
            headerRow.entity = {};
          } else {
            headerRow = new GridRow({}, null, grid);
            gridClassFactory.rowTemplateAssigner.call(grid, headerRow);
          }
          headerRow.entity['$$' + processingState[stateIndex].col.uid] = {groupVal: newDisplayValue};
          headerRow.treeLevel = stateIndex;
          headerRow.groupHeader = true;
          headerRow.internalRow = true;
          headerRow.enableCellEdit = false;
          headerRow.enableSelection = grid.options.enableGroupHeaderSelection;
          processingState[stateIndex].initialised = true;
          processingState[stateIndex].currentValue = newValue;
          processingState[stateIndex].currentRow = headerRow;
          service.finaliseProcessingState(processingState, stateIndex + 1);
          renderableRows.splice(rowIndex, 0, headerRow);
          cacheItem = grid.grouping.groupingHeaderCache;
          for (i = 0; i < stateIndex; i++) {
            cacheItem = cacheItem[processingState[i].currentValue].children;
          }
          cacheItem[newValue] = {
            row: headerRow,
            children: {}
          };
        },
        finaliseProcessingState: function(processingState, stateIndex) {
          for (var i = stateIndex; i < processingState.length; i++) {
            processingState[i].initialised = false;
            processingState[i].currentRow = null;
            processingState[i].currentValue = null;
          }
        },
        getRowExpandedStates: function(treeChildren) {
          if (typeof(treeChildren) === 'undefined') {
            return {};
          }
          var newChildren = {};
          angular.forEach(treeChildren, function(value, key) {
            newChildren[key] = {state: value.row.treeNode.state};
            if (value.children) {
              newChildren[key].children = service.getRowExpandedStates(value.children);
            } else {
              newChildren[key].children = {};
            }
          });
          return newChildren;
        },
        applyRowExpandedStates: function(currentNode, expandedStates) {
          if (typeof(expandedStates) === 'undefined') {
            return ;
          }
          angular.forEach(expandedStates, function(value, key) {
            if (currentNode[key]) {
              currentNode[key].row.treeNode.state = value.state;
              if (value.children && currentNode[key].children) {
                service.applyRowExpandedStates(currentNode[key].children, value.children);
              }
            }
          });
        }
      };
      return service;
    }]);
    module.directive('uiGridGrouping', ['uiGridGroupingConstants', 'uiGridGroupingService', '$templateCache', function(uiGridGroupingConstants, uiGridGroupingService, $templateCache) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              if (uiGridCtrl.grid.options.enableGrouping !== false) {
                uiGridGroupingService.initializeGrid(uiGridCtrl.grid, $scope);
              }
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.importer', ['ui.grid']);
    module.constant('uiGridImporterConstants', {featureName: 'importer'});
    module.service('uiGridImporterService', ['$q', 'uiGridConstants', 'uiGridImporterConstants', 'gridUtil', '$compile', '$interval', 'i18nService', '$window', function($q, uiGridConstants, uiGridImporterConstants, gridUtil, $compile, $interval, i18nService, $window) {
      var service = {
        initializeGrid: function($scope, grid) {
          grid.importer = {$scope: $scope};
          this.defaultGridOptions(grid.options);
          var publicApi = {
            events: {importer: {}},
            methods: {importer: {importFile: function(fileObject) {
                  service.importThisFile(grid, fileObject);
                }}}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
          if (grid.options.enableImporter && grid.options.importerShowMenu) {
            if (grid.api.core.addToGridMenu) {
              service.addToMenu(grid);
            } else {
              $interval(function() {
                if (grid.api.core.addToGridMenu) {
                  service.addToMenu(grid);
                }
              }, 100, 1);
            }
          }
        },
        defaultGridOptions: function(gridOptions) {
          if (gridOptions.enableImporter || gridOptions.enableImporter === undefined) {
            if (!($window.hasOwnProperty('File') && $window.hasOwnProperty('FileReader') && $window.hasOwnProperty('FileList') && $window.hasOwnProperty('Blob'))) {
              gridUtil.logError('The File APIs are not fully supported in this browser, grid importer cannot be used.');
              gridOptions.enableImporter = false;
            } else {
              gridOptions.enableImporter = true;
            }
          } else {
            gridOptions.enableImporter = false;
          }
          gridOptions.importerProcessHeaders = gridOptions.importerProcessHeaders || service.processHeaders;
          gridOptions.importerHeaderFilter = gridOptions.importerHeaderFilter || function(displayName) {
            return displayName;
          };
          if (!gridOptions.importerErrorCallback || typeof(gridOptions.importerErrorCallback) !== 'function') {
            delete gridOptions.importerErrorCallback;
          }
          if (gridOptions.enableImporter === true && !gridOptions.importerDataAddCallback) {
            gridUtil.logError("You have not set an importerDataAddCallback, importer is disabled");
            gridOptions.enableImporter = false;
          }
          gridOptions.importerShowMenu = gridOptions.importerShowMenu !== false;
          gridOptions.importerObjectCallback = gridOptions.importerObjectCallback || function(grid, newObject) {
            return newObject;
          };
        },
        addToMenu: function(grid) {
          grid.api.core.addToGridMenu(grid, [{
            title: i18nService.getSafeText('gridMenu.importerTitle'),
            order: 150
          }, {
            templateUrl: 'ui-grid/importerMenuItemContainer',
            action: function($event) {
              this.grid.api.importer.importAFile(grid);
            },
            order: 151
          }]);
        },
        importThisFile: function(grid, fileObject) {
          if (!fileObject) {
            gridUtil.logError('No file object provided to importThisFile, should be impossible, aborting');
            return ;
          }
          var reader = new FileReader();
          switch (fileObject.type) {
            case 'application/json':
              reader.onload = service.importJsonClosure(grid);
              break;
            default:
              reader.onload = service.importCsvClosure(grid);
              break;
          }
          reader.readAsText(fileObject);
        },
        importJsonClosure: function(grid) {
          return function(importFile) {
            var newObjects = [];
            var newObject;
            var importArray = service.parseJson(grid, importFile);
            if (importArray === null) {
              return ;
            }
            importArray.forEach(function(value, index) {
              newObject = service.newObject(grid);
              angular.extend(newObject, value);
              newObject = grid.options.importerObjectCallback(grid, newObject);
              newObjects.push(newObject);
            });
            service.addObjects(grid, newObjects);
          };
        },
        parseJson: function(grid, importFile) {
          var loadedObjects;
          try {
            loadedObjects = JSON.parse(importFile.target.result);
          } catch (e) {
            service.alertError(grid, 'importer.invalidJson', 'File could not be processed, is it valid json? Content was: ', importFile.target.result);
            return ;
          }
          if (!Array.isArray(loadedObjects)) {
            service.alertError(grid, 'importer.jsonNotarray', 'Import failed, file is not an array, file was: ', importFile.target.result);
            return [];
          } else {
            return loadedObjects;
          }
        },
        importCsvClosure: function(grid) {
          return function(importFile) {
            var importArray = service.parseCsv(importFile);
            if (!importArray || importArray.length < 1) {
              service.alertError(grid, 'importer.invalidCsv', 'File could not be processed, is it valid csv? Content was: ', importFile.target.result);
              return ;
            }
            var newObjects = service.createCsvObjects(grid, importArray);
            if (!newObjects || newObjects.length === 0) {
              service.alertError(grid, 'importer.noObjects', 'Objects were not able to be derived, content was: ', importFile.target.result);
              return ;
            }
            service.addObjects(grid, newObjects);
          };
        },
        parseCsv: function(importFile) {
          var csv = importFile.target.result;
          return CSV.parse(csv);
        },
        createCsvObjects: function(grid, importArray) {
          var headerMapping = grid.options.importerProcessHeaders(grid, importArray.shift());
          if (!headerMapping || headerMapping.length === 0) {
            service.alertError(grid, 'importer.noHeaders', 'Column names could not be derived, content was: ', importArray);
            return [];
          }
          var newObjects = [];
          var newObject;
          importArray.forEach(function(row, index) {
            newObject = service.newObject(grid);
            if (row !== null) {
              row.forEach(function(field, index) {
                if (headerMapping[index] !== null) {
                  newObject[headerMapping[index]] = field;
                }
              });
            }
            newObject = grid.options.importerObjectCallback(grid, newObject);
            newObjects.push(newObject);
          });
          return newObjects;
        },
        processHeaders: function(grid, headerRow) {
          var headers = [];
          if (!grid.options.columnDefs || grid.options.columnDefs.length === 0) {
            headerRow.forEach(function(value, index) {
              headers.push(value.replace(/[^0-9a-zA-Z\-_]/g, '_'));
            });
            return headers;
          } else {
            var lookupHash = service.flattenColumnDefs(grid, grid.options.columnDefs);
            headerRow.forEach(function(value, index) {
              if (lookupHash[value]) {
                headers.push(lookupHash[value]);
              } else if (lookupHash[value.toLowerCase()]) {
                headers.push(lookupHash[value.toLowerCase()]);
              } else {
                headers.push(null);
              }
            });
            return headers;
          }
        },
        flattenColumnDefs: function(grid, columnDefs) {
          var flattenedHash = {};
          columnDefs.forEach(function(columnDef, index) {
            if (columnDef.name) {
              flattenedHash[columnDef.name] = columnDef.field || columnDef.name;
              flattenedHash[columnDef.name.toLowerCase()] = columnDef.field || columnDef.name;
            }
            if (columnDef.field) {
              flattenedHash[columnDef.field] = columnDef.field || columnDef.name;
              flattenedHash[columnDef.field.toLowerCase()] = columnDef.field || columnDef.name;
            }
            if (columnDef.displayName) {
              flattenedHash[columnDef.displayName] = columnDef.field || columnDef.name;
              flattenedHash[columnDef.displayName.toLowerCase()] = columnDef.field || columnDef.name;
            }
            if (columnDef.displayName && grid.options.importerHeaderFilter) {
              flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName)] = columnDef.field || columnDef.name;
              flattenedHash[grid.options.importerHeaderFilter(columnDef.displayName).toLowerCase()] = columnDef.field || columnDef.name;
            }
          });
          return flattenedHash;
        },
        addObjects: function(grid, newObjects, $scope) {
          if (grid.api.rowEdit) {
            var dataChangeDereg = grid.registerDataChangeCallback(function() {
              grid.api.rowEdit.setRowsDirty(newObjects);
              dataChangeDereg();
            }, [uiGridConstants.dataChange.ROW]);
            grid.importer.$scope.$on('$destroy', dataChangeDereg);
          }
          grid.importer.$scope.$apply(grid.options.importerDataAddCallback(grid, newObjects));
        },
        newObject: function(grid) {
          if (typeof(grid.options) !== "undefined" && typeof(grid.options.importerNewObject) !== "undefined") {
            return new grid.options.importerNewObject();
          } else {
            return {};
          }
        },
        alertError: function(grid, alertI18nToken, consoleMessage, context) {
          if (grid.options.importerErrorCallback) {
            grid.options.importerErrorCallback(grid, alertI18nToken, consoleMessage, context);
          } else {
            $window.alert(i18nService.getSafeText(alertI18nToken));
            gridUtil.logError(consoleMessage + context);
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridImporter', ['uiGridImporterConstants', 'uiGridImporterService', 'gridUtil', '$compile', function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          uiGridImporterService.initializeGrid($scope, uiGridCtrl.grid);
        }
      };
    }]);
    module.directive('uiGridImporterMenuItem', ['uiGridImporterConstants', 'uiGridImporterService', 'gridUtil', '$compile', function(uiGridImporterConstants, uiGridImporterService, gridUtil, $compile) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        templateUrl: 'ui-grid/importerMenuItem',
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var handleFileSelect = function(event) {
            var target = event.srcElement || event.target;
            if (target && target.files && target.files.length === 1) {
              var fileObject = target.files[0];
              uiGridImporterService.importThisFile(grid, fileObject);
              target.form.reset();
            }
          };
          var fileChooser = $elm[0].querySelectorAll('.ui-grid-importer-file-chooser');
          var grid = uiGridCtrl.grid;
          if (fileChooser.length !== 1) {
            gridUtil.logError('Found > 1 or < 1 file choosers within the menu item, error, cannot continue');
          } else {
            fileChooser[0].addEventListener('change', handleFileSelect, false);
          }
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.infiniteScroll', ['ui.grid']);
    module.service('uiGridInfiniteScrollService', ['gridUtil', '$compile', '$timeout', 'uiGridConstants', 'ScrollEvent', '$q', function(gridUtil, $compile, $timeout, uiGridConstants, ScrollEvent, $q) {
      var service = {
        initializeGrid: function(grid, $scope) {
          service.defaultGridOptions(grid.options);
          if (!grid.options.enableInfiniteScroll) {
            return ;
          }
          grid.infiniteScroll = {dataLoading: false};
          service.setScrollDirections(grid, grid.options.infiniteScrollUp, grid.options.infiniteScrollDown);
          grid.api.core.on.scrollEnd($scope, service.handleScroll);
          var publicApi = {
            events: {infiniteScroll: {
                needLoadMoreData: function($scope, fn) {},
                needLoadMoreDataTop: function($scope, fn) {}
              }},
            methods: {infiniteScroll: {
                dataLoaded: function(scrollUp, scrollDown) {
                  service.setScrollDirections(grid, scrollUp, scrollDown);
                  var promise = service.adjustScroll(grid).then(function() {
                    grid.infiniteScroll.dataLoading = false;
                  });
                  return promise;
                },
                resetScroll: function(scrollUp, scrollDown) {
                  service.setScrollDirections(grid, scrollUp, scrollDown);
                  return service.adjustInfiniteScrollPosition(grid, 0);
                },
                saveScrollPercentage: function() {
                  grid.infiniteScroll.prevScrolltopPercentage = grid.renderContainers.body.prevScrolltopPercentage;
                  grid.infiniteScroll.previousVisibleRows = grid.renderContainers.body.visibleRowCache.length;
                },
                dataRemovedTop: function(scrollUp, scrollDown) {
                  service.dataRemovedTop(grid, scrollUp, scrollDown);
                },
                dataRemovedBottom: function(scrollUp, scrollDown) {
                  service.dataRemovedBottom(grid, scrollUp, scrollDown);
                },
                setScrollDirections: function(scrollUp, scrollDown) {
                  service.setScrollDirections(grid, scrollUp, scrollDown);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableInfiniteScroll = gridOptions.enableInfiniteScroll !== false;
          gridOptions.infiniteScrollRowsFromEnd = gridOptions.infiniteScrollRowsFromEnd || 20;
          gridOptions.infiniteScrollUp = gridOptions.infiniteScrollUp === true;
          gridOptions.infiniteScrollDown = gridOptions.infiniteScrollDown !== false;
        },
        setScrollDirections: function(grid, scrollUp, scrollDown) {
          grid.infiniteScroll.scrollUp = (scrollUp === true);
          grid.suppressParentScrollUp = (scrollUp === true);
          grid.infiniteScroll.scrollDown = (scrollDown !== false);
          grid.suppressParentScrollDown = (scrollDown !== false);
        },
        handleScroll: function(args) {
          if (args.grid.infiniteScroll && args.grid.infiniteScroll.dataLoading || args.source === 'ui.grid.adjustInfiniteScrollPosition') {
            return ;
          }
          if (args.y) {
            var percentage;
            var targetPercentage = args.grid.options.infiniteScrollRowsFromEnd / args.grid.renderContainers.body.visibleRowCache.length;
            if (args.grid.scrollDirection === uiGridConstants.scrollDirection.UP) {
              percentage = args.y.percentage;
              if (percentage <= targetPercentage) {
                service.loadData(args.grid);
              }
            } else if (args.grid.scrollDirection === uiGridConstants.scrollDirection.DOWN) {
              percentage = 1 - args.y.percentage;
              if (percentage <= targetPercentage) {
                service.loadData(args.grid);
              }
            }
          }
        },
        loadData: function(grid) {
          grid.infiniteScroll.previousVisibleRows = grid.renderContainers.body.visibleRowCache.length;
          grid.infiniteScroll.direction = grid.scrollDirection;
          delete grid.infiniteScroll.prevScrolltopPercentage;
          if (grid.scrollDirection === uiGridConstants.scrollDirection.UP && grid.infiniteScroll.scrollUp) {
            grid.infiniteScroll.dataLoading = true;
            grid.api.infiniteScroll.raise.needLoadMoreDataTop();
          } else if (grid.scrollDirection === uiGridConstants.scrollDirection.DOWN && grid.infiniteScroll.scrollDown) {
            grid.infiniteScroll.dataLoading = true;
            grid.api.infiniteScroll.raise.needLoadMoreData();
          }
        },
        adjustScroll: function(grid) {
          var promise = $q.defer();
          $timeout(function() {
            var newPercentage;
            if (grid.infiniteScroll.direction === undefined) {
              service.adjustInfiniteScrollPosition(grid, 0);
            }
            var newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
            var oldPercentage,
                oldTopRow;
            var halfViewport = grid.getViewportHeight() / grid.options.rowHeight / 2;
            if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.UP) {
              oldPercentage = grid.infiniteScroll.prevScrolltopPercentage || 0;
              oldTopRow = oldPercentage * grid.infiniteScroll.previousVisibleRows;
              newPercentage = (newVisibleRows - grid.infiniteScroll.previousVisibleRows + oldTopRow + halfViewport) / newVisibleRows;
              service.adjustInfiniteScrollPosition(grid, newPercentage);
              $timeout(function() {
                promise.resolve();
              });
            }
            if (grid.infiniteScroll.direction === uiGridConstants.scrollDirection.DOWN) {
              oldPercentage = grid.infiniteScroll.prevScrolltopPercentage || 1;
              oldTopRow = oldPercentage * grid.infiniteScroll.previousVisibleRows;
              newPercentage = (oldTopRow - halfViewport) / newVisibleRows;
              service.adjustInfiniteScrollPosition(grid, newPercentage);
              $timeout(function() {
                promise.resolve();
              });
            }
          }, 0);
          return promise.promise;
        },
        adjustInfiniteScrollPosition: function(grid, percentage) {
          var scrollEvent = new ScrollEvent(grid, null, null, 'ui.grid.adjustInfiniteScrollPosition');
          if (percentage === 0 && grid.infiniteScroll.scrollUp) {
            scrollEvent.y = {pixels: 1};
          } else {
            scrollEvent.y = {percentage: percentage};
          }
          grid.scrollContainers('', scrollEvent);
        },
        dataRemovedTop: function(grid, scrollUp, scrollDown) {
          service.setScrollDirections(grid, scrollUp, scrollDown);
          var newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
          var oldScrollRow = grid.infiniteScroll.prevScrolltopPercentage * grid.infiniteScroll.previousVisibleRows;
          var newScrollRow = oldScrollRow - (grid.infiniteScroll.previousVisibleRows - newVisibleRows);
          var newScrollPercent = newScrollRow / newVisibleRows;
          return service.adjustInfiniteScrollPosition(grid, newScrollPercent);
        },
        dataRemovedBottom: function(grid, scrollUp, scrollDown) {
          service.setScrollDirections(grid, scrollUp, scrollDown);
          var newVisibleRows = grid.renderContainers.body.visibleRowCache.length;
          var oldScrollRow = grid.infiniteScroll.prevScrolltopPercentage * grid.infiniteScroll.previousVisibleRows;
          var newScrollPercent = oldScrollRow / newVisibleRows;
          return service.adjustInfiniteScrollPosition(grid, newScrollPercent);
        }
      };
      return service;
    }]);
    module.directive('uiGridInfiniteScroll', ['uiGridInfiniteScrollService', function(uiGridInfiniteScrollService) {
      return {
        priority: -200,
        scope: false,
        require: '^uiGrid',
        compile: function($scope, $elm, $attr) {
          return {
            pre: function($scope, $elm, $attr, uiGridCtrl) {
              uiGridInfiniteScrollService.initializeGrid(uiGridCtrl.grid, $scope);
            },
            post: function($scope, $elm, $attr) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.moveColumns', ['ui.grid']);
    module.service('uiGridMoveColumnService', ['$q', '$timeout', '$log', 'ScrollEvent', 'uiGridConstants', 'gridUtil', function($q, $timeout, $log, ScrollEvent, uiGridConstants, gridUtil) {
      var service = {
        initializeGrid: function(grid) {
          var self = this;
          this.registerPublicApi(grid);
          this.defaultGridOptions(grid.options);
          grid.registerColumnBuilder(self.movableColumnBuilder);
        },
        registerPublicApi: function(grid) {
          var self = this;
          var publicApi = {
            events: {colMovable: {columnPositionChanged: function(colDef, originalPosition, newPosition) {}}},
            methods: {colMovable: {moveColumn: function(originalPosition, finalPosition) {
                  var columns = grid.columns;
                  if (!angular.isNumber(originalPosition) || !angular.isNumber(finalPosition)) {
                    gridUtil.logError('MoveColumn: Please provide valid values for originalPosition and finalPosition');
                    return ;
                  }
                  var nonMovableColumns = 0;
                  for (var i = 0; i < columns.length; i++) {
                    if ((angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false) || columns[i].isRowHeader === true) {
                      nonMovableColumns++;
                    }
                  }
                  if (originalPosition >= (columns.length - nonMovableColumns) || finalPosition >= (columns.length - nonMovableColumns)) {
                    gridUtil.logError('MoveColumn: Invalid values for originalPosition, finalPosition');
                    return ;
                  }
                  var findPositionForRenderIndex = function(index) {
                    var position = index;
                    for (var i = 0; i <= position; i++) {
                      if (angular.isDefined(columns[i]) && ((angular.isDefined(columns[i].colDef.visible) && columns[i].colDef.visible === false) || columns[i].isRowHeader === true)) {
                        position++;
                      }
                    }
                    return position;
                  };
                  self.redrawColumnAtPosition(grid, findPositionForRenderIndex(originalPosition), findPositionForRenderIndex(finalPosition));
                }}}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableColumnMoving = gridOptions.enableColumnMoving !== false;
        },
        movableColumnBuilder: function(colDef, col, gridOptions) {
          var promises = [];
          colDef.enableColumnMoving = colDef.enableColumnMoving === undefined ? gridOptions.enableColumnMoving : colDef.enableColumnMoving;
          return $q.all(promises);
        },
        redrawColumnAtPosition: function(grid, originalPosition, newPosition) {
          var columns = grid.columns;
          var originalColumn = columns[originalPosition];
          if (originalColumn.colDef.enableColumnMoving) {
            if (originalPosition > newPosition) {
              for (var i1 = originalPosition; i1 > newPosition; i1--) {
                columns[i1] = columns[i1 - 1];
              }
            } else if (newPosition > originalPosition) {
              for (var i2 = originalPosition; i2 < newPosition; i2++) {
                columns[i2] = columns[i2 + 1];
              }
            }
            columns[newPosition] = originalColumn;
            grid.queueGridRefresh();
            $timeout(function() {
              grid.api.core.notifyDataChange(uiGridConstants.dataChange.COLUMN);
              grid.api.colMovable.raise.columnPositionChanged(originalColumn.colDef, originalPosition, newPosition);
            });
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridMoveColumns', ['uiGridMoveColumnService', function(uiGridMoveColumnService) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridMoveColumnService.initializeGrid(uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridHeaderCell', ['$q', 'gridUtil', 'uiGridMoveColumnService', '$document', '$log', 'uiGridConstants', 'ScrollEvent', function($q, gridUtil, uiGridMoveColumnService, $document, $log, uiGridConstants, ScrollEvent) {
      return {
        priority: -10,
        require: '^uiGrid',
        compile: function() {
          return {post: function($scope, $elm, $attrs, uiGridCtrl) {
              if ($scope.col.colDef.enableColumnMoving) {
                var $contentsElm = angular.element($elm[0].querySelectorAll('.ui-grid-cell-contents'));
                var gridLeft;
                var previousMouseX;
                var totalMouseMovement;
                var rightMoveLimit;
                var elmCloned = false;
                var movingElm;
                var reducedWidth;
                var moveOccurred = false;
                var downFn = function(event) {
                  gridLeft = $scope.grid.element[0].getBoundingClientRect().left;
                  if ($scope.grid.hasLeftContainer()) {
                    gridLeft += $scope.grid.renderContainers.left.header[0].getBoundingClientRect().width;
                  }
                  previousMouseX = event.pageX;
                  totalMouseMovement = 0;
                  rightMoveLimit = gridLeft + $scope.grid.getViewportWidth();
                  if (event.type === 'mousedown') {
                    $document.on('mousemove', moveFn);
                    $document.on('mouseup', upFn);
                  } else if (event.type === 'touchstart') {
                    $document.on('touchmove', moveFn);
                    $document.on('touchend', upFn);
                  }
                };
                var moveFn = function(event) {
                  var changeValue = event.pageX - previousMouseX;
                  if (changeValue === 0) {
                    return ;
                  }
                  document.onselectstart = function() {
                    return false;
                  };
                  moveOccurred = true;
                  if (!elmCloned) {
                    cloneElement();
                  } else if (elmCloned) {
                    moveElement(changeValue);
                    previousMouseX = event.pageX;
                  }
                };
                var upFn = function(event) {
                  document.onselectstart = null;
                  if (movingElm) {
                    movingElm.remove();
                    elmCloned = false;
                  }
                  offAllEvents();
                  onDownEvents();
                  if (!moveOccurred) {
                    return ;
                  }
                  var columns = $scope.grid.columns;
                  var columnIndex = 0;
                  for (var i = 0; i < columns.length; i++) {
                    if (columns[i].colDef.name !== $scope.col.colDef.name) {
                      columnIndex++;
                    } else {
                      break;
                    }
                  }
                  if (totalMouseMovement < 0) {
                    var totalColumnsLeftWidth = 0;
                    for (var il = columnIndex - 1; il >= 0; il--) {
                      if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                        totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                        if (totalColumnsLeftWidth > Math.abs(totalMouseMovement)) {
                          uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, il + 1);
                          break;
                        }
                      }
                    }
                    if (totalColumnsLeftWidth < Math.abs(totalMouseMovement)) {
                      uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, 0);
                    }
                  } else if (totalMouseMovement > 0) {
                    var totalColumnsRightWidth = 0;
                    for (var ir = columnIndex + 1; ir < columns.length; ir++) {
                      if (angular.isUndefined(columns[ir].colDef.visible) || columns[ir].colDef.visible === true) {
                        totalColumnsRightWidth += columns[ir].drawnWidth || columns[ir].width || columns[ir].colDef.width;
                        if (totalColumnsRightWidth > totalMouseMovement) {
                          uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, ir - 1);
                          break;
                        }
                      }
                    }
                    if (totalColumnsRightWidth < totalMouseMovement) {
                      uiGridMoveColumnService.redrawColumnAtPosition($scope.grid, columnIndex, columns.length - 1);
                    }
                  }
                };
                var onDownEvents = function() {
                  $contentsElm.on('touchstart', downFn);
                  $contentsElm.on('mousedown', downFn);
                };
                var offAllEvents = function() {
                  $contentsElm.off('touchstart', downFn);
                  $contentsElm.off('mousedown', downFn);
                  $document.off('mousemove', moveFn);
                  $document.off('touchmove', moveFn);
                  $document.off('mouseup', upFn);
                  $document.off('touchend', upFn);
                };
                onDownEvents();
                var cloneElement = function() {
                  elmCloned = true;
                  movingElm = $elm.clone();
                  $elm.parent().append(movingElm);
                  movingElm.addClass('movingColumn');
                  var movingElementStyles = {};
                  var elmLeft;
                  if (gridUtil.detectBrowser() === 'safari') {
                    elmLeft = $elm[0].offsetLeft + $elm[0].offsetWidth - $elm[0].getBoundingClientRect().width;
                  } else {
                    elmLeft = $elm[0].getBoundingClientRect().left;
                  }
                  movingElementStyles.left = (elmLeft - gridLeft) + 'px';
                  var gridRight = $scope.grid.element[0].getBoundingClientRect().right;
                  var elmRight = $elm[0].getBoundingClientRect().right;
                  if (elmRight > gridRight) {
                    reducedWidth = $scope.col.drawnWidth + (gridRight - elmRight);
                    movingElementStyles.width = reducedWidth + 'px';
                  }
                  movingElm.css(movingElementStyles);
                };
                var moveElement = function(changeValue) {
                  var columns = $scope.grid.columns;
                  var totalColumnWidth = 0;
                  for (var i = 0; i < columns.length; i++) {
                    if (angular.isUndefined(columns[i].colDef.visible) || columns[i].colDef.visible === true) {
                      totalColumnWidth += columns[i].drawnWidth || columns[i].width || columns[i].colDef.width;
                    }
                  }
                  var currentElmLeft = movingElm[0].getBoundingClientRect().left - 1;
                  var currentElmRight = movingElm[0].getBoundingClientRect().right;
                  var newElementLeft;
                  newElementLeft = currentElmLeft - gridLeft + changeValue;
                  newElementLeft = newElementLeft < rightMoveLimit ? newElementLeft : rightMoveLimit;
                  if ((currentElmLeft >= gridLeft || changeValue > 0) && (currentElmRight <= rightMoveLimit || changeValue < 0)) {
                    movingElm.css({
                      visibility: 'visible',
                      'left': newElementLeft + 'px'
                    });
                  } else if (totalColumnWidth > Math.ceil(uiGridCtrl.grid.gridWidth)) {
                    changeValue *= 8;
                    var scrollEvent = new ScrollEvent($scope.col.grid, null, null, 'uiGridHeaderCell.moveElement');
                    scrollEvent.x = {pixels: changeValue};
                    scrollEvent.grid.scrollContainers('', scrollEvent);
                  }
                  var totalColumnsLeftWidth = 0;
                  for (var il = 0; il < columns.length; il++) {
                    if (angular.isUndefined(columns[il].colDef.visible) || columns[il].colDef.visible === true) {
                      if (columns[il].colDef.name !== $scope.col.colDef.name) {
                        totalColumnsLeftWidth += columns[il].drawnWidth || columns[il].width || columns[il].colDef.width;
                      } else {
                        break;
                      }
                    }
                  }
                  if ($scope.newScrollLeft === undefined) {
                    totalMouseMovement += changeValue;
                  } else {
                    totalMouseMovement = $scope.newScrollLeft + newElementLeft - totalColumnsLeftWidth;
                  }
                  if (reducedWidth < $scope.col.drawnWidth) {
                    reducedWidth += Math.abs(changeValue);
                    movingElm.css({'width': reducedWidth + 'px'});
                  }
                };
              }
            }};
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.pagination', ['ng', 'ui.grid']);
    module.service('uiGridPaginationService', ['gridUtil', function(gridUtil) {
      var service = {
        initializeGrid: function(grid) {
          service.defaultGridOptions(grid.options);
          var publicApi = {
            events: {pagination: {paginationChanged: function(currentPage, pageSize) {}}},
            methods: {pagination: {
                getPage: function() {
                  return grid.options.enablePagination ? grid.options.paginationCurrentPage : null;
                },
                getTotalPages: function() {
                  if (!grid.options.enablePagination) {
                    return null;
                  }
                  return (grid.options.totalItems === 0) ? 1 : Math.ceil(grid.options.totalItems / grid.options.paginationPageSize);
                },
                nextPage: function() {
                  if (!grid.options.enablePagination) {
                    return ;
                  }
                  if (grid.options.totalItems > 0) {
                    grid.options.paginationCurrentPage = Math.min(grid.options.paginationCurrentPage + 1, publicApi.methods.pagination.getTotalPages());
                  } else {
                    grid.options.paginationCurrentPage++;
                  }
                },
                previousPage: function() {
                  if (!grid.options.enablePagination) {
                    return ;
                  }
                  grid.options.paginationCurrentPage = Math.max(grid.options.paginationCurrentPage - 1, 1);
                },
                seek: function(page) {
                  if (!grid.options.enablePagination) {
                    return ;
                  }
                  if (!angular.isNumber(page) || page < 1) {
                    throw 'Invalid page number: ' + page;
                  }
                  grid.options.paginationCurrentPage = Math.min(page, publicApi.methods.pagination.getTotalPages());
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
          var processPagination = function(renderableRows) {
            if (grid.options.useExternalPagination || !grid.options.enablePagination) {
              return renderableRows;
            }
            var pageSize = parseInt(grid.options.paginationPageSize, 10);
            var currentPage = parseInt(grid.options.paginationCurrentPage, 10);
            var visibleRows = renderableRows.filter(function(row) {
              return row.visible;
            });
            grid.options.totalItems = visibleRows.length;
            var firstRow = (currentPage - 1) * pageSize;
            if (firstRow > visibleRows.length) {
              currentPage = grid.options.paginationCurrentPage = 1;
              firstRow = (currentPage - 1) * pageSize;
            }
            return visibleRows.slice(firstRow, firstRow + pageSize);
          };
          grid.registerRowsProcessor(processPagination, 900);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enablePagination = gridOptions.enablePagination !== false;
          gridOptions.enablePaginationControls = gridOptions.enablePaginationControls !== false;
          gridOptions.useExternalPagination = gridOptions.useExternalPagination === true;
          if (gridUtil.isNullOrUndefined(gridOptions.totalItems)) {
            gridOptions.totalItems = 0;
          }
          if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSizes)) {
            gridOptions.paginationPageSizes = [250, 500, 1000];
          }
          if (gridUtil.isNullOrUndefined(gridOptions.paginationPageSize)) {
            if (gridOptions.paginationPageSizes.length > 0) {
              gridOptions.paginationPageSize = gridOptions.paginationPageSizes[0];
            } else {
              gridOptions.paginationPageSize = 0;
            }
          }
          if (gridUtil.isNullOrUndefined(gridOptions.paginationCurrentPage)) {
            gridOptions.paginationCurrentPage = 1;
          }
          if (gridUtil.isNullOrUndefined(gridOptions.paginationTemplate)) {
            gridOptions.paginationTemplate = 'ui-grid/pagination';
          }
        },
        onPaginationChanged: function(grid, currentPage, pageSize) {
          grid.api.pagination.raise.paginationChanged(currentPage, pageSize);
          if (!grid.options.useExternalPagination) {
            grid.queueGridRefresh();
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridPagination', ['gridUtil', 'uiGridPaginationService', function(gridUtil, uiGridPaginationService) {
      return {
        priority: -200,
        scope: false,
        require: 'uiGrid',
        link: {pre: function($scope, $elm, $attr, uiGridCtrl) {
            uiGridPaginationService.initializeGrid(uiGridCtrl.grid);
            gridUtil.getTemplate(uiGridCtrl.grid.options.paginationTemplate).then(function(contents) {
              var template = angular.element(contents);
              $elm.append(template);
              uiGridCtrl.innerCompile(template);
            });
          }}
      };
    }]);
    module.directive('uiGridPager', ['uiGridPaginationService', 'uiGridConstants', 'gridUtil', 'i18nService', function(uiGridPaginationService, uiGridConstants, gridUtil, i18nService) {
      return {
        priority: -200,
        scope: true,
        require: '^uiGrid',
        link: function($scope, $elm, $attr, uiGridCtrl) {
          var defaultFocusElementSelector = '.ui-grid-pager-control-input';
          $scope.aria = i18nService.getSafeText('pagination.aria');
          $scope.paginationApi = uiGridCtrl.grid.api.pagination;
          $scope.sizesLabel = i18nService.getSafeText('pagination.sizes');
          $scope.totalItemsLabel = i18nService.getSafeText('pagination.totalItems');
          $scope.paginationOf = i18nService.getSafeText('pagination.of');
          $scope.paginationThrough = i18nService.getSafeText('pagination.through');
          var options = uiGridCtrl.grid.options;
          uiGridCtrl.grid.renderContainers.body.registerViewportAdjuster(function(adjustment) {
            adjustment.height = adjustment.height - gridUtil.elementHeight($elm);
            return adjustment;
          });
          var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(function(grid) {
            if (!grid.options.useExternalPagination) {
              grid.options.totalItems = grid.rows.length;
            }
          }, [uiGridConstants.dataChange.ROW]);
          $scope.$on('$destroy', dataChangeDereg);
          var setShowing = function() {
            $scope.showingLow = ((options.paginationCurrentPage - 1) * options.paginationPageSize) + 1;
            $scope.showingHigh = Math.min(options.paginationCurrentPage * options.paginationPageSize, options.totalItems);
          };
          var deregT = $scope.$watch('grid.options.totalItems + grid.options.paginationPageSize', setShowing);
          var deregP = $scope.$watch('grid.options.paginationCurrentPage + grid.options.paginationPageSize', function(newValues, oldValues) {
            if (newValues === oldValues || oldValues === undefined) {
              return ;
            }
            if (!angular.isNumber(options.paginationCurrentPage) || options.paginationCurrentPage < 1) {
              options.paginationCurrentPage = 1;
              return ;
            }
            if (options.totalItems > 0 && options.paginationCurrentPage > $scope.paginationApi.getTotalPages()) {
              options.paginationCurrentPage = $scope.paginationApi.getTotalPages();
              return ;
            }
            setShowing();
            uiGridPaginationService.onPaginationChanged($scope.grid, options.paginationCurrentPage, options.paginationPageSize);
          });
          $scope.$on('$destroy', function() {
            deregT();
            deregP();
          });
          $scope.cantPageForward = function() {
            if (options.totalItems > 0) {
              return options.paginationCurrentPage >= $scope.paginationApi.getTotalPages();
            } else {
              return options.data.length < 1;
            }
          };
          $scope.cantPageToLast = function() {
            if (options.totalItems > 0) {
              return $scope.cantPageForward();
            } else {
              return true;
            }
          };
          $scope.cantPageBackward = function() {
            return options.paginationCurrentPage <= 1;
          };
          var focusToInputIf = function(condition) {
            if (condition) {
              gridUtil.focus.bySelector($elm, defaultFocusElementSelector);
            }
          };
          $scope.pageFirstPageClick = function() {
            $scope.paginationApi.seek(1);
            focusToInputIf($scope.cantPageBackward());
          };
          $scope.pagePreviousPageClick = function() {
            $scope.paginationApi.previousPage();
            focusToInputIf($scope.cantPageBackward());
          };
          $scope.pageNextPageClick = function() {
            $scope.paginationApi.nextPage();
            focusToInputIf($scope.cantPageForward());
          };
          $scope.pageLastPageClick = function() {
            $scope.paginationApi.seek($scope.paginationApi.getTotalPages());
            focusToInputIf($scope.cantPageToLast());
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.pinning', ['ui.grid']);
    module.constant('uiGridPinningConstants', {container: {
        LEFT: 'left',
        RIGHT: 'right',
        NONE: ''
      }});
    module.service('uiGridPinningService', ['gridUtil', 'GridRenderContainer', 'i18nService', 'uiGridPinningConstants', function(gridUtil, GridRenderContainer, i18nService, uiGridPinningConstants) {
      var service = {
        initializeGrid: function(grid) {
          service.defaultGridOptions(grid.options);
          grid.registerColumnBuilder(service.pinningColumnBuilder);
          var publicApi = {
            events: {pinning: {columnPinned: function(colDef, container) {}}},
            methods: {pinning: {pinColumn: function(col, container) {
                  service.pinColumn(grid, col, container);
                }}}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enablePinning = gridOptions.enablePinning !== false;
        },
        pinningColumnBuilder: function(colDef, col, gridOptions) {
          colDef.enablePinning = colDef.enablePinning === undefined ? gridOptions.enablePinning : colDef.enablePinning;
          if (colDef.pinnedLeft) {
            col.renderContainer = 'left';
            col.grid.createLeftContainer();
          } else if (colDef.pinnedRight) {
            col.renderContainer = 'right';
            col.grid.createRightContainer();
          }
          if (!colDef.enablePinning) {
            return ;
          }
          var pinColumnLeftAction = {
            name: 'ui.grid.pinning.pinLeft',
            title: i18nService.get().pinning.pinLeft,
            icon: 'ui-grid-icon-left-open',
            shown: function() {
              return typeof(this.context.col.renderContainer) === 'undefined' || !this.context.col.renderContainer || this.context.col.renderContainer !== 'left';
            },
            action: function() {
              service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.LEFT);
            }
          };
          var pinColumnRightAction = {
            name: 'ui.grid.pinning.pinRight',
            title: i18nService.get().pinning.pinRight,
            icon: 'ui-grid-icon-right-open',
            shown: function() {
              return typeof(this.context.col.renderContainer) === 'undefined' || !this.context.col.renderContainer || this.context.col.renderContainer !== 'right';
            },
            action: function() {
              service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.RIGHT);
            }
          };
          var removePinAction = {
            name: 'ui.grid.pinning.unpin',
            title: i18nService.get().pinning.unpin,
            icon: 'ui-grid-icon-cancel',
            shown: function() {
              return typeof(this.context.col.renderContainer) !== 'undefined' && this.context.col.renderContainer !== null && this.context.col.renderContainer !== 'body';
            },
            action: function() {
              service.pinColumn(this.context.col.grid, this.context.col, uiGridPinningConstants.container.UNPIN);
            }
          };
          if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.pinning.pinLeft')) {
            col.menuItems.push(pinColumnLeftAction);
          }
          if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.pinning.pinRight')) {
            col.menuItems.push(pinColumnRightAction);
          }
          if (!gridUtil.arrayContainsObjectWithProperty(col.menuItems, 'name', 'ui.grid.pinning.unpin')) {
            col.menuItems.push(removePinAction);
          }
        },
        pinColumn: function(grid, col, container) {
          if (container === uiGridPinningConstants.container.NONE) {
            col.renderContainer = null;
          } else {
            col.renderContainer = container;
            if (container === uiGridPinningConstants.container.LEFT) {
              grid.createLeftContainer();
            } else if (container === uiGridPinningConstants.container.RIGHT) {
              grid.createRightContainer();
            }
          }
          grid.refresh().then(function() {
            grid.api.pinning.raise.columnPinned(col.colDef, container);
          });
        }
      };
      return service;
    }]);
    module.directive('uiGridPinning', ['gridUtil', 'uiGridPinningService', function(gridUtil, uiGridPinningService) {
      return {
        require: 'uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridPinningService.initializeGrid(uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.resizeColumns', ['ui.grid']);
    module.service('uiGridResizeColumnsService', ['gridUtil', '$q', '$timeout', function(gridUtil, $q, $timeout) {
      var service = {
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableColumnResizing = gridOptions.enableColumnResizing !== false;
          if (gridOptions.enableColumnResize === false) {
            gridOptions.enableColumnResizing = false;
          }
        },
        colResizerColumnBuilder: function(colDef, col, gridOptions) {
          var promises = [];
          colDef.enableColumnResizing = colDef.enableColumnResizing === undefined ? gridOptions.enableColumnResizing : colDef.enableColumnResizing;
          if (colDef.enableColumnResize === false) {
            colDef.enableColumnResizing = false;
          }
          return $q.all(promises);
        },
        registerPublicApi: function(grid) {
          var publicApi = {events: {colResizable: {columnSizeChanged: function(colDef, deltaChange) {}}}};
          grid.api.registerEventsFromObject(publicApi.events);
        },
        fireColumnSizeChanged: function(grid, colDef, deltaChange) {
          $timeout(function() {
            if (grid.api.colResizable) {
              grid.api.colResizable.raise.columnSizeChanged(colDef, deltaChange);
            } else {
              gridUtil.logError("The resizeable api is not registered, this may indicate that you've included the module but not added the 'ui-grid-resize-columns' directive to your grid definition.  Cannot raise any events.");
            }
          });
        },
        findTargetCol: function(col, position, rtlMultiplier) {
          var renderContainer = col.getRenderContainer();
          if (position === 'left') {
            var colIndex = renderContainer.visibleColumnCache.indexOf(col);
            return renderContainer.visibleColumnCache[colIndex - 1 * rtlMultiplier];
          } else {
            return col;
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridResizeColumns', ['gridUtil', 'uiGridResizeColumnsService', function(gridUtil, uiGridResizeColumnsService) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridResizeColumnsService.defaultGridOptions(uiGridCtrl.grid.options);
              uiGridCtrl.grid.registerColumnBuilder(uiGridResizeColumnsService.colResizerColumnBuilder);
              uiGridResizeColumnsService.registerPublicApi(uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridHeaderCell', ['gridUtil', '$templateCache', '$compile', '$q', 'uiGridResizeColumnsService', 'uiGridConstants', '$timeout', function(gridUtil, $templateCache, $compile, $q, uiGridResizeColumnsService, uiGridConstants, $timeout) {
      return {
        priority: -10,
        require: '^uiGrid',
        compile: function() {
          return {post: function($scope, $elm, $attrs, uiGridCtrl) {
              var grid = uiGridCtrl.grid;
              if (grid.options.enableColumnResizing) {
                var columnResizerElm = $templateCache.get('ui-grid/columnResizer');
                var rtlMultiplier = 1;
                if (grid.isRTL()) {
                  $scope.position = 'left';
                  rtlMultiplier = -1;
                }
                var displayResizers = function() {
                  var resizers = $elm[0].getElementsByClassName('ui-grid-column-resizer');
                  for (var i = 0; i < resizers.length; i++) {
                    angular.element(resizers[i]).remove();
                  }
                  var otherCol = uiGridResizeColumnsService.findTargetCol($scope.col, 'left', rtlMultiplier);
                  var renderContainer = $scope.col.getRenderContainer();
                  if (otherCol && renderContainer.visibleColumnCache.indexOf($scope.col) !== 0 && otherCol.colDef.enableColumnResizing !== false) {
                    var resizerLeft = angular.element(columnResizerElm).clone();
                    resizerLeft.attr('position', 'left');
                    $elm.prepend(resizerLeft);
                    $compile(resizerLeft)($scope);
                  }
                  if ($scope.col.colDef.enableColumnResizing !== false) {
                    var resizerRight = angular.element(columnResizerElm).clone();
                    resizerRight.attr('position', 'right');
                    $elm.append(resizerRight);
                    $compile(resizerRight)($scope);
                  }
                };
                displayResizers();
                var waitDisplay = function() {
                  $timeout(displayResizers);
                };
                var dataChangeDereg = grid.registerDataChangeCallback(waitDisplay, [uiGridConstants.dataChange.COLUMN]);
                $scope.$on('$destroy', dataChangeDereg);
              }
            }};
        }
      };
    }]);
    module.directive('uiGridColumnResizer', ['$document', 'gridUtil', 'uiGridConstants', 'uiGridResizeColumnsService', function($document, gridUtil, uiGridConstants, uiGridResizeColumnsService) {
      var resizeOverlay = angular.element('<div class="ui-grid-resize-overlay"></div>');
      var resizer = {
        priority: 0,
        scope: {
          col: '=',
          position: '@',
          renderIndex: '='
        },
        require: '?^uiGrid',
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var startX = 0,
              x = 0,
              gridLeft = 0,
              rtlMultiplier = 1;
          if (uiGridCtrl.grid.isRTL()) {
            $scope.position = 'left';
            rtlMultiplier = -1;
          }
          if ($scope.position === 'left') {
            $elm.addClass('left');
          } else if ($scope.position === 'right') {
            $elm.addClass('right');
          }
          function refreshCanvas(xDiff) {
            uiGridCtrl.grid.refreshCanvas(true).then(function() {
              uiGridCtrl.grid.queueGridRefresh();
            });
          }
          function constrainWidth(col, width) {
            var newWidth = width;
            if (col.minWidth && newWidth < col.minWidth) {
              newWidth = col.minWidth;
            } else if (col.maxWidth && newWidth > col.maxWidth) {
              newWidth = col.maxWidth;
            }
            return newWidth;
          }
          function moveFunction(event, args) {
            if (event.originalEvent) {
              event = event.originalEvent;
            }
            event.preventDefault();
            x = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
            if (x < 0) {
              x = 0;
            } else if (x > uiGridCtrl.grid.gridWidth) {
              x = uiGridCtrl.grid.gridWidth;
            }
            var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
            if (col.colDef.enableColumnResizing === false) {
              return ;
            }
            if (!uiGridCtrl.grid.element.hasClass('column-resizing')) {
              uiGridCtrl.grid.element.addClass('column-resizing');
            }
            var xDiff = x - startX;
            var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
            x = x + (constrainWidth(col, newWidth) - newWidth) * rtlMultiplier;
            resizeOverlay.css({left: x + 'px'});
            uiGridCtrl.fireEvent(uiGridConstants.events.ITEM_DRAGGING);
          }
          function upFunction(event, args) {
            if (event.originalEvent) {
              event = event.originalEvent;
            }
            event.preventDefault();
            uiGridCtrl.grid.element.removeClass('column-resizing');
            resizeOverlay.remove();
            x = (event.changedTouches ? event.changedTouches[0] : event).clientX - gridLeft;
            var xDiff = x - startX;
            if (xDiff === 0) {
              offAllEvents();
              onDownEvents();
              return ;
            }
            var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
            if (col.colDef.enableColumnResizing === false) {
              return ;
            }
            var newWidth = parseInt(col.drawnWidth + xDiff * rtlMultiplier, 10);
            col.width = constrainWidth(col, newWidth);
            col.hasCustomWidth = true;
            refreshCanvas(xDiff);
            uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
            offAllEvents();
            onDownEvents();
          }
          var downFunction = function(event, args) {
            if (event.originalEvent) {
              event = event.originalEvent;
            }
            event.stopPropagation();
            gridLeft = uiGridCtrl.grid.element[0].getBoundingClientRect().left;
            startX = (event.targetTouches ? event.targetTouches[0] : event).clientX - gridLeft;
            uiGridCtrl.grid.element.append(resizeOverlay);
            resizeOverlay.css({left: startX});
            if (event.type === 'touchstart') {
              $document.on('touchend', upFunction);
              $document.on('touchmove', moveFunction);
              $elm.off('mousedown', downFunction);
            } else {
              $document.on('mouseup', upFunction);
              $document.on('mousemove', moveFunction);
              $elm.off('touchstart', downFunction);
            }
          };
          var onDownEvents = function() {
            $elm.on('mousedown', downFunction);
            $elm.on('touchstart', downFunction);
          };
          var offAllEvents = function() {
            $document.off('mouseup', upFunction);
            $document.off('touchend', upFunction);
            $document.off('mousemove', moveFunction);
            $document.off('touchmove', moveFunction);
            $elm.off('mousedown', downFunction);
            $elm.off('touchstart', downFunction);
          };
          onDownEvents();
          var dblClickFn = function(event, args) {
            event.stopPropagation();
            var col = uiGridResizeColumnsService.findTargetCol($scope.col, $scope.position, rtlMultiplier);
            if (col.colDef.enableColumnResizing === false) {
              return ;
            }
            var maxWidth = 0;
            var xDiff = 0;
            var renderContainerElm = gridUtil.closestElm($elm, '.ui-grid-render-container');
            var cells = renderContainerElm.querySelectorAll('.' + uiGridConstants.COL_CLASS_PREFIX + col.uid + ' .ui-grid-cell-contents');
            Array.prototype.forEach.call(cells, function(cell) {
              var menuButton;
              if (angular.element(cell).parent().hasClass('ui-grid-header-cell')) {
                menuButton = angular.element(cell).parent()[0].querySelectorAll('.ui-grid-column-menu-button');
              }
              gridUtil.fakeElement(cell, {}, function(newElm) {
                var e = angular.element(newElm);
                e.attr('style', 'float: left');
                var width = gridUtil.elementWidth(e);
                if (menuButton) {
                  var menuButtonWidth = gridUtil.elementWidth(menuButton);
                  width = width + menuButtonWidth;
                }
                if (width > maxWidth) {
                  maxWidth = width;
                  xDiff = maxWidth - width;
                }
              });
            });
            col.width = constrainWidth(col, maxWidth);
            col.hasCustomWidth = true;
            refreshCanvas(xDiff);
            uiGridResizeColumnsService.fireColumnSizeChanged(uiGridCtrl.grid, col.colDef, xDiff);
          };
          $elm.on('dblclick', dblClickFn);
          $elm.on('$destroy', function() {
            $elm.off('dblclick', dblClickFn);
            offAllEvents();
          });
        }
      };
      return resizer;
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.rowEdit', ['ui.grid', 'ui.grid.edit', 'ui.grid.cellNav']);
    module.constant('uiGridRowEditConstants', {});
    module.service('uiGridRowEditService', ['$interval', '$q', 'uiGridConstants', 'uiGridRowEditConstants', 'gridUtil', function($interval, $q, uiGridConstants, uiGridRowEditConstants, gridUtil) {
      var service = {
        initializeGrid: function(scope, grid) {
          grid.rowEdit = {};
          var publicApi = {
            events: {rowEdit: {saveRow: function(rowEntity) {}}},
            methods: {rowEdit: {
                setSavePromise: function(rowEntity, savePromise) {
                  service.setSavePromise(grid, rowEntity, savePromise);
                },
                getDirtyRows: function() {
                  return grid.rowEdit.dirtyRows ? grid.rowEdit.dirtyRows : [];
                },
                getErrorRows: function() {
                  return grid.rowEdit.errorRows ? grid.rowEdit.errorRows : [];
                },
                flushDirtyRows: function() {
                  return service.flushDirtyRows(grid);
                },
                setRowsDirty: function(dataRows) {
                  service.setRowsDirty(grid, dataRows);
                },
                setRowsClean: function(dataRows) {
                  service.setRowsClean(grid, dataRows);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
          grid.api.core.on.renderingComplete(scope, function(gridApi) {
            grid.api.edit.on.afterCellEdit(scope, service.endEditCell);
            grid.api.edit.on.beginCellEdit(scope, service.beginEditCell);
            grid.api.edit.on.cancelCellEdit(scope, service.cancelEditCell);
            if (grid.api.cellNav) {
              grid.api.cellNav.on.navigate(scope, service.navigate);
            }
          });
        },
        defaultGridOptions: function(gridOptions) {},
        saveRow: function(grid, gridRow) {
          var self = this;
          return function() {
            gridRow.isSaving = true;
            if (gridRow.rowEditSavePromise) {
              return gridRow.rowEditSavePromise;
            }
            var promise = grid.api.rowEdit.raise.saveRow(gridRow.entity);
            if (gridRow.rowEditSavePromise) {
              gridRow.rowEditSavePromise.then(self.processSuccessPromise(grid, gridRow), self.processErrorPromise(grid, gridRow));
            } else {
              gridUtil.logError('A promise was not returned when saveRow event was raised, either nobody is listening to event, or event handler did not return a promise');
            }
            return promise;
          };
        },
        setSavePromise: function(grid, rowEntity, savePromise) {
          var gridRow = grid.getRow(rowEntity);
          gridRow.rowEditSavePromise = savePromise;
        },
        processSuccessPromise: function(grid, gridRow) {
          var self = this;
          return function() {
            delete gridRow.isSaving;
            delete gridRow.isDirty;
            delete gridRow.isError;
            delete gridRow.rowEditSaveTimer;
            delete gridRow.rowEditSavePromise;
            self.removeRow(grid.rowEdit.errorRows, gridRow);
            self.removeRow(grid.rowEdit.dirtyRows, gridRow);
          };
        },
        processErrorPromise: function(grid, gridRow) {
          return function() {
            delete gridRow.isSaving;
            delete gridRow.rowEditSaveTimer;
            delete gridRow.rowEditSavePromise;
            gridRow.isError = true;
            if (!grid.rowEdit.errorRows) {
              grid.rowEdit.errorRows = [];
            }
            if (!service.isRowPresent(grid.rowEdit.errorRows, gridRow)) {
              grid.rowEdit.errorRows.push(gridRow);
            }
          };
        },
        removeRow: function(rowArray, removeGridRow) {
          if (typeof(rowArray) === 'undefined' || rowArray === null) {
            return ;
          }
          rowArray.forEach(function(gridRow, index) {
            if (gridRow.uid === removeGridRow.uid) {
              rowArray.splice(index, 1);
            }
          });
        },
        isRowPresent: function(rowArray, removeGridRow) {
          var present = false;
          rowArray.forEach(function(gridRow, index) {
            if (gridRow.uid === removeGridRow.uid) {
              present = true;
            }
          });
          return present;
        },
        flushDirtyRows: function(grid) {
          var promises = [];
          grid.api.rowEdit.getDirtyRows().forEach(function(gridRow) {
            service.saveRow(grid, gridRow)();
            promises.push(gridRow.rowEditSavePromise);
          });
          return $q.all(promises);
        },
        endEditCell: function(rowEntity, colDef, newValue, previousValue) {
          var grid = this.grid;
          var gridRow = grid.getRow(rowEntity);
          if (!gridRow) {
            gridUtil.logError('Unable to find rowEntity in grid data, dirty flag cannot be set');
            return ;
          }
          if (newValue !== previousValue || gridRow.isDirty) {
            if (!grid.rowEdit.dirtyRows) {
              grid.rowEdit.dirtyRows = [];
            }
            if (!gridRow.isDirty) {
              gridRow.isDirty = true;
              grid.rowEdit.dirtyRows.push(gridRow);
            }
            delete gridRow.isError;
            service.considerSetTimer(grid, gridRow);
          }
        },
        beginEditCell: function(rowEntity, colDef) {
          var grid = this.grid;
          var gridRow = grid.getRow(rowEntity);
          if (!gridRow) {
            gridUtil.logError('Unable to find rowEntity in grid data, timer cannot be cancelled');
            return ;
          }
          service.cancelTimer(grid, gridRow);
        },
        cancelEditCell: function(rowEntity, colDef) {
          var grid = this.grid;
          var gridRow = grid.getRow(rowEntity);
          if (!gridRow) {
            gridUtil.logError('Unable to find rowEntity in grid data, timer cannot be set');
            return ;
          }
          service.considerSetTimer(grid, gridRow);
        },
        navigate: function(newRowCol, oldRowCol) {
          var grid = this.grid;
          if (newRowCol.row.rowEditSaveTimer) {
            service.cancelTimer(grid, newRowCol.row);
          }
          if (oldRowCol && oldRowCol.row && oldRowCol.row !== newRowCol.row) {
            service.considerSetTimer(grid, oldRowCol.row);
          }
        },
        considerSetTimer: function(grid, gridRow) {
          service.cancelTimer(grid, gridRow);
          if (gridRow.isDirty && !gridRow.isSaving) {
            if (grid.options.rowEditWaitInterval !== -1) {
              var waitTime = grid.options.rowEditWaitInterval ? grid.options.rowEditWaitInterval : 2000;
              gridRow.rowEditSaveTimer = $interval(service.saveRow(grid, gridRow), waitTime, 1);
            }
          }
        },
        cancelTimer: function(grid, gridRow) {
          if (gridRow.rowEditSaveTimer && !gridRow.isSaving) {
            $interval.cancel(gridRow.rowEditSaveTimer);
            delete gridRow.rowEditSaveTimer;
          }
        },
        setRowsDirty: function(grid, myDataRows) {
          var gridRow;
          myDataRows.forEach(function(value, index) {
            gridRow = grid.getRow(value);
            if (gridRow) {
              if (!grid.rowEdit.dirtyRows) {
                grid.rowEdit.dirtyRows = [];
              }
              if (!gridRow.isDirty) {
                gridRow.isDirty = true;
                grid.rowEdit.dirtyRows.push(gridRow);
              }
              delete gridRow.isError;
              service.considerSetTimer(grid, gridRow);
            } else {
              gridUtil.logError("requested row not found in rowEdit.setRowsDirty, row was: " + value);
            }
          });
        },
        setRowsClean: function(grid, myDataRows) {
          var gridRow;
          myDataRows.forEach(function(value, index) {
            gridRow = grid.getRow(value);
            if (gridRow) {
              delete gridRow.isDirty;
              service.removeRow(grid.rowEdit.dirtyRows, gridRow);
              service.cancelTimer(grid, gridRow);
              delete gridRow.isError;
              service.removeRow(grid.rowEdit.errorRows, gridRow);
            } else {
              gridUtil.logError("requested row not found in rowEdit.setRowsClean, row was: " + value);
            }
          });
        }
      };
      return service;
    }]);
    module.directive('uiGridRowEdit', ['gridUtil', 'uiGridRowEditService', 'uiGridEditConstants', function(gridUtil, uiGridRowEditService, uiGridEditConstants) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridRowEditService.initializeGrid($scope, uiGridCtrl.grid);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridViewport', ['$compile', 'uiGridConstants', 'gridUtil', '$parse', function($compile, uiGridConstants, gridUtil, $parse) {
      return {
        priority: -200,
        scope: false,
        compile: function($elm, $attrs) {
          var rowRepeatDiv = angular.element($elm.children().children()[0]);
          var existingNgClass = rowRepeatDiv.attr("ng-class");
          var newNgClass = '';
          if (existingNgClass) {
            newNgClass = existingNgClass.slice(0, -1) + ", 'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
          } else {
            newNgClass = "{'ui-grid-row-dirty': row.isDirty, 'ui-grid-row-saving': row.isSaving, 'ui-grid-row-error': row.isError}";
          }
          rowRepeatDiv.attr("ng-class", newNgClass);
          return {
            pre: function($scope, $elm, $attrs, controllers) {},
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.saveState', ['ui.grid', 'ui.grid.selection', 'ui.grid.cellNav', 'ui.grid.grouping', 'ui.grid.pinning', 'ui.grid.treeView']);
    module.constant('uiGridSaveStateConstants', {featureName: 'saveState'});
    module.service('uiGridSaveStateService', ['$q', 'uiGridSaveStateConstants', 'gridUtil', '$compile', '$interval', 'uiGridConstants', function($q, uiGridSaveStateConstants, gridUtil, $compile, $interval, uiGridConstants) {
      var service = {
        initializeGrid: function(grid) {
          grid.saveState = {};
          this.defaultGridOptions(grid.options);
          var publicApi = {
            events: {saveState: {}},
            methods: {saveState: {
                save: function() {
                  return service.save(grid);
                },
                restore: function($scope, state) {
                  service.restore(grid, $scope, state);
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.saveWidths = gridOptions.saveWidths !== false;
          gridOptions.saveOrder = gridOptions.saveOrder !== false;
          gridOptions.saveScroll = gridOptions.saveScroll === true;
          gridOptions.saveFocus = gridOptions.saveScroll !== true && gridOptions.saveFocus !== false;
          gridOptions.saveVisible = gridOptions.saveVisible !== false;
          gridOptions.saveSort = gridOptions.saveSort !== false;
          gridOptions.saveFilter = gridOptions.saveFilter !== false;
          gridOptions.saveSelection = gridOptions.saveSelection !== false;
          gridOptions.saveGrouping = gridOptions.saveGrouping !== false;
          gridOptions.saveGroupingExpandedStates = gridOptions.saveGroupingExpandedStates === true;
          gridOptions.savePinning = gridOptions.savePinning !== false;
          gridOptions.saveTreeView = gridOptions.saveTreeView !== false;
        },
        save: function(grid) {
          var savedState = {};
          savedState.columns = service.saveColumns(grid);
          savedState.scrollFocus = service.saveScrollFocus(grid);
          savedState.selection = service.saveSelection(grid);
          savedState.grouping = service.saveGrouping(grid);
          savedState.treeView = service.saveTreeView(grid);
          return savedState;
        },
        restore: function(grid, $scope, state) {
          if (state.columns) {
            service.restoreColumns(grid, state.columns);
          }
          if (state.scrollFocus) {
            service.restoreScrollFocus(grid, $scope, state.scrollFocus);
          }
          if (state.selection) {
            service.restoreSelection(grid, state.selection);
          }
          if (state.grouping) {
            service.restoreGrouping(grid, state.grouping);
          }
          if (state.treeView) {
            service.restoreTreeView(grid, state.treeView);
          }
          grid.refresh();
        },
        saveColumns: function(grid) {
          var columns = [];
          grid.getOnlyDataColumns().forEach(function(column) {
            var savedColumn = {};
            savedColumn.name = column.name;
            if (grid.options.saveVisible) {
              savedColumn.visible = column.visible;
            }
            if (grid.options.saveWidths) {
              savedColumn.width = column.width;
            }
            if (grid.options.saveSort) {
              savedColumn.sort = angular.copy(column.sort);
            }
            if (grid.options.saveFilter) {
              savedColumn.filters = [];
              column.filters.forEach(function(filter) {
                var copiedFilter = {};
                angular.forEach(filter, function(value, key) {
                  if (key !== 'condition' && key !== '$$hashKey' && key !== 'placeholder') {
                    copiedFilter[key] = value;
                  }
                });
                savedColumn.filters.push(copiedFilter);
              });
            }
            if (!!grid.api.pinning && grid.options.savePinning) {
              savedColumn.pinned = column.renderContainer ? column.renderContainer : '';
            }
            columns.push(savedColumn);
          });
          return columns;
        },
        saveScrollFocus: function(grid) {
          if (!grid.api.cellNav) {
            return {};
          }
          var scrollFocus = {};
          if (grid.options.saveFocus) {
            scrollFocus.focus = true;
            var rowCol = grid.api.cellNav.getFocusedCell();
            if (rowCol !== null) {
              if (rowCol.col !== null) {
                scrollFocus.colName = rowCol.col.colDef.name;
              }
              if (rowCol.row !== null) {
                scrollFocus.rowVal = service.getRowVal(grid, rowCol.row);
              }
            }
          }
          if (grid.options.saveScroll || grid.options.saveFocus && !scrollFocus.colName && !scrollFocus.rowVal) {
            scrollFocus.focus = false;
            if (grid.renderContainers.body.prevRowScrollIndex) {
              scrollFocus.rowVal = service.getRowVal(grid, grid.renderContainers.body.visibleRowCache[grid.renderContainers.body.prevRowScrollIndex]);
            }
            if (grid.renderContainers.body.prevColScrollIndex) {
              scrollFocus.colName = grid.renderContainers.body.visibleColumnCache[grid.renderContainers.body.prevColScrollIndex].name;
            }
          }
          return scrollFocus;
        },
        saveSelection: function(grid) {
          if (!grid.api.selection || !grid.options.saveSelection) {
            return [];
          }
          var selection = grid.api.selection.getSelectedGridRows().map(function(gridRow) {
            return service.getRowVal(grid, gridRow);
          });
          return selection;
        },
        saveGrouping: function(grid) {
          if (!grid.api.grouping || !grid.options.saveGrouping) {
            return {};
          }
          return grid.api.grouping.getGrouping(grid.options.saveGroupingExpandedStates);
        },
        saveTreeView: function(grid) {
          if (!grid.api.treeView || !grid.options.saveTreeView) {
            return {};
          }
          return grid.api.treeView.getTreeView();
        },
        getRowVal: function(grid, gridRow) {
          if (!gridRow) {
            return null;
          }
          var rowVal = {};
          if (grid.options.saveRowIdentity) {
            rowVal.identity = true;
            rowVal.row = grid.options.saveRowIdentity(gridRow.entity);
          } else {
            rowVal.identity = false;
            rowVal.row = grid.renderContainers.body.visibleRowCache.indexOf(gridRow);
          }
          return rowVal;
        },
        restoreColumns: function(grid, columnsState) {
          var isSortChanged = false;
          columnsState.forEach(function(columnState, index) {
            var currentCol = grid.getColumn(columnState.name);
            if (currentCol && !grid.isRowHeaderColumn(currentCol)) {
              if (grid.options.saveVisible && (currentCol.visible !== columnState.visible || currentCol.colDef.visible !== columnState.visible)) {
                currentCol.visible = columnState.visible;
                currentCol.colDef.visible = columnState.visible;
                grid.api.core.raise.columnVisibilityChanged(currentCol);
              }
              if (grid.options.saveWidths) {
                currentCol.width = columnState.width;
              }
              if (grid.options.saveSort && !angular.equals(currentCol.sort, columnState.sort) && !(currentCol.sort === undefined && angular.isEmpty(columnState.sort))) {
                currentCol.sort = angular.copy(columnState.sort);
                isSortChanged = true;
              }
              if (grid.options.saveFilter && !angular.equals(currentCol.filters, columnState.filters)) {
                columnState.filters.forEach(function(filter, index) {
                  angular.extend(currentCol.filters[index], filter);
                  if (typeof(filter.term) === 'undefined' || filter.term === null) {
                    delete currentCol.filters[index].term;
                  }
                });
                grid.api.core.raise.filterChanged();
              }
              if (!!grid.api.pinning && grid.options.savePinning && currentCol.renderContainer !== columnState.pinned) {
                grid.api.pinning.pinColumn(currentCol, columnState.pinned);
              }
              var currentIndex = grid.getOnlyDataColumns().indexOf(currentCol);
              if (currentIndex !== -1) {
                if (grid.options.saveOrder && currentIndex !== index) {
                  var column = grid.columns.splice(currentIndex + grid.rowHeaderColumns.length, 1)[0];
                  grid.columns.splice(index + grid.rowHeaderColumns.length, 0, column);
                }
              }
            }
          });
          if (isSortChanged) {
            grid.api.core.raise.sortChanged(grid, grid.getColumnSorting());
          }
        },
        restoreScrollFocus: function(grid, $scope, scrollFocusState) {
          if (!grid.api.cellNav) {
            return ;
          }
          var colDef,
              row;
          if (scrollFocusState.colName) {
            var colDefs = grid.options.columnDefs.filter(function(colDef) {
              return colDef.name === scrollFocusState.colName;
            });
            if (colDefs.length > 0) {
              colDef = colDefs[0];
            }
          }
          if (scrollFocusState.rowVal && scrollFocusState.rowVal.row) {
            if (scrollFocusState.rowVal.identity) {
              row = service.findRowByIdentity(grid, scrollFocusState.rowVal);
            } else {
              row = grid.renderContainers.body.visibleRowCache[scrollFocusState.rowVal.row];
            }
          }
          var entity = row && row.entity ? row.entity : null;
          if (colDef || entity) {
            if (scrollFocusState.focus) {
              grid.api.cellNav.scrollToFocus(entity, colDef);
            } else {
              grid.scrollTo(entity, colDef);
            }
          }
        },
        restoreSelection: function(grid, selectionState) {
          if (!grid.api.selection) {
            return ;
          }
          grid.api.selection.clearSelectedRows();
          selectionState.forEach(function(rowVal) {
            if (rowVal.identity) {
              var foundRow = service.findRowByIdentity(grid, rowVal);
              if (foundRow) {
                grid.api.selection.selectRow(foundRow.entity);
              }
            } else {
              grid.api.selection.selectRowByVisibleIndex(rowVal.row);
            }
          });
        },
        restoreGrouping: function(grid, groupingState) {
          if (!grid.api.grouping || typeof(groupingState) === 'undefined' || groupingState === null || angular.equals(groupingState, {})) {
            return ;
          }
          grid.api.grouping.setGrouping(groupingState);
        },
        restoreTreeView: function(grid, treeViewState) {
          if (!grid.api.treeView || typeof(treeViewState) === 'undefined' || treeViewState === null || angular.equals(treeViewState, {})) {
            return ;
          }
          grid.api.treeView.setTreeView(treeViewState);
        },
        findRowByIdentity: function(grid, rowVal) {
          if (!grid.options.saveRowIdentity) {
            return null;
          }
          var filteredRows = grid.rows.filter(function(gridRow) {
            if (grid.options.saveRowIdentity(gridRow.entity) === rowVal.row) {
              return true;
            } else {
              return false;
            }
          });
          if (filteredRows.length > 0) {
            return filteredRows[0];
          } else {
            return null;
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridSaveState', ['uiGridSaveStateConstants', 'uiGridSaveStateService', 'gridUtil', '$compile', function(uiGridSaveStateConstants, uiGridSaveStateService, gridUtil, $compile) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          uiGridSaveStateService.initializeGrid(uiGridCtrl.grid);
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.selection', ['ui.grid']);
    module.constant('uiGridSelectionConstants', {
      featureName: "selection",
      selectionRowHeaderColName: 'selectionRowHeaderCol'
    });
    angular.module('ui.grid').config(['$provide', function($provide) {
      $provide.decorator('GridRow', ['$delegate', function($delegate) {
        $delegate.prototype.setSelected = function(selected) {
          this.isSelected = selected;
          if (selected) {
            this.grid.selection.selectedCount++;
          } else {
            this.grid.selection.selectedCount--;
          }
        };
        return $delegate;
      }]);
    }]);
    module.service('uiGridSelectionService', ['$q', '$templateCache', 'uiGridSelectionConstants', 'gridUtil', function($q, $templateCache, uiGridSelectionConstants, gridUtil) {
      var service = {
        initializeGrid: function(grid) {
          grid.selection = {};
          grid.selection.lastSelectedRow = null;
          grid.selection.selectAll = false;
          grid.selection.selectedCount = 0;
          service.defaultGridOptions(grid.options);
          var publicApi = {
            events: {selection: {
                rowSelectionChanged: function(scope, row, evt) {},
                rowSelectionChangedBatch: function(scope, rows, evt) {}
              }},
            methods: {selection: {
                toggleRowSelection: function(rowEntity, evt) {
                  var row = grid.getRow(rowEntity);
                  if (row !== null) {
                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                  }
                },
                selectRow: function(rowEntity, evt) {
                  var row = grid.getRow(rowEntity);
                  if (row !== null && !row.isSelected) {
                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                  }
                },
                selectRowByVisibleIndex: function(rowNum, evt) {
                  var row = grid.renderContainers.body.visibleRowCache[rowNum];
                  if (row !== null && typeof(row) !== 'undefined' && !row.isSelected) {
                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                  }
                },
                unSelectRow: function(rowEntity, evt) {
                  var row = grid.getRow(rowEntity);
                  if (row !== null && row.isSelected) {
                    service.toggleRowSelection(grid, row, evt, grid.options.multiSelect, grid.options.noUnselect);
                  }
                },
                selectAllRows: function(evt) {
                  if (grid.options.multiSelect === false) {
                    return ;
                  }
                  var changedRows = [];
                  grid.rows.forEach(function(row) {
                    if (!row.isSelected && row.enableSelection !== false) {
                      row.setSelected(true);
                      service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                    }
                  });
                  service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                  grid.selection.selectAll = true;
                },
                selectAllVisibleRows: function(evt) {
                  if (grid.options.multiSelect === false) {
                    return ;
                  }
                  var changedRows = [];
                  grid.rows.forEach(function(row) {
                    if (row.visible) {
                      if (!row.isSelected && row.enableSelection !== false) {
                        row.setSelected(true);
                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                      }
                    } else {
                      if (row.isSelected) {
                        row.setSelected(false);
                        service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
                      }
                    }
                  });
                  service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
                  grid.selection.selectAll = true;
                },
                clearSelectedRows: function(evt) {
                  service.clearSelectedRows(grid, evt);
                },
                getSelectedRows: function() {
                  return service.getSelectedRows(grid).map(function(gridRow) {
                    return gridRow.entity;
                  });
                },
                getSelectedGridRows: function() {
                  return service.getSelectedRows(grid);
                },
                setMultiSelect: function(multiSelect) {
                  grid.options.multiSelect = multiSelect;
                },
                setModifierKeysToMultiSelect: function(modifierKeysToMultiSelect) {
                  grid.options.modifierKeysToMultiSelect = modifierKeysToMultiSelect;
                },
                getSelectAllState: function() {
                  return grid.selection.selectAll;
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableRowSelection = gridOptions.enableRowSelection !== false;
          gridOptions.multiSelect = gridOptions.multiSelect !== false;
          gridOptions.noUnselect = gridOptions.noUnselect === true;
          gridOptions.modifierKeysToMultiSelect = gridOptions.modifierKeysToMultiSelect === true;
          gridOptions.enableRowHeaderSelection = gridOptions.enableRowHeaderSelection !== false;
          if (typeof(gridOptions.enableFullRowSelection) === 'undefined') {
            gridOptions.enableFullRowSelection = !gridOptions.enableRowHeaderSelection;
          }
          gridOptions.enableSelectAll = gridOptions.enableSelectAll !== false;
          gridOptions.enableSelectionBatchEvent = gridOptions.enableSelectionBatchEvent !== false;
          gridOptions.selectionRowHeaderWidth = angular.isDefined(gridOptions.selectionRowHeaderWidth) ? gridOptions.selectionRowHeaderWidth : 30;
          gridOptions.enableFooterTotalSelected = gridOptions.enableFooterTotalSelected !== false;
          gridOptions.isRowSelectable = angular.isDefined(gridOptions.isRowSelectable) ? gridOptions.isRowSelectable : angular.noop;
        },
        toggleRowSelection: function(grid, row, evt, multiSelect, noUnselect) {
          var selected = row.isSelected;
          if (row.enableSelection === false && !selected) {
            return ;
          }
          if (!multiSelect && !selected) {
            service.clearSelectedRows(grid, evt);
          } else if (!multiSelect && selected) {
            var selectedRows = service.getSelectedRows(grid);
            if (selectedRows.length > 1) {
              selected = false;
              service.clearSelectedRows(grid, evt);
            }
          }
          if (selected && noUnselect) {} else {
            row.setSelected(!selected);
            if (row.isSelected === true) {
              grid.selection.lastSelectedRow = row;
            } else {
              grid.selection.selectAll = false;
            }
            grid.api.selection.raise.rowSelectionChanged(row, evt);
          }
        },
        shiftSelect: function(grid, row, evt, multiSelect) {
          if (!multiSelect) {
            return ;
          }
          var selectedRows = service.getSelectedRows(grid);
          var fromRow = selectedRows.length > 0 ? grid.renderContainers.body.visibleRowCache.indexOf(grid.selection.lastSelectedRow) : 0;
          var toRow = grid.renderContainers.body.visibleRowCache.indexOf(row);
          if (fromRow > toRow) {
            var tmp = fromRow;
            fromRow = toRow;
            toRow = tmp;
          }
          var changedRows = [];
          for (var i = fromRow; i <= toRow; i++) {
            var rowToSelect = grid.renderContainers.body.visibleRowCache[i];
            if (rowToSelect) {
              if (!rowToSelect.isSelected && rowToSelect.enableSelection !== false) {
                rowToSelect.setSelected(true);
                grid.selection.lastSelectedRow = rowToSelect;
                service.decideRaiseSelectionEvent(grid, rowToSelect, changedRows, evt);
              }
            }
          }
          service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
        },
        getSelectedRows: function(grid) {
          return grid.rows.filter(function(row) {
            return row.isSelected;
          });
        },
        clearSelectedRows: function(grid, evt) {
          var changedRows = [];
          service.getSelectedRows(grid).forEach(function(row) {
            if (row.isSelected) {
              row.setSelected(false);
              service.decideRaiseSelectionEvent(grid, row, changedRows, evt);
            }
          });
          service.decideRaiseSelectionBatchEvent(grid, changedRows, evt);
          grid.selection.selectAll = false;
        },
        decideRaiseSelectionEvent: function(grid, row, changedRows, evt) {
          if (!grid.options.enableSelectionBatchEvent) {
            grid.api.selection.raise.rowSelectionChanged(row, evt);
          } else {
            changedRows.push(row);
          }
        },
        decideRaiseSelectionBatchEvent: function(grid, changedRows, evt) {
          if (changedRows.length > 0) {
            grid.api.selection.raise.rowSelectionChangedBatch(changedRows, evt);
          }
        }
      };
      return service;
    }]);
    module.directive('uiGridSelection', ['uiGridSelectionConstants', 'uiGridSelectionService', '$templateCache', 'uiGridConstants', function(uiGridSelectionConstants, uiGridSelectionService, $templateCache, uiGridConstants) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              uiGridSelectionService.initializeGrid(uiGridCtrl.grid);
              if (uiGridCtrl.grid.options.enableRowHeaderSelection) {
                var selectionRowHeaderDef = {
                  name: uiGridSelectionConstants.selectionRowHeaderColName,
                  displayName: '',
                  width: uiGridCtrl.grid.options.selectionRowHeaderWidth,
                  minWidth: 10,
                  cellTemplate: 'ui-grid/selectionRowHeader',
                  headerCellTemplate: 'ui-grid/selectionHeaderCell',
                  enableColumnResizing: false,
                  enableColumnMenu: false,
                  exporterSuppressExport: true,
                  allowCellFocus: true
                };
                uiGridCtrl.grid.addRowHeaderColumn(selectionRowHeaderDef);
              }
              var processorSet = false;
              var processSelectableRows = function(rows) {
                rows.forEach(function(row) {
                  row.enableSelection = uiGridCtrl.grid.options.isRowSelectable(row);
                });
                return rows;
              };
              var updateOptions = function() {
                if (uiGridCtrl.grid.options.isRowSelectable !== angular.noop && processorSet !== true) {
                  uiGridCtrl.grid.registerRowsProcessor(processSelectableRows, 500);
                  processorSet = true;
                }
              };
              updateOptions();
              var dataChangeDereg = uiGridCtrl.grid.registerDataChangeCallback(updateOptions, [uiGridConstants.dataChange.OPTIONS]);
              $scope.$on('$destroy', dataChangeDereg);
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
    module.directive('uiGridSelectionRowHeaderButtons', ['$templateCache', 'uiGridSelectionService', 'gridUtil', function($templateCache, uiGridSelectionService, gridUtil) {
      return {
        replace: true,
        restrict: 'E',
        template: $templateCache.get('ui-grid/selectionRowHeaderButtons'),
        scope: true,
        require: '^uiGrid',
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = uiGridCtrl.grid;
          $scope.selectButtonClick = selectButtonClick;
          if (gridUtil.detectBrowser() === 'ie') {
            $elm.on('mousedown', selectButtonMouseDown);
          }
          function selectButtonClick(row, evt) {
            evt.stopPropagation();
            if (evt.shiftKey) {
              uiGridSelectionService.shiftSelect(self, row, evt, self.options.multiSelect);
            } else if (evt.ctrlKey || evt.metaKey) {
              uiGridSelectionService.toggleRowSelection(self, row, evt, self.options.multiSelect, self.options.noUnselect);
            } else {
              uiGridSelectionService.toggleRowSelection(self, row, evt, (self.options.multiSelect && !self.options.modifierKeysToMultiSelect), self.options.noUnselect);
            }
          }
          function selectButtonMouseDown(evt) {
            if (evt.ctrlKey || evt.shiftKey) {
              evt.target.onselectstart = function() {
                return false;
              };
              window.setTimeout(function() {
                evt.target.onselectstart = null;
              }, 0);
            }
          }
        }
      };
    }]);
    module.directive('uiGridSelectionSelectAllButtons', ['$templateCache', 'uiGridSelectionService', function($templateCache, uiGridSelectionService) {
      return {
        replace: true,
        restrict: 'E',
        template: $templateCache.get('ui-grid/selectionSelectAllButtons'),
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = $scope.col.grid;
          $scope.headerButtonClick = function(row, evt) {
            if (self.selection.selectAll) {
              uiGridSelectionService.clearSelectedRows(self, evt);
              if (self.options.noUnselect) {
                self.api.selection.selectRowByVisibleIndex(0, evt);
              }
              self.selection.selectAll = false;
            } else {
              if (self.options.multiSelect) {
                self.api.selection.selectAllVisibleRows(evt);
                self.selection.selectAll = true;
              }
            }
          };
        }
      };
    }]);
    module.directive('uiGridViewport', ['$compile', 'uiGridConstants', 'uiGridSelectionConstants', 'gridUtil', '$parse', 'uiGridSelectionService', function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService) {
      return {
        priority: -200,
        scope: false,
        compile: function($elm, $attrs) {
          var rowRepeatDiv = angular.element($elm.children().children()[0]);
          var existingNgClass = rowRepeatDiv.attr("ng-class");
          var newNgClass = '';
          if (existingNgClass) {
            newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-row-selected': row.isSelected}";
          } else {
            newNgClass = "{'ui-grid-row-selected': row.isSelected}";
          }
          rowRepeatDiv.attr("ng-class", newNgClass);
          return {
            pre: function($scope, $elm, $attrs, controllers) {},
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
    module.directive('uiGridCell', ['$compile', 'uiGridConstants', 'uiGridSelectionConstants', 'gridUtil', '$parse', 'uiGridSelectionService', '$timeout', function($compile, uiGridConstants, uiGridSelectionConstants, gridUtil, $parse, uiGridSelectionService, $timeout) {
      return {
        priority: -200,
        restrict: 'A',
        require: '?^uiGrid',
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var touchStartTime = 0;
          var touchTimeout = 300;
          if (uiGridCtrl.grid.api.cellNav) {
            uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown($scope, function(evt, rowCol) {
              if (rowCol === null || rowCol.row !== $scope.row || rowCol.col !== $scope.col) {
                return ;
              }
              if (evt.keyCode === 32 && $scope.col.colDef.name === "selectionRowHeaderCol") {
                uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, ($scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect), $scope.grid.options.noUnselect);
                $scope.$apply();
              }
            });
          }
          var selectCells = function(evt) {
            $elm.off('touchend', touchEnd);
            if (evt.shiftKey) {
              uiGridSelectionService.shiftSelect($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect);
            } else if (evt.ctrlKey || evt.metaKey) {
              uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, $scope.grid.options.multiSelect, $scope.grid.options.noUnselect);
            } else {
              uiGridSelectionService.toggleRowSelection($scope.grid, $scope.row, evt, ($scope.grid.options.multiSelect && !$scope.grid.options.modifierKeysToMultiSelect), $scope.grid.options.noUnselect);
            }
            $scope.$apply();
            $timeout(function() {
              $elm.on('touchend', touchEnd);
            }, touchTimeout);
          };
          var touchStart = function(evt) {
            touchStartTime = (new Date()).getTime();
            $elm.off('click', selectCells);
          };
          var touchEnd = function(evt) {
            var touchEndTime = (new Date()).getTime();
            var touchTime = touchEndTime - touchStartTime;
            if (touchTime < touchTimeout) {
              selectCells(evt);
            }
            $timeout(function() {
              $elm.on('click', selectCells);
            }, touchTimeout);
          };
          function registerRowSelectionEvents() {
            if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection) {
              $elm.addClass('ui-grid-disable-selection');
              $elm.on('touchstart', touchStart);
              $elm.on('touchend', touchEnd);
              $elm.on('click', selectCells);
              $scope.registered = true;
            }
          }
          function deregisterRowSelectionEvents() {
            if ($scope.registered) {
              $elm.removeClass('ui-grid-disable-selection');
              $elm.off('touchstart', touchStart);
              $elm.off('touchend', touchEnd);
              $elm.off('click', selectCells);
              $scope.registered = false;
            }
          }
          registerRowSelectionEvents();
          var dataChangeDereg = $scope.grid.registerDataChangeCallback(function() {
            if ($scope.grid.options.enableRowSelection && $scope.grid.options.enableFullRowSelection && !$scope.registered) {
              registerRowSelectionEvents();
            } else if ((!$scope.grid.options.enableRowSelection || !$scope.grid.options.enableFullRowSelection) && $scope.registered) {
              deregisterRowSelectionEvents();
            }
          }, [uiGridConstants.dataChange.OPTIONS]);
          $elm.on('$destroy', dataChangeDereg);
        }
      };
    }]);
    module.directive('uiGridGridFooter', ['$compile', 'uiGridConstants', 'gridUtil', function($compile, uiGridConstants, gridUtil) {
      return {
        restrict: 'EA',
        replace: true,
        priority: -1000,
        require: '^uiGrid',
        scope: true,
        compile: function($elm, $attrs) {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              if (!uiGridCtrl.grid.options.showGridFooter) {
                return ;
              }
              gridUtil.getTemplate('ui-grid/gridFooterSelectedItems').then(function(contents) {
                var template = angular.element(contents);
                var newElm = $compile(template)($scope);
                angular.element($elm[0].getElementsByClassName('ui-grid-grid-footer')[0]).append(newElm);
              });
            },
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.treeBase', ['ui.grid']);
    module.constant('uiGridTreeBaseConstants', {
      featureName: "treeBase",
      rowHeaderColName: 'treeBaseRowHeaderCol',
      EXPANDED: 'expanded',
      COLLAPSED: 'collapsed',
      aggregation: {
        COUNT: 'count',
        SUM: 'sum',
        MAX: 'max',
        MIN: 'min',
        AVG: 'avg'
      }
    });
    module.service('uiGridTreeBaseService', ['$q', 'uiGridTreeBaseConstants', 'gridUtil', 'GridRow', 'gridClassFactory', 'i18nService', 'uiGridConstants', 'rowSorter', function($q, uiGridTreeBaseConstants, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants, rowSorter) {
      var service = {
        initializeGrid: function(grid, $scope) {
          grid.treeBase = {};
          grid.treeBase.numberLevels = 0;
          grid.treeBase.expandAll = false;
          grid.treeBase.tree = {};
          service.defaultGridOptions(grid.options);
          grid.registerRowsProcessor(service.treeRows, 410);
          grid.registerColumnBuilder(service.treeBaseColumnBuilder);
          service.createRowHeader(grid);
          var publicApi = {
            events: {treeBase: {
                rowExpanded: {},
                rowCollapsed: {}
              }},
            methods: {treeBase: {
                expandAllRows: function() {
                  service.expandAllRows(grid);
                },
                collapseAllRows: function() {
                  service.collapseAllRows(grid);
                },
                toggleRowTreeState: function(row) {
                  service.toggleRowTreeState(grid, row);
                },
                expandRow: function(row) {
                  service.expandRow(grid, row);
                },
                expandRowChildren: function(row) {
                  service.expandRowChildren(grid, row);
                },
                collapseRow: function(row) {
                  service.collapseRow(grid, row);
                },
                collapseRowChildren: function(row) {
                  service.collapseRowChildren(grid, row);
                },
                getTreeExpandedState: function() {
                  return {expandedState: service.getTreeState(grid)};
                },
                setTreeState: function(config) {
                  service.setTreeState(grid, config);
                },
                getRowChildren: function(row) {
                  return row.treeNode.children.map(function(childNode) {
                    return childNode.row;
                  });
                }
              }}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.treeRowHeaderBaseWidth = gridOptions.treeRowHeaderBaseWidth || 30;
          gridOptions.treeIndent = gridOptions.treeIndent || 10;
          gridOptions.showTreeRowHeader = gridOptions.showTreeRowHeader !== false;
          gridOptions.showTreeExpandNoChildren = gridOptions.showTreeExpandNoChildren !== false;
          gridOptions.treeRowHeaderAlwaysVisible = gridOptions.treeRowHeaderAlwaysVisible !== false;
          gridOptions.treeCustomAggregations = gridOptions.treeCustomAggregations || {};
        },
        treeBaseColumnBuilder: function(colDef, col, gridOptions) {
          if (typeof(colDef.customTreeAggregationFn) !== 'undefined') {
            col.treeAggregationFn = colDef.customTreeAggregationFn;
          }
          if (typeof(colDef.treeAggregationType) !== 'undefined') {
            col.treeAggregation = {type: colDef.treeAggregationType};
            if (typeof(gridOptions.treeCustomAggregations[colDef.treeAggregationType]) !== 'undefined') {
              col.treeAggregationFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].aggregationFn;
              col.treeAggregationFinalizerFn = gridOptions.treeCustomAggregations[colDef.treeAggregationType].finalizerFn;
              col.treeAggregation.label = gridOptions.treeCustomAggregations[colDef.treeAggregationType].label;
            } else if (typeof(service.nativeAggregations()[colDef.treeAggregationType]) !== 'undefined') {
              col.treeAggregationFn = service.nativeAggregations()[colDef.treeAggregationType].aggregationFn;
              col.treeAggregation.label = service.nativeAggregations()[colDef.treeAggregationType].label;
            }
          }
          if (typeof(colDef.treeAggregationLabel) !== 'undefined') {
            if (typeof(col.treeAggregation) === 'undefined') {
              col.treeAggregation = {};
            }
            col.treeAggregation.label = colDef.treeAggregationLabel;
          }
          col.treeAggregationUpdateEntity = colDef.treeAggregationUpdateEntity !== false;
          if (typeof(col.customTreeAggregationFinalizerFn) === 'undefined') {
            col.customTreeAggregationFinalizerFn = colDef.customTreeAggregationFinalizerFn;
          }
        },
        createRowHeader: function(grid) {
          var rowHeaderColumnDef = {
            name: uiGridTreeBaseConstants.rowHeaderColName,
            displayName: '',
            width: grid.options.treeRowHeaderBaseWidth,
            minWidth: 10,
            cellTemplate: 'ui-grid/treeBaseRowHeader',
            headerCellTemplate: 'ui-grid/treeBaseHeaderCell',
            enableColumnResizing: false,
            enableColumnMenu: false,
            exporterSuppressExport: true,
            allowCellFocus: true
          };
          rowHeaderColumnDef.visible = grid.options.treeRowHeaderAlwaysVisible;
          grid.addRowHeaderColumn(rowHeaderColumnDef);
        },
        expandAllRows: function(grid) {
          grid.treeBase.tree.forEach(function(node) {
            service.setAllNodes(grid, node, uiGridTreeBaseConstants.EXPANDED);
          });
          grid.treeBase.expandAll = true;
          grid.queueGridRefresh();
        },
        collapseAllRows: function(grid) {
          grid.treeBase.tree.forEach(function(node) {
            service.setAllNodes(grid, node, uiGridTreeBaseConstants.COLLAPSED);
          });
          grid.treeBase.expandAll = false;
          grid.queueGridRefresh();
        },
        setAllNodes: function(grid, treeNode, targetState) {
          if (typeof(treeNode.state) !== 'undefined' && treeNode.state !== targetState) {
            treeNode.state = targetState;
            if (targetState === uiGridTreeBaseConstants.EXPANDED) {
              grid.api.treeBase.raise.rowExpanded(treeNode.row);
            } else {
              grid.api.treeBase.raise.rowCollapsed(treeNode.row);
            }
          }
          if (treeNode.children) {
            treeNode.children.forEach(function(childNode) {
              service.setAllNodes(grid, childNode, targetState);
            });
          }
        },
        toggleRowTreeState: function(grid, row) {
          if (typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) {
            return ;
          }
          if (row.treeNode.state === uiGridTreeBaseConstants.EXPANDED) {
            service.collapseRow(grid, row);
          } else {
            service.expandRow(grid, row);
          }
          grid.queueGridRefresh();
        },
        expandRow: function(grid, row) {
          if (typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) {
            return ;
          }
          if (row.treeNode.state !== uiGridTreeBaseConstants.EXPANDED) {
            row.treeNode.state = uiGridTreeBaseConstants.EXPANDED;
            grid.api.treeBase.raise.rowExpanded(row);
            grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
            grid.queueGridRefresh();
          }
        },
        expandRowChildren: function(grid, row) {
          if (typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) {
            return ;
          }
          service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.EXPANDED);
          grid.treeBase.expandAll = service.allExpanded(grid.treeBase.tree);
          grid.queueGridRefresh();
        },
        collapseRow: function(grid, row) {
          if (typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) {
            return ;
          }
          if (row.treeNode.state !== uiGridTreeBaseConstants.COLLAPSED) {
            row.treeNode.state = uiGridTreeBaseConstants.COLLAPSED;
            grid.treeBase.expandAll = false;
            grid.api.treeBase.raise.rowCollapsed(row);
            grid.queueGridRefresh();
          }
        },
        collapseRowChildren: function(grid, row) {
          if (typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) {
            return ;
          }
          service.setAllNodes(grid, row.treeNode, uiGridTreeBaseConstants.COLLAPSED);
          grid.treeBase.expandAll = false;
          grid.queueGridRefresh();
        },
        allExpanded: function(tree) {
          var allExpanded = true;
          tree.forEach(function(node) {
            if (!service.allExpandedInternal(node)) {
              allExpanded = false;
            }
          });
          return allExpanded;
        },
        allExpandedInternal: function(treeNode) {
          if (treeNode.children && treeNode.children.length > 0) {
            if (treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
              return false;
            }
            var allExpanded = true;
            treeNode.children.forEach(function(node) {
              if (!service.allExpandedInternal(node)) {
                allExpanded = false;
              }
            });
            return allExpanded;
          } else {
            return true;
          }
        },
        treeRows: function(renderableRows) {
          if (renderableRows.length === 0) {
            return renderableRows;
          }
          var grid = this;
          var currentLevel = 0;
          var currentState = uiGridTreeBaseConstants.EXPANDED;
          var parents = [];
          grid.treeBase.tree = service.createTree(grid, renderableRows);
          service.updateRowHeaderWidth(grid);
          service.sortTree(grid);
          service.fixFilter(grid);
          return service.renderTree(grid.treeBase.tree);
        },
        updateRowHeaderWidth: function(grid) {
          var rowHeader = grid.getColumn(uiGridTreeBaseConstants.rowHeaderColName);
          var newWidth = grid.options.treeRowHeaderBaseWidth + grid.options.treeIndent * Math.max(grid.treeBase.numberLevels - 1, 0);
          if (rowHeader && newWidth !== rowHeader.width) {
            rowHeader.width = newWidth;
            grid.queueRefresh();
          }
          var newVisibility = true;
          if (grid.options.showTreeRowHeader === false) {
            newVisibility = false;
          }
          if (grid.options.treeRowHeaderAlwaysVisible === false && grid.treeBase.numberLevels <= 0) {
            newVisibility = false;
          }
          if (rowHeader.visible !== newVisibility) {
            rowHeader.visible = newVisibility;
            rowHeader.colDef.visible = newVisibility;
            grid.queueGridRefresh();
          }
        },
        renderTree: function(nodeList) {
          var renderableRows = [];
          nodeList.forEach(function(node) {
            if (node.row.visible) {
              renderableRows.push(node.row);
            }
            if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
              renderableRows = renderableRows.concat(service.renderTree(node.children));
            }
          });
          return renderableRows;
        },
        createTree: function(grid, renderableRows) {
          var currentLevel = -1;
          var parents = [];
          var currentState;
          grid.treeBase.tree = [];
          grid.treeBase.numberLevels = 0;
          var aggregations = service.getAggregations(grid);
          var createNode = function(row) {
            if (typeof(row.entity.$$treeLevel) !== 'undefined' && row.treeLevel !== row.entity.$$treeLevel) {
              row.treeLevel = row.entity.$$treeLevel;
            }
            if (row.treeLevel <= currentLevel) {
              while (row.treeLevel <= currentLevel) {
                var lastParent = parents.pop();
                service.finaliseAggregations(lastParent);
                currentLevel--;
              }
              if (parents.length > 0) {
                currentState = service.setCurrentState(parents);
              } else {
                currentState = uiGridTreeBaseConstants.EXPANDED;
              }
            }
            if ((typeof(row.treeLevel) === 'undefined' || row.treeLevel === null || row.treeLevel < 0) && row.visible) {
              service.aggregate(grid, row, parents);
            }
            service.addOrUseNode(grid, row, parents, aggregations);
            if (typeof(row.treeLevel) !== 'undefined' && row.treeLevel !== null && row.treeLevel >= 0) {
              parents.push(row);
              currentLevel++;
              currentState = service.setCurrentState(parents);
            }
            if (grid.treeBase.numberLevels < row.treeLevel + 1) {
              grid.treeBase.numberLevels = row.treeLevel + 1;
            }
          };
          renderableRows.forEach(createNode);
          while (parents.length > 0) {
            var lastParent = parents.pop();
            service.finaliseAggregations(lastParent);
          }
          return grid.treeBase.tree;
        },
        addOrUseNode: function(grid, row, parents, aggregationBase) {
          var newAggregations = [];
          aggregationBase.forEach(function(aggregation) {
            newAggregations.push(service.buildAggregationObject(aggregation.col));
          });
          var newNode = {
            state: uiGridTreeBaseConstants.COLLAPSED,
            row: row,
            parentRow: null,
            aggregations: newAggregations,
            children: []
          };
          if (row.treeNode) {
            newNode.state = row.treeNode.state;
          }
          if (parents.length > 0) {
            newNode.parentRow = parents[parents.length - 1];
          }
          row.treeNode = newNode;
          if (parents.length === 0) {
            grid.treeBase.tree.push(newNode);
          } else {
            parents[parents.length - 1].treeNode.children.push(newNode);
          }
        },
        setCurrentState: function(parents) {
          var currentState = uiGridTreeBaseConstants.EXPANDED;
          parents.forEach(function(parent) {
            if (parent.treeNode.state === uiGridTreeBaseConstants.COLLAPSED) {
              currentState = uiGridTreeBaseConstants.COLLAPSED;
            }
          });
          return currentState;
        },
        sortTree: function(grid) {
          grid.columns.forEach(function(column) {
            if (column.sort && column.sort.ignoreSort) {
              delete column.sort.ignoreSort;
            }
          });
          grid.treeBase.tree = service.sortInternal(grid, grid.treeBase.tree);
        },
        sortInternal: function(grid, treeList) {
          var rows = treeList.map(function(node) {
            return node.row;
          });
          rows = rowSorter.sort(grid, rows, grid.columns);
          var treeNodes = rows.map(function(row) {
            return row.treeNode;
          });
          treeNodes.forEach(function(node) {
            if (node.state === uiGridTreeBaseConstants.EXPANDED && node.children && node.children.length > 0) {
              node.children = service.sortInternal(grid, node.children);
            }
          });
          return treeNodes;
        },
        fixFilter: function(grid) {
          var parentsVisible;
          grid.treeBase.tree.forEach(function(node) {
            if (node.children && node.children.length > 0) {
              parentsVisible = node.row.visible;
              service.fixFilterInternal(node.children, parentsVisible);
            }
          });
        },
        fixFilterInternal: function(nodes, parentsVisible) {
          nodes.forEach(function(node) {
            if (node.row.visible && !parentsVisible) {
              service.setParentsVisible(node);
              parentsVisible = true;
            }
            if (node.children && node.children.length > 0) {
              if (service.fixFilterInternal(node.children, (parentsVisible && node.row.visible))) {
                parentsVisible = true;
              }
            }
          });
          return parentsVisible;
        },
        setParentsVisible: function(node) {
          while (node.parentRow) {
            node.parentRow.visible = true;
            node = node.parentRow.treeNode;
          }
        },
        buildAggregationObject: function(column) {
          var newAggregation = {col: column};
          if (column.treeAggregation && column.treeAggregation.type) {
            newAggregation.type = column.treeAggregation.type;
          }
          if (column.treeAggregation && column.treeAggregation.label) {
            newAggregation.label = column.treeAggregation.label;
          }
          return newAggregation;
        },
        getAggregations: function(grid) {
          var aggregateArray = [];
          grid.columns.forEach(function(column) {
            if (typeof(column.treeAggregationFn) !== 'undefined') {
              aggregateArray.push(service.buildAggregationObject(column));
              if (grid.options.showColumnFooter && typeof(column.colDef.aggregationType) === 'undefined' && column.treeAggregation) {
                column.treeFooterAggregation = service.buildAggregationObject(column);
                column.aggregationType = service.treeFooterAggregationType;
              }
            }
          });
          return aggregateArray;
        },
        aggregate: function(grid, row, parents) {
          if (parents.length === 0 && row.treeNode && row.treeNode.aggregations) {
            row.treeNode.aggregations.forEach(function(aggregation) {
              if (typeof(aggregation.col.treeFooterAggregation) !== 'undefined') {
                var fieldValue = grid.getCellValue(row, aggregation.col);
                var numValue = Number(fieldValue);
                aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
              }
            });
          }
          parents.forEach(function(parent, index) {
            if (parent.treeNode.aggregations) {
              parent.treeNode.aggregations.forEach(function(aggregation) {
                var fieldValue = grid.getCellValue(row, aggregation.col);
                var numValue = Number(fieldValue);
                aggregation.col.treeAggregationFn(aggregation, fieldValue, numValue, row);
                if (index === 0 && typeof(aggregation.col.treeFooterAggregation) !== 'undefined') {
                  aggregation.col.treeAggregationFn(aggregation.col.treeFooterAggregation, fieldValue, numValue, row);
                }
              });
            }
          });
        },
        nativeAggregations: function() {
          var nativeAggregations = {
            count: {
              label: i18nService.get().aggregation.count,
              menuTitle: i18nService.get().grouping.aggregate_count,
              aggregationFn: function(aggregation, fieldValue, numValue) {
                if (typeof(aggregation.value) === 'undefined') {
                  aggregation.value = 1;
                } else {
                  aggregation.value++;
                }
              }
            },
            sum: {
              label: i18nService.get().aggregation.sum,
              menuTitle: i18nService.get().grouping.aggregate_sum,
              aggregationFn: function(aggregation, fieldValue, numValue) {
                if (!isNaN(numValue)) {
                  if (typeof(aggregation.value) === 'undefined') {
                    aggregation.value = numValue;
                  } else {
                    aggregation.value += numValue;
                  }
                }
              }
            },
            min: {
              label: i18nService.get().aggregation.min,
              menuTitle: i18nService.get().grouping.aggregate_min,
              aggregationFn: function(aggregation, fieldValue, numValue) {
                if (typeof(aggregation.value) === 'undefined') {
                  aggregation.value = fieldValue;
                } else {
                  if (typeof(fieldValue) !== 'undefined' && fieldValue !== null && (fieldValue < aggregation.value || aggregation.value === null)) {
                    aggregation.value = fieldValue;
                  }
                }
              }
            },
            max: {
              label: i18nService.get().aggregation.max,
              menuTitle: i18nService.get().grouping.aggregate_max,
              aggregationFn: function(aggregation, fieldValue, numValue) {
                if (typeof(aggregation.value) === 'undefined') {
                  aggregation.value = fieldValue;
                } else {
                  if (typeof(fieldValue) !== 'undefined' && fieldValue !== null && (fieldValue > aggregation.value || aggregation.value === null)) {
                    aggregation.value = fieldValue;
                  }
                }
              }
            },
            avg: {
              label: i18nService.get().aggregation.avg,
              menuTitle: i18nService.get().grouping.aggregate_avg,
              aggregationFn: function(aggregation, fieldValue, numValue) {
                if (typeof(aggregation.count) === 'undefined') {
                  aggregation.count = 1;
                } else {
                  aggregation.count++;
                }
                if (isNaN(numValue)) {
                  return ;
                }
                if (typeof(aggregation.value) === 'undefined' || typeof(aggregation.sum) === 'undefined') {
                  aggregation.value = numValue;
                  aggregation.sum = numValue;
                } else {
                  aggregation.sum += numValue;
                  aggregation.value = aggregation.sum / aggregation.count;
                }
              }
            }
          };
          return nativeAggregations;
        },
        finaliseAggregation: function(row, aggregation) {
          if (aggregation.col.treeAggregationUpdateEntity && typeof(row) !== 'undefined' && typeof(row.entity['$$' + aggregation.col.uid]) !== 'undefined') {
            angular.extend(aggregation, row.entity['$$' + aggregation.col.uid]);
          }
          if (typeof(aggregation.col.treeAggregationFinalizerFn) === 'function') {
            aggregation.col.treeAggregationFinalizerFn(aggregation);
          }
          if (typeof(aggregation.col.customTreeAggregationFinalizerFn) === 'function') {
            aggregation.col.customTreeAggregationFinalizerFn(aggregation);
          }
          if (typeof(aggregation.rendered) === 'undefined') {
            aggregation.rendered = aggregation.label ? aggregation.label + aggregation.value : aggregation.value;
          }
        },
        finaliseAggregations: function(row) {
          if (typeof(row.treeNode.aggregations) === 'undefined') {
            return ;
          }
          row.treeNode.aggregations.forEach(function(aggregation) {
            service.finaliseAggregation(row, aggregation);
            if (aggregation.col.treeAggregationUpdateEntity) {
              var aggregationCopy = {};
              angular.forEach(aggregation, function(value, key) {
                if (aggregation.hasOwnProperty(key) && key !== 'col') {
                  aggregationCopy[key] = value;
                }
              });
              row.entity['$$' + aggregation.col.uid] = aggregationCopy;
            }
          });
        },
        treeFooterAggregationType: function(rows, column) {
          service.finaliseAggregation(undefined, column.treeFooterAggregation);
          if (typeof(column.treeFooterAggregation.value) === 'undefined' || column.treeFooterAggregation.rendered === null) {
            return '';
          }
          return column.treeFooterAggregation.rendered;
        }
      };
      return service;
    }]);
    module.directive('uiGridTreeBaseRowHeaderButtons', ['$templateCache', 'uiGridTreeBaseService', function($templateCache, uiGridTreeBaseService) {
      return {
        replace: true,
        restrict: 'E',
        template: $templateCache.get('ui-grid/treeBaseRowHeaderButtons'),
        scope: true,
        require: '^uiGrid',
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = uiGridCtrl.grid;
          $scope.treeButtonClick = function(row, evt) {
            uiGridTreeBaseService.toggleRowTreeState(self, row, evt);
          };
        }
      };
    }]);
    module.directive('uiGridTreeBaseExpandAllButtons', ['$templateCache', 'uiGridTreeBaseService', function($templateCache, uiGridTreeBaseService) {
      return {
        replace: true,
        restrict: 'E',
        template: $templateCache.get('ui-grid/treeBaseExpandAllButtons'),
        scope: false,
        link: function($scope, $elm, $attrs, uiGridCtrl) {
          var self = $scope.col.grid;
          $scope.headerButtonClick = function(row, evt) {
            if (self.treeBase.expandAll) {
              uiGridTreeBaseService.collapseAllRows(self, evt);
            } else {
              uiGridTreeBaseService.expandAllRows(self, evt);
            }
          };
        }
      };
    }]);
    module.directive('uiGridViewport', ['$compile', 'uiGridConstants', 'gridUtil', '$parse', function($compile, uiGridConstants, gridUtil, $parse) {
      return {
        priority: -200,
        scope: false,
        compile: function($elm, $attrs) {
          var rowRepeatDiv = angular.element($elm.children().children()[0]);
          var existingNgClass = rowRepeatDiv.attr("ng-class");
          var newNgClass = '';
          if (existingNgClass) {
            newNgClass = existingNgClass.slice(0, -1) + ",'ui-grid-tree-header-row': row.treeLevel > -1}";
          } else {
            newNgClass = "{'ui-grid-tree-header-row': row.treeLevel > -1}";
          }
          rowRepeatDiv.attr("ng-class", newNgClass);
          return {
            pre: function($scope, $elm, $attrs, controllers) {},
            post: function($scope, $elm, $attrs, controllers) {}
          };
        }
      };
    }]);
  })();
  (function() {
    'use strict';
    var module = angular.module('ui.grid.treeView', ['ui.grid', 'ui.grid.treeBase']);
    module.constant('uiGridTreeViewConstants', {
      featureName: "treeView",
      rowHeaderColName: 'treeBaseRowHeaderCol',
      EXPANDED: 'expanded',
      COLLAPSED: 'collapsed',
      aggregation: {
        COUNT: 'count',
        SUM: 'sum',
        MAX: 'max',
        MIN: 'min',
        AVG: 'avg'
      }
    });
    module.service('uiGridTreeViewService', ['$q', 'uiGridTreeViewConstants', 'uiGridTreeBaseConstants', 'uiGridTreeBaseService', 'gridUtil', 'GridRow', 'gridClassFactory', 'i18nService', 'uiGridConstants', function($q, uiGridTreeViewConstants, uiGridTreeBaseConstants, uiGridTreeBaseService, gridUtil, GridRow, gridClassFactory, i18nService, uiGridConstants) {
      var service = {
        initializeGrid: function(grid, $scope) {
          uiGridTreeBaseService.initializeGrid(grid, $scope);
          grid.treeView = {};
          grid.registerRowsProcessor(service.adjustSorting, 60);
          var publicApi = {
            events: {treeView: {}},
            methods: {treeView: {}}
          };
          grid.api.registerEventsFromObject(publicApi.events);
          grid.api.registerMethodsFromObject(publicApi.methods);
        },
        defaultGridOptions: function(gridOptions) {
          gridOptions.enableTreeView = gridOptions.enableTreeView !== false;
        },
        adjustSorting: function(renderableRows) {
          var grid = this;
          grid.columns.forEach(function(column) {
            if (column.sort) {
              column.sort.ignoreSort = true;
            }
          });
          return renderableRows;
        }
      };
      return service;
    }]);
    module.directive('uiGridTreeView', ['uiGridTreeViewConstants', 'uiGridTreeViewService', '$templateCache', function(uiGridTreeViewConstants, uiGridTreeViewService, $templateCache) {
      return {
        replace: true,
        priority: 0,
        require: '^uiGrid',
        scope: false,
        compile: function() {
          return {
            pre: function($scope, $elm, $attrs, uiGridCtrl) {
              if (uiGridCtrl.grid.options.enableTreeView !== false) {
                uiGridTreeViewService.initializeGrid(uiGridCtrl.grid, $scope);
              }
            },
            post: function($scope, $elm, $attrs, uiGridCtrl) {}
          };
        }
      };
    }]);
  })();
  angular.module('ui.grid').run(['$templateCache', function($templateCache) {
    'use strict';
    $templateCache.put('ui-grid/ui-grid-filter', "<div class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\" ng-class=\"{'ui-grid-filter-cancel-button-hidden' : colFilter.disableCancelFilterButton === true }\"><div ng-if=\"colFilter.type !== 'select'\"><input type=\"text\" class=\"ui-grid-filter-input ui-grid-filter-input-{{$index}}\" ng-model=\"colFilter.term\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\" aria-label=\"{{colFilter.ariaLabel || aria.defaultFilterLabel}}\"><div role=\"button\" class=\"ui-grid-filter-button\" ng-click=\"removeFilter(colFilter, $index)\" ng-if=\"!colFilter.disableCancelFilterButton\" ng-disabled=\"colFilter.term === undefined || colFilter.term === null || colFilter.term === ''\" ng-show=\"colFilter.term !== undefined && colFilter.term !== null && colFilter.term !== ''\"><i class=\"ui-grid-icon-cancel\" ui-grid-one-bind-aria-label=\"aria.removeFilter\">&nbsp;</i></div></div><div ng-if=\"colFilter.type === 'select'\"><select class=\"ui-grid-filter-select ui-grid-filter-input-{{$index}}\" ng-model=\"colFilter.term\" ng-attr-placeholder=\"{{colFilter.placeholder || aria.defaultFilterLabel}}\" aria-label=\"{{colFilter.ariaLabel || ''}}\" ng-options=\"option.value as option.label for option in colFilter.selectOptions\"><option value=\"\"></option></select><div role=\"button\" class=\"ui-grid-filter-button-select\" ng-click=\"removeFilter(colFilter, $index)\" ng-if=\"!colFilter.disableCancelFilterButton\" ng-disabled=\"colFilter.term === undefined || colFilter.term === null || colFilter.term === ''\" ng-show=\"colFilter.term !== undefined && colFilter.term != null\"><i class=\"ui-grid-icon-cancel\" ui-grid-one-bind-aria-label=\"aria.removeFilter\">&nbsp;</i></div></div></div>");
    $templateCache.put('ui-grid/ui-grid-footer', "<div class=\"ui-grid-footer-panel ui-grid-footer-aggregates-row\"><!-- tfooter --><div class=\"ui-grid-footer ui-grid-footer-viewport\"><div class=\"ui-grid-footer-canvas\"><div class=\"ui-grid-footer-cell-wrapper\" ng-style=\"colContainer.headerCellWrapperStyle()\"><div role=\"row\" class=\"ui-grid-footer-cell-row\"><div ui-grid-footer-cell role=\"gridcell\" ng-repeat=\"col in colContainer.renderedColumns track by col.uid\" col=\"col\" render-index=\"$index\" class=\"ui-grid-footer-cell ui-grid-clearfix\"></div></div></div></div></div></div>");
    $templateCache.put('ui-grid/ui-grid-grid-footer', "<div class=\"ui-grid-footer-info ui-grid-grid-footer\"><span>{{'search.totalItems' | t}} {{grid.rows.length}}</span> <span ng-if=\"grid.renderContainers.body.visibleRowCache.length !== grid.rows.length\" class=\"ngLabel\">({{\"search.showingItems\" | t}} {{grid.renderContainers.body.visibleRowCache.length}})</span></div>");
    $templateCache.put('ui-grid/ui-grid-group-panel', "<div class=\"ui-grid-group-panel\"><div ui-t=\"groupPanel.description\" class=\"description\" ng-show=\"groupings.length == 0\"></div><ul ng-show=\"groupings.length > 0\" class=\"ngGroupList\"><li class=\"ngGroupItem\" ng-repeat=\"group in configGroups\"><span class=\"ngGroupElement\"><span class=\"ngGroupName\">{{group.displayName}} <span ng-click=\"removeGroup($index)\" class=\"ngRemoveGroup\">x</span></span> <span ng-hide=\"$last\" class=\"ngGroupArrow\"></span></span></li></ul></div>");
    $templateCache.put('ui-grid/ui-grid-header', "<div role=\"rowgroup\" class=\"ui-grid-header\"><!-- theader --><div class=\"ui-grid-top-panel\"><div class=\"ui-grid-header-viewport\"><div class=\"ui-grid-header-canvas\"><div class=\"ui-grid-header-cell-wrapper\" ng-style=\"colContainer.headerCellWrapperStyle()\"><div role=\"row\" class=\"ui-grid-header-cell-row\"><div class=\"ui-grid-header-cell ui-grid-clearfix\" ng-repeat=\"col in colContainer.renderedColumns track by col.uid\" ui-grid-header-cell col=\"col\" render-index=\"$index\"></div></div></div></div></div></div></div>");
    $templateCache.put('ui-grid/ui-grid-menu-button', "<div class=\"ui-grid-menu-button\"><div role=\"button\" ui-grid-one-bind-id-grid=\"'grid-menu'\" class=\"ui-grid-icon-container\" ng-click=\"toggleMenu()\" aria-haspopup=\"true\"><i class=\"ui-grid-icon-menu\" ui-grid-one-bind-aria-label=\"i18n.aria.buttonLabel\">&nbsp;</i></div><div ui-grid-menu menu-items=\"menuItems\"></div></div>");
    $templateCache.put('ui-grid/ui-grid-no-header', "<div class=\"ui-grid-top-panel\"></div>");
    $templateCache.put('ui-grid/ui-grid-row', "<div ng-repeat=\"(colRenderIndex, col) in colContainer.renderedColumns track by col.uid\" ui-grid-one-bind-id-grid=\"rowRenderIndex + '-' + col.uid + '-cell'\" class=\"ui-grid-cell\" ng-class=\"{ 'ui-grid-row-header-cell': col.isRowHeader }\" role=\"{{col.isRowHeader ? 'rowheader' : 'gridcell'}}\" ui-grid-cell></div>");
    $templateCache.put('ui-grid/ui-grid', "<div ui-i18n=\"en\" class=\"ui-grid\"><!-- TODO (c0bra): add \"scoped\" attr here, eventually? --><style ui-grid-style>.grid{{ grid.id }} {\n" + "      /* Styles for the grid */\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row, .grid{{ grid.id }} .ui-grid-cell, .grid{{ grid.id }} .ui-grid-cell .ui-grid-vertical-bar {\n" + "      height: {{ grid.options.rowHeight }}px;\n" + "    }\n" + "\n" + "    .grid{{ grid.id }} .ui-grid-row:last-child .ui-grid-cell {\n" + "      border-bottom-width: {{ ((grid.getTotalRowHeight() < grid.getViewportHeight()) && '1') || '0' }}px;\n" + "    }\n" + "\n" + "    {{ grid.verticalScrollbarStyles }}\n" + "    {{ grid.horizontalScrollbarStyles }}\n" + "\n" + "    /*\n" + "    .ui-grid[dir=rtl] .ui-grid-viewport {\n" + "      padding-left: {{ grid.verticalScrollbarWidth }}px;\n" + "    }\n" + "    */\n" + "\n" + "    {{ grid.customStyles }}</style><div class=\"ui-grid-contents-wrapper\"><div ui-grid-menu-button ng-if=\"grid.options.enableGridMenu\"></div><div ng-if=\"grid.hasLeftContainer()\" style=\"width: 0\" ui-grid-pinned-container=\"'left'\"></div><div ui-grid-render-container container-id=\"'body'\" col-container-name=\"'body'\" row-container-name=\"'body'\" bind-scroll-horizontal=\"true\" bind-scroll-vertical=\"true\" enable-horizontal-scrollbar=\"grid.options.enableHorizontalScrollbar\" enable-vertical-scrollbar=\"grid.options.enableVerticalScrollbar\"></div><div ng-if=\"grid.hasRightContainer()\" style=\"width: 0\" ui-grid-pinned-container=\"'right'\"></div><div ui-grid-grid-footer ng-if=\"grid.options.showGridFooter\"></div><div ui-grid-column-menu ng-if=\"grid.options.enableColumnMenus\"></div><div ng-transclude></div></div></div>");
    $templateCache.put('ui-grid/uiGridCell', "<div class=\"ui-grid-cell-contents\" title=\"TOOLTIP\">{{COL_FIELD CUSTOM_FILTERS}}</div>");
    $templateCache.put('ui-grid/uiGridColumnMenu', "<div class=\"ui-grid-column-menu\"><div ui-grid-menu menu-items=\"menuItems\"><!-- <div class=\"ui-grid-column-menu\">\n" + "    <div class=\"inner\" ng-show=\"menuShown\">\n" + "      <ul>\n" + "        <div ng-show=\"grid.options.enableSorting\">\n" + "          <li ng-click=\"sortColumn($event, asc)\" ng-class=\"{ 'selected' : col.sort.direction == asc }\"><i class=\"ui-grid-icon-sort-alt-up\"></i> Sort Ascending</li>\n" + "          <li ng-click=\"sortColumn($event, desc)\" ng-class=\"{ 'selected' : col.sort.direction == desc }\"><i class=\"ui-grid-icon-sort-alt-down\"></i> Sort Descending</li>\n" + "          <li ng-show=\"col.sort.direction\" ng-click=\"unsortColumn()\"><i class=\"ui-grid-icon-cancel\"></i> Remove Sort</li>\n" + "        </div>\n" + "      </ul>\n" + "    </div>\n" + "  </div> --></div></div>");
    $templateCache.put('ui-grid/uiGridFooterCell', "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\"><div>{{ col.getAggregationText() + ( col.getAggregationValue() CUSTOM_FILTERS ) }}</div></div>");
    $templateCache.put('ui-grid/uiGridHeaderCell', "<div role=\"columnheader\" ng-class=\"{ 'sortable': sortable }\" ui-grid-one-bind-aria-labelledby-grid=\"col.uid + '-header-text ' + col.uid + '-sortdir-text'\" aria-sort=\"{{col.sort.direction == asc ? 'ascending' : ( col.sort.direction == desc ? 'descending' : (!col.sort.direction ? 'none' : 'other'))}}\"><div role=\"button\" tabindex=\"0\" class=\"ui-grid-cell-contents ui-grid-header-cell-primary-focus\" col-index=\"renderIndex\" title=\"TOOLTIP\"><span ui-grid-one-bind-id-grid=\"col.uid + '-header-text'\">{{ col.displayName CUSTOM_FILTERS }}</span> <span ui-grid-one-bind-id-grid=\"col.uid + '-sortdir-text'\" ui-grid-visible=\"col.sort.direction\" aria-label=\"{{getSortDirectionAriaLabel()}}\"><i ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\" title=\"{{col.sort.priority ? i18n.headerCell.priority + ' ' + col.sort.priority : null}}\" aria-hidden=\"true\">&nbsp;</i></span></div><div role=\"button\" tabindex=\"0\" ui-grid-one-bind-id-grid=\"col.uid + '-menu-button'\" class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" ng-click=\"toggleMenu($event)\" ng-class=\"{'ui-grid-column-menu-button-last-col': isLastCol}\" ui-grid-one-bind-aria-label=\"i18n.headerCell.aria.columnMenuButtonLabel\" aria-haspopup=\"true\"><i class=\"ui-grid-icon-angle-down\" aria-hidden=\"true\">&nbsp;</i></div><div ui-grid-filter></div></div>");
    $templateCache.put('ui-grid/uiGridMenu', "<div class=\"ui-grid-menu\" ng-if=\"shown\"><div class=\"ui-grid-menu-mid\" ng-show=\"shownMid\"><div class=\"ui-grid-menu-inner\"><button type=\"button\" ng-focus=\"focus=true\" ng-blur=\"focus=false\" class=\"ui-grid-menu-close-button\" ng-class=\"{'ui-grid-sr-only': (!focus)}\"><i class=\"ui-grid-icon-cancel\" ui-grid-one-bind-aria-label=\"i18n.close\"></i></button><ul role=\"menu\" class=\"ui-grid-menu-items\"><li ng-repeat=\"item in menuItems\" role=\"menuitem\" ui-grid-menu-item ui-grid-one-bind-id=\"'menuitem-'+$index\" action=\"item.action\" name=\"item.title\" active=\"item.active\" icon=\"item.icon\" shown=\"item.shown\" context=\"item.context\" template-url=\"item.templateUrl\" leave-open=\"item.leaveOpen\" screen-reader-only=\"item.screenReaderOnly\"></li></ul></div></div></div>");
    $templateCache.put('ui-grid/uiGridMenuItem', "<button type=\"button\" class=\"ui-grid-menu-item\" ng-click=\"itemAction($event, title)\" ng-show=\"itemShown()\" ng-class=\"{ 'ui-grid-menu-item-active': active(), 'ui-grid-sr-only': (!focus && screenReaderOnly) }\" aria-pressed=\"{{active()}}\" tabindex=\"0\" ng-focus=\"focus=true\" ng-blur=\"focus=false\"><i ng-class=\"icon\" aria-hidden=\"true\">&nbsp;</i> {{ name }}</button>");
    $templateCache.put('ui-grid/uiGridRenderContainer', "<div role=\"grid\" ui-grid-one-bind-id-grid=\"'grid-container'\" class=\"ui-grid-render-container\" ng-style=\"{ 'margin-left': colContainer.getMargin('left') + 'px', 'margin-right': colContainer.getMargin('right') + 'px' }\"><!-- All of these dom elements are replaced in place --><div ui-grid-header></div><div ui-grid-viewport></div><div ng-if=\"colContainer.needsHScrollbarPlaceholder()\" class=\"ui-grid-scrollbar-placeholder\" ng-style=\"{height:colContainer.grid.scrollbarHeight + 'px'}\"></div><ui-grid-footer ng-if=\"grid.options.showColumnFooter\"></ui-grid-footer></div>");
    $templateCache.put('ui-grid/uiGridViewport', "<div role=\"rowgroup\" class=\"ui-grid-viewport\" ng-style=\"colContainer.getViewportStyle()\"><!-- tbody --><div class=\"ui-grid-canvas\"><div ng-repeat=\"(rowRenderIndex, row) in rowContainer.renderedRows track by $index\" class=\"ui-grid-row\" ng-style=\"Viewport.rowStyle(rowRenderIndex)\"><div role=\"row\" ui-grid-row=\"row\" row-render-index=\"rowRenderIndex\"></div></div></div></div>");
    $templateCache.put('ui-grid/cellEditor', "<div><form name=\"inputForm\"><input type=\"INPUT_TYPE\" ng-class=\"'colt' + col.uid\" ui-grid-editor ng-model=\"MODEL_COL_FIELD\"></form></div>");
    $templateCache.put('ui-grid/dropdownEditor', "<div><form name=\"inputForm\"><select ng-class=\"'colt' + col.uid\" ui-grid-edit-dropdown ng-model=\"MODEL_COL_FIELD\" ng-options=\"field[editDropdownIdLabel] as field[editDropdownValueLabel] CUSTOM_FILTERS for field in editDropdownOptionsArray\"></select></form></div>");
    $templateCache.put('ui-grid/fileChooserEditor', "<div><form name=\"inputForm\"><input ng-class=\"'colt' + col.uid\" ui-grid-edit-file-chooser type=\"file\" id=\"files\" name=\"files[]\" ng-model=\"MODEL_COL_FIELD\"></form></div>");
    $templateCache.put('ui-grid/expandableRow', "<div ui-grid-expandable-row ng-if=\"expandableRow.shouldRenderExpand()\" class=\"expandableRow\" style=\"float:left; margin-top: 1px; margin-bottom: 1px\" ng-style=\"{width: (grid.renderContainers.body.getCanvasWidth()) + 'px', height: grid.options.expandableRowHeight + 'px'}\"></div>");
    $templateCache.put('ui-grid/expandableRowHeader', "<div class=\"ui-grid-row-header-cell ui-grid-expandable-buttons-cell\"><div class=\"ui-grid-cell-contents\"><i ng-class=\"{ 'ui-grid-icon-plus-squared' : !row.isExpanded, 'ui-grid-icon-minus-squared' : row.isExpanded }\" ng-click=\"grid.api.expandable.toggleRowExpansion(row.entity)\"></i></div></div>");
    $templateCache.put('ui-grid/expandableScrollFiller', "<div ng-if=\"expandableRow.shouldRenderFiller()\" ng-class=\"{scrollFiller:true, scrollFillerClass:(colContainer.name === 'body')}\" ng-style=\"{ width: (grid.getViewportWidth()) + 'px', height: grid.options.expandableRowHeight + 2 + 'px', 'margin-left': grid.options.rowHeader.rowHeaderWidth + 'px' }\"><i class=\"ui-grid-icon-spin5 ui-grid-animate-spin\" ng-style=\"{'margin-top': ( grid.options.expandableRowHeight/2 - 5) + 'px', 'margin-left' : ((grid.getViewportWidth() - grid.options.rowHeader.rowHeaderWidth)/2 - 5) + 'px'}\"></i></div>");
    $templateCache.put('ui-grid/expandableTopRowHeader', "<div class=\"ui-grid-row-header-cell ui-grid-expandable-buttons-cell\"><div class=\"ui-grid-cell-contents\"><i ng-class=\"{ 'ui-grid-icon-plus-squared' : !grid.expandable.expandedAll, 'ui-grid-icon-minus-squared' : grid.expandable.expandedAll }\" ng-click=\"grid.api.expandable.toggleAllRows()\"></i></div></div>");
    $templateCache.put('ui-grid/csvLink', "<span class=\"ui-grid-exporter-csv-link-span\"><a href=\"data:text/csv;charset=UTF-8,CSV_CONTENT\" download=\"FILE_NAME\">LINK_LABEL</a></span>");
    $templateCache.put('ui-grid/importerMenuItem', "<li class=\"ui-grid-menu-item\"><form><input class=\"ui-grid-importer-file-chooser\" type=\"file\" id=\"files\" name=\"files[]\"></form></li>");
    $templateCache.put('ui-grid/importerMenuItemContainer', "<div ui-grid-importer-menu-item></div>");
    $templateCache.put('ui-grid/pagination', "<div role=\"contentinfo\" class=\"ui-grid-pager-panel\" ui-grid-pager ng-show=\"grid.options.enablePaginationControls\"><div role=\"navigation\" class=\"ui-grid-pager-container\"><div role=\"menubar\" class=\"ui-grid-pager-control\"><button type=\"button\" role=\"menuitem\" class=\"ui-grid-pager-first\" ui-grid-one-bind-title=\"aria.pageToFirst\" ui-grid-one-bind-aria-label=\"aria.pageToFirst\" ng-click=\"pageFirstPageClick()\" ng-disabled=\"cantPageBackward()\"><div class=\"first-triangle\"><div class=\"first-bar\"></div></div></button> <button type=\"button\" role=\"menuitem\" class=\"ui-grid-pager-previous\" ui-grid-one-bind-title=\"aria.pageBack\" ui-grid-one-bind-aria-label=\"aria.pageBack\" ng-click=\"pagePreviousPageClick()\" ng-disabled=\"cantPageBackward()\"><div class=\"first-triangle prev-triangle\"></div></button> <input type=\"number\" ui-grid-one-bind-title=\"aria.pageSelected\" ui-grid-one-bind-aria-label=\"aria.pageSelected\" class=\"ui-grid-pager-control-input\" ng-model=\"grid.options.paginationCurrentPage\" min=\"1\" max=\"{{ paginationApi.getTotalPages() }}\" required> <span class=\"ui-grid-pager-max-pages-number\" ng-show=\"paginationApi.getTotalPages() > 0\"><abbr ui-grid-one-bind-title=\"paginationOf\">/</abbr> {{ paginationApi.getTotalPages() }}</span> <button type=\"button\" role=\"menuitem\" class=\"ui-grid-pager-next\" ui-grid-one-bind-title=\"aria.pageForward\" ui-grid-one-bind-aria-label=\"aria.pageForward\" ng-click=\"pageNextPageClick()\" ng-disabled=\"cantPageForward()\"><div class=\"last-triangle next-triangle\"></div></button> <button type=\"button\" role=\"menuitem\" class=\"ui-grid-pager-last\" ui-grid-one-bind-title=\"aria.pageToLast\" ui-grid-one-bind-aria-label=\"aria.pageToLast\" ng-click=\"pageLastPageClick()\" ng-disabled=\"cantPageToLast()\"><div class=\"last-triangle\"><div class=\"last-bar\"></div></div></button></div><div class=\"ui-grid-pager-row-count-picker\" ng-if=\"grid.options.paginationPageSizes.length > 1\"><select ui-grid-one-bind-aria-labelledby-grid=\"'items-per-page-label'\" ng-model=\"grid.options.paginationPageSize\" ng-options=\"o as o for o in grid.options.paginationPageSizes\"></select><span ui-grid-one-bind-id-grid=\"'items-per-page-label'\" class=\"ui-grid-pager-row-count-label\">&nbsp;{{sizesLabel}}</span></div><span ng-if=\"grid.options.paginationPageSizes.length <= 1\" class=\"ui-grid-pager-row-count-label\">{{grid.options.paginationPageSize}}&nbsp;{{sizesLabel}}</span></div><div class=\"ui-grid-pager-count-container\"><div class=\"ui-grid-pager-count\"><span ng-show=\"grid.options.totalItems > 0\">{{showingLow}} <abbr ui-grid-one-bind-title=\"paginationThrough\">-</abbr> {{showingHigh}} {{paginationOf}} {{grid.options.totalItems}} {{totalItemsLabel}}</span></div></div></div>");
    $templateCache.put('ui-grid/columnResizer', "<div ui-grid-column-resizer ng-if=\"grid.options.enableColumnResizing\" class=\"ui-grid-column-resizer\" col=\"col\" position=\"right\" render-index=\"renderIndex\" unselectable=\"on\"></div>");
    $templateCache.put('ui-grid/gridFooterSelectedItems', "<span ng-if=\"grid.selection.selectedCount !== 0 && grid.options.enableFooterTotalSelected\">({{\"search.selectedItems\" | t}} {{grid.selection.selectedCount}})</span>");
    $templateCache.put('ui-grid/selectionHeaderCell', "<div><!-- <div class=\"ui-grid-vertical-bar\">&nbsp;</div> --><div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\"><ui-grid-selection-select-all-buttons ng-if=\"grid.options.enableSelectAll\"></ui-grid-selection-select-all-buttons></div></div>");
    $templateCache.put('ui-grid/selectionRowHeader', "<div class=\"ui-grid-disable-selection\"><div class=\"ui-grid-cell-contents\"><ui-grid-selection-row-header-buttons></ui-grid-selection-row-header-buttons></div></div>");
    $templateCache.put('ui-grid/selectionRowHeaderButtons', "<div class=\"ui-grid-selection-row-header-buttons ui-grid-icon-ok\" ng-class=\"{'ui-grid-row-selected': row.isSelected}\" ng-click=\"selectButtonClick(row, $event)\">&nbsp;</div>");
    $templateCache.put('ui-grid/selectionSelectAllButtons', "<div class=\"ui-grid-selection-row-header-buttons ui-grid-icon-ok\" ng-class=\"{'ui-grid-all-selected': grid.selection.selectAll}\" ng-click=\"headerButtonClick($event)\"></div>");
    $templateCache.put('ui-grid/treeBaseExpandAllButtons', "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-icon-minus-squared': grid.treeBase.numberLevels > 0 && grid.treeBase.expandAll, 'ui-grid-icon-plus-squared': grid.treeBase.numberLevels > 0 && !grid.treeBase.expandAll}\" ng-click=\"headerButtonClick($event)\"></div>");
    $templateCache.put('ui-grid/treeBaseHeaderCell', "<div><div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\"><ui-grid-tree-base-expand-all-buttons></ui-grid-tree-base-expand-all-buttons></div></div>");
    $templateCache.put('ui-grid/treeBaseRowHeader', "<div class=\"ui-grid-cell-contents\"><ui-grid-tree-base-row-header-buttons></ui-grid-tree-base-row-header-buttons></div>");
    $templateCache.put('ui-grid/treeBaseRowHeaderButtons', "<div class=\"ui-grid-tree-base-row-header-buttons\" ng-class=\"{'ui-grid-tree-base-header': row.treeLevel > -1 }\" ng-click=\"treeButtonClick(row, $event)\"><i ng-class=\"{'ui-grid-icon-minus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'expanded', 'ui-grid-icon-plus-squared': ( ( grid.options.showTreeExpandNoChildren && row.treeLevel > -1 ) || ( row.treeNode.children && row.treeNode.children.length > 0 ) ) && row.treeNode.state === 'collapsed'}\" ng-style=\"{'padding-left': grid.options.treeIndent * row.treeLevel + 'px'}\"></i> &nbsp;</div>");
  }]);
  global.define = __define;
  return module.exports;
});

System.register("github:angular-ui/bower-ui-grid@3.0.5", ["github:angular-ui/bower-ui-grid@3.0.5/ui-grid"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/bower-ui-grid@3.0.5/ui-grid");
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:validate.js@0.8.0/validate", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function(exports, module, define) {
      "use strict";
      var validate = function(attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options),
            attr,
            validator;
        for (attr in results) {
          for (validator in results[attr]) {
            if (v.isPromise(results[attr][validator])) {
              throw new Error("Use validate.async if you want support for promises");
            }
          }
        }
        return validate.processValidationResults(results, options);
      };
      var v = validate;
      v.extend = function(obj) {
        [].slice.call(arguments, 1).forEach(function(source) {
          for (var attr in source) {
            obj[attr] = source[attr];
          }
        });
        return obj;
      };
      v.extend(validate, {
        version: {
          major: 0,
          minor: 8,
          patch: 0,
          metadata: "",
          toString: function() {
            var version = v.format("%{major}.%{minor}.%{patch}", v.version);
            if (!v.isEmpty(v.version.metadata)) {
              version += "+" + v.version.metadata;
            }
            return version;
          }
        },
        Promise: typeof Promise !== "undefined" ? Promise : null,
        moment: typeof moment !== "undefined" ? moment : null,
        XDate: typeof XDate !== "undefined" ? XDate : null,
        EMPTY_STRING_REGEXP: /^\s*$/,
        runValidations: function(attributes, constraints, options) {
          var results = [],
              attr,
              validatorName,
              value,
              validators,
              validator,
              validatorOptions,
              error;
          if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
            attributes = v.collectFormValues(attributes);
          }
          for (attr in constraints) {
            value = v.getDeepObjectValue(attributes, attr);
            validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
            for (validatorName in validators) {
              validator = v.validators[validatorName];
              if (!validator) {
                error = v.format("Unknown validator %{name}", {name: validatorName});
                throw new Error(error);
              }
              validatorOptions = validators[validatorName];
              validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
              if (!validatorOptions) {
                continue;
              }
              results.push({
                attribute: attr,
                value: value,
                validator: validatorName,
                options: validatorOptions,
                error: validator.call(validator, value, validatorOptions, attr, attributes)
              });
            }
          }
          return results;
        },
        processValidationResults: function(errors, options) {
          var attr;
          errors = v.pruneEmptyErrors(errors, options);
          errors = v.expandMultipleErrors(errors, options);
          errors = v.convertErrorMessages(errors, options);
          switch (options.format || "grouped") {
            case "detailed":
              break;
            case "flat":
              errors = v.flattenErrorsToArray(errors);
              break;
            case "grouped":
              errors = v.groupErrorsByAttribute(errors);
              for (attr in errors) {
                errors[attr] = v.flattenErrorsToArray(errors[attr]);
              }
              break;
            default:
              throw new Error(v.format("Unknown format %{format}", options));
          }
          return v.isEmpty(errors) ? undefined : errors;
        },
        async: function(attributes, constraints, options) {
          options = v.extend({}, v.async.options, options);
          var WrapErrors = options.wrapErrors || function(errors) {
            return errors;
          };
          if (options.cleanAttributes !== false) {
            attributes = v.cleanAttributes(attributes, constraints);
          }
          var results = v.runValidations(attributes, constraints, options);
          return new v.Promise(function(resolve, reject) {
            v.waitForResults(results).then(function() {
              var errors = v.processValidationResults(results, options);
              if (errors) {
                reject(new WrapErrors(errors, options, attributes, constraints));
              } else {
                resolve(attributes);
              }
            }, function(err) {
              reject(err);
            });
          });
        },
        single: function(value, constraints, options) {
          options = v.extend({}, v.single.options, options, {
            format: "flat",
            fullMessages: false
          });
          return v({single: value}, {single: constraints}, options);
        },
        waitForResults: function(results) {
          return results.reduce(function(memo, result) {
            if (!v.isPromise(result.error)) {
              return memo;
            }
            return memo.then(function() {
              return result.error.then(function(error) {
                result.error = error || null;
              }, function(error) {
                if (error instanceof Error) {
                  throw error;
                }
                console.log("Foo");
                v.error("Rejecting promises with the result is deprecated. Please use the resolve callback instead.");
                result.error = error;
              });
            });
          }, new v.Promise(function(r) {
            r();
          }));
        },
        result: function(value) {
          var args = [].slice.call(arguments, 1);
          if (typeof value === 'function') {
            value = value.apply(null, args);
          }
          return value;
        },
        isNumber: function(value) {
          return typeof value === 'number' && !isNaN(value);
        },
        isFunction: function(value) {
          return typeof value === 'function';
        },
        isInteger: function(value) {
          return v.isNumber(value) && value % 1 === 0;
        },
        isObject: function(obj) {
          return obj === Object(obj);
        },
        isDate: function(obj) {
          return obj instanceof Date;
        },
        isDefined: function(obj) {
          return obj !== null && obj !== undefined;
        },
        isPromise: function(p) {
          return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function(o) {
          return o && v.isString(o.jquery);
        },
        isDomElement: function(o) {
          if (!o) {
            return false;
          }
          if (!v.isFunction(o.querySelectorAll) || !v.isFunction(o.querySelector)) {
            return false;
          }
          if (v.isObject(document) && o === document) {
            return true;
          }
          if (typeof HTMLElement === "object") {
            return o instanceof HTMLElement;
          } else {
            return o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
          }
        },
        isEmpty: function(value) {
          var attr;
          if (!v.isDefined(value)) {
            return true;
          }
          if (v.isFunction(value)) {
            return false;
          }
          if (v.isString(value)) {
            return v.EMPTY_STRING_REGEXP.test(value);
          }
          if (v.isArray(value)) {
            return value.length === 0;
          }
          if (v.isDate(value)) {
            return false;
          }
          if (v.isObject(value)) {
            for (attr in value) {
              return false;
            }
            return true;
          }
          return false;
        },
        format: v.extend(function(str, vals) {
          return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
            if (m1 === '%') {
              return "%{" + m2 + "}";
            } else {
              return String(vals[m2]);
            }
          });
        }, {FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g}),
        prettify: function(str) {
          if (v.isNumber(str)) {
            if ((str * 100) % 1 === 0) {
              return "" + str;
            } else {
              return parseFloat(Math.round(str * 100) / 100).toFixed(2);
            }
          }
          if (v.isArray(str)) {
            return str.map(function(s) {
              return v.prettify(s);
            }).join(", ");
          }
          if (v.isObject(str)) {
            return str.toString();
          }
          str = "" + str;
          return str.replace(/([^\s])\.([^\s])/g, '$1 $2').replace(/\\+/g, '').replace(/[_-]/g, ' ').replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
            return "" + m1 + " " + m2.toLowerCase();
          }).toLowerCase();
        },
        stringifyValue: function(value) {
          return v.prettify(value);
        },
        isString: function(value) {
          return typeof value === 'string';
        },
        isArray: function(value) {
          return {}.toString.call(value) === '[object Array]';
        },
        contains: function(obj, value) {
          if (!v.isDefined(obj)) {
            return false;
          }
          if (v.isArray(obj)) {
            return obj.indexOf(value) !== -1;
          }
          return value in obj;
        },
        forEachKeyInKeypath: function(object, keypath, callback) {
          if (!v.isString(keypath)) {
            return undefined;
          }
          var key = "",
              i,
              escape = false;
          for (i = 0; i < keypath.length; ++i) {
            switch (keypath[i]) {
              case '.':
                if (escape) {
                  escape = false;
                  key += '.';
                } else {
                  object = callback(object, key, false);
                  key = "";
                }
                break;
              case '\\':
                if (escape) {
                  escape = false;
                  key += '\\';
                } else {
                  escape = true;
                }
                break;
              default:
                escape = false;
                key += keypath[i];
                break;
            }
          }
          return callback(object, key, true);
        },
        getDeepObjectValue: function(obj, keypath) {
          if (!v.isObject(obj)) {
            return undefined;
          }
          return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {
            if (v.isObject(obj)) {
              return obj[key];
            }
          });
        },
        collectFormValues: function(form, options) {
          var values = {},
              i,
              input,
              inputs,
              value;
          if (v.isJqueryElement(form)) {
            form = form[0];
          }
          if (!form) {
            return values;
          }
          options = options || {};
          inputs = form.querySelectorAll("input[name], textarea[name]");
          for (i = 0; i < inputs.length; ++i) {
            input = inputs.item(i);
            if (v.isDefined(input.getAttribute("data-ignored"))) {
              continue;
            }
            value = v.sanitizeFormValue(input.value, options);
            if (input.type === "number") {
              value = +value;
            } else if (input.type === "checkbox") {
              if (input.attributes.value) {
                if (!input.checked) {
                  value = values[input.name] || null;
                }
              } else {
                value = input.checked;
              }
            } else if (input.type === "radio") {
              if (!input.checked) {
                value = values[input.name] || null;
              }
            }
            values[input.name] = value;
          }
          inputs = form.querySelectorAll("select[name]");
          for (i = 0; i < inputs.length; ++i) {
            input = inputs.item(i);
            value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
            values[input.name] = value;
          }
          return values;
        },
        sanitizeFormValue: function(value, options) {
          if (options.trim && v.isString(value)) {
            value = value.trim();
          }
          if (options.nullify !== false && value === "") {
            return null;
          }
          return value;
        },
        capitalize: function(str) {
          if (!v.isString(str)) {
            return str;
          }
          return str[0].toUpperCase() + str.slice(1);
        },
        pruneEmptyErrors: function(errors) {
          return errors.filter(function(error) {
            return !v.isEmpty(error.error);
          });
        },
        expandMultipleErrors: function(errors) {
          var ret = [];
          errors.forEach(function(error) {
            if (v.isArray(error.error)) {
              error.error.forEach(function(msg) {
                ret.push(v.extend({}, error, {error: msg}));
              });
            } else {
              ret.push(error);
            }
          });
          return ret;
        },
        convertErrorMessages: function(errors, options) {
          options = options || {};
          var ret = [];
          errors.forEach(function(errorInfo) {
            var error = errorInfo.error;
            if (error[0] === '^') {
              error = error.slice(1);
            } else if (options.fullMessages !== false) {
              error = v.capitalize(v.prettify(errorInfo.attribute)) + " " + error;
            }
            error = error.replace(/\\\^/g, "^");
            error = v.format(error, {value: v.stringifyValue(errorInfo.value)});
            ret.push(v.extend({}, errorInfo, {error: error}));
          });
          return ret;
        },
        groupErrorsByAttribute: function(errors) {
          var ret = {};
          errors.forEach(function(error) {
            var list = ret[error.attribute];
            if (list) {
              list.push(error);
            } else {
              ret[error.attribute] = [error];
            }
          });
          return ret;
        },
        flattenErrorsToArray: function(errors) {
          return errors.map(function(error) {
            return error.error;
          });
        },
        cleanAttributes: function(attributes, whitelist) {
          function whitelistCreator(obj, key, last) {
            if (v.isObject(obj[key])) {
              return obj[key];
            }
            return (obj[key] = last ? true : {});
          }
          function buildObjectWhitelist(whitelist) {
            var ow = {},
                lastObject,
                attr;
            for (attr in whitelist) {
              if (!whitelist[attr]) {
                continue;
              }
              v.forEachKeyInKeypath(ow, attr, whitelistCreator);
            }
            return ow;
          }
          function cleanRecursive(attributes, whitelist) {
            if (!v.isObject(attributes)) {
              return attributes;
            }
            var ret = v.extend({}, attributes),
                w,
                attribute;
            for (attribute in attributes) {
              w = whitelist[attribute];
              if (v.isObject(w)) {
                ret[attribute] = cleanRecursive(ret[attribute], w);
              } else if (!w) {
                delete ret[attribute];
              }
            }
            return ret;
          }
          if (!v.isObject(whitelist) || !v.isObject(attributes)) {
            return {};
          }
          whitelist = buildObjectWhitelist(whitelist);
          return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function(validate, root, exports, module, define) {
          if (exports) {
            if (module && module.exports) {
              exports = module.exports = validate;
            }
            exports.validate = validate;
          } else {
            root.validate = validate;
            if (validate.isFunction(define) && define.amd) {
              define([], function() {
                return validate;
              });
            }
          }
        },
        warn: function(msg) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn("[validate.js] " + msg);
          }
        },
        error: function(msg) {
          if (typeof console !== "undefined" && console.error) {
            console.error("[validate.js] " + msg);
          }
        }
      });
      validate.validators = {
        presence: function(value, options) {
          options = v.extend({}, this.options, options);
          if (v.isEmpty(value)) {
            return options.message || this.message || "can't be blank";
          }
        },
        length: function(value, options, attribute) {
          if (v.isEmpty(value)) {
            return ;
          }
          options = v.extend({}, this.options, options);
          var is = options.is,
              maximum = options.maximum,
              minimum = options.minimum,
              tokenizer = options.tokenizer || function(val) {
                return val;
              },
              err,
              errors = [];
          value = tokenizer(value);
          var length = value.length;
          if (!v.isNumber(length)) {
            v.error(v.format("Attribute %{attr} has a non numeric value for `length`", {attr: attribute}));
            return options.message || this.notValid || "has an incorrect length";
          }
          if (v.isNumber(is) && length !== is) {
            err = options.wrongLength || this.wrongLength || "is the wrong length (should be %{count} characters)";
            errors.push(v.format(err, {count: is}));
          }
          if (v.isNumber(minimum) && length < minimum) {
            err = options.tooShort || this.tooShort || "is too short (minimum is %{count} characters)";
            errors.push(v.format(err, {count: minimum}));
          }
          if (v.isNumber(maximum) && length > maximum) {
            err = options.tooLong || this.tooLong || "is too long (maximum is %{count} characters)";
            errors.push(v.format(err, {count: maximum}));
          }
          if (errors.length > 0) {
            return options.message || errors;
          }
        },
        numericality: function(value, options) {
          if (v.isEmpty(value)) {
            return ;
          }
          options = v.extend({}, this.options, options);
          var errors = [],
              name,
              count,
              checks = {
                greaterThan: function(v, c) {
                  return v > c;
                },
                greaterThanOrEqualTo: function(v, c) {
                  return v >= c;
                },
                equalTo: function(v, c) {
                  return v === c;
                },
                lessThan: function(v, c) {
                  return v < c;
                },
                lessThanOrEqualTo: function(v, c) {
                  return v <= c;
                }
              };
          if (options.noStrings !== true && v.isString(value)) {
            value = +value;
          }
          if (!v.isNumber(value)) {
            return options.message || this.notValid || "is not a number";
          }
          if (options.onlyInteger && !v.isInteger(value)) {
            return options.message || this.notInteger || "must be an integer";
          }
          for (name in checks) {
            count = options[name];
            if (v.isNumber(count) && !checks[name](value, count)) {
              var msg = this["not" + v.capitalize(name)] || "must be %{type} %{count}";
              errors.push(v.format(msg, {
                count: count,
                type: v.prettify(name)
              }));
            }
          }
          if (options.odd && value % 2 !== 1) {
            errors.push(this.notOdd || "must be odd");
          }
          if (options.even && value % 2 !== 0) {
            errors.push(this.notEven || "must be even");
          }
          if (errors.length) {
            return options.message || errors;
          }
        },
        datetime: v.extend(function(value, options) {
          if (v.isEmpty(value)) {
            return ;
          }
          options = v.extend({}, this.options, options);
          var err,
              errors = [],
              earliest = options.earliest ? this.parse(options.earliest, options) : NaN,
              latest = options.latest ? this.parse(options.latest, options) : NaN;
          value = this.parse(value, options);
          if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
            return options.message || this.notValid || "must be a valid date";
          }
          if (!isNaN(earliest) && value < earliest) {
            err = this.tooEarly || "must be no earlier than %{date}";
            err = v.format(err, {date: this.format(earliest, options)});
            errors.push(err);
          }
          if (!isNaN(latest) && value > latest) {
            err = this.tooLate || "must be no later than %{date}";
            err = v.format(err, {date: this.format(latest, options)});
            errors.push(err);
          }
          if (errors.length) {
            return options.message || errors;
          }
        }, {
          parse: function(value, options) {
            if (v.isFunction(v.XDate)) {
              return new v.XDate(value, true).getTime();
            }
            if (v.isDefined(v.moment)) {
              return +v.moment.utc(value);
            }
            throw new Error("Neither XDate or moment.js was found");
          },
          format: function(date, options) {
            var format = options.dateFormat;
            if (v.isFunction(v.XDate)) {
              format = format || (options.dateOnly ? "yyyy-MM-dd" : "yyyy-MM-dd HH:mm:ss");
              return new v.XDate(date, true).toString(format);
            }
            if (v.isDefined(v.moment)) {
              format = format || (options.dateOnly ? "YYYY-MM-DD" : "YYYY-MM-DD HH:mm:ss");
              return v.moment.utc(date).format(format);
            }
            throw new Error("Neither XDate or moment.js was found");
          }
        }),
        date: function(value, options) {
          options = v.extend({}, options, {dateOnly: true});
          return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function(value, options) {
          if (v.isString(options) || (options instanceof RegExp)) {
            options = {pattern: options};
          }
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is invalid",
              pattern = options.pattern,
              match;
          if (v.isEmpty(value)) {
            return ;
          }
          if (!v.isString(value)) {
            return message;
          }
          if (v.isString(pattern)) {
            pattern = new RegExp(options.pattern, options.flags);
          }
          match = pattern.exec(value);
          if (!match || match[0].length != value.length) {
            return message;
          }
        },
        inclusion: function(value, options) {
          if (v.isEmpty(value)) {
            return ;
          }
          if (v.isArray(options)) {
            options = {within: options};
          }
          options = v.extend({}, this.options, options);
          if (v.contains(options.within, value)) {
            return ;
          }
          var message = options.message || this.message || "^%{value} is not included in the list";
          return v.format(message, {value: value});
        },
        exclusion: function(value, options) {
          if (v.isEmpty(value)) {
            return ;
          }
          if (v.isArray(options)) {
            options = {within: options};
          }
          options = v.extend({}, this.options, options);
          if (!v.contains(options.within, value)) {
            return ;
          }
          var message = options.message || this.message || "^%{value} is restricted";
          return v.format(message, {value: value});
        },
        email: v.extend(function(value, options) {
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is not a valid email";
          if (v.isEmpty(value)) {
            return ;
          }
          if (!v.isString(value)) {
            return message;
          }
          if (!this.PATTERN.exec(value)) {
            return message;
          }
        }, {PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i}),
        equality: function(value, options, attribute, attributes) {
          if (v.isEmpty(value)) {
            return ;
          }
          if (v.isString(options)) {
            options = {attribute: options};
          }
          options = v.extend({}, this.options, options);
          var message = options.message || this.message || "is not equal to %{attribute}";
          if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
            throw new Error("The attribute must be a non empty string");
          }
          var otherValue = v.getDeepObjectValue(attributes, options.attribute),
              comparator = options.comparator || function(v1, v2) {
                return v1 === v2;
              };
          if (!comparator(value, otherValue, options, attribute, attributes)) {
            return v.format(message, {attribute: v.prettify(options.attribute)});
          }
        }
      };
      validate.exposeModule(validate, this, exports, module, define);
    }).call(this, typeof exports !== 'undefined' ? exports : null, typeof module !== 'undefined' ? module : null, typeof define !== 'undefined' ? define : null);
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:validate.js@0.8.0", ["npm:validate.js@0.8.0/validate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:validate.js@0.8.0/validate");
  global.define = __define;
  return module.exports;
});

System.register("npm:js-data-schema@1.2.5/dist/js-data-schema", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
      module.exports = factory();
    else if (typeof define === 'function' && define.amd)
      define(factory);
    else if (typeof exports === 'object')
      exports["Schemator"] = factory();
    else
      root["Schemator"] = factory();
  })(this, function() {
    return (function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    })([function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {value: true});
      var _createClass = (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }
      var _utils = __webpack_require__(1);
      var _utils2 = _interopRequireDefault(_utils);
      var _dataTypes = __webpack_require__(47);
      var _dataTypes2 = _interopRequireDefault(_dataTypes);
      var _rules = __webpack_require__(48);
      var _rules2 = _interopRequireDefault(_rules);
      var _schema = __webpack_require__(49);
      var _schema2 = _interopRequireDefault(_schema);
      var id = 1;
      var Schemator = (function() {
        function Schemator() {
          _classCallCheck(this, Schemator);
          this.dataTypes = {};
          this.rules = {};
          this.schemata = {};
          this.id = id++;
        }
        _createClass(Schemator, [{
          key: 'availableDataTypes',
          value: function availableDataTypes() {
            return _utils2['default'].unique(_utils2['default'].keys(this.dataTypes).concat(_utils2['default'].keys(_dataTypes2['default'])));
          }
        }, {
          key: 'availableRules',
          value: function availableRules() {
            return _utils2['default'].unique(_utils2['default'].keys(this.rules).concat(_utils2['default'].keys(_rules2['default'])));
          }
        }, {
          key: 'availableSchemata',
          value: function availableSchemata() {
            return _utils2['default'].keys(this.schemata);
          }
        }, {
          key: 'defineDataType',
          value: function defineDataType(name, typeDefinition) {
            if (!_utils2['default'].isString(name)) {
              throw new Error('"name" must be a string!');
            } else if (!_utils2['default'].isFunction(typeDefinition)) {
              throw new Error('"typeDefinition" must be a function!');
            } else if (this.dataTypes[name]) {
              throw new Error('dataType already registered!');
            }
            this.dataTypes[name] = typeDefinition;
          }
        }, {
          key: 'defineRule',
          value: function defineRule(name, ruleFunc, async) {
            if (!_utils2['default'].isString(name)) {
              throw new Error('"name" must be a string!');
            } else if (!_utils2['default'].isFunction(ruleFunc)) {
              throw new Error('"ruleFunc" must be a function!');
            } else if (this.rules[name]) {
              throw new Error('rule already registered!');
            }
            this.rules[name] = ruleFunc;
            this.rules[name].async = !!async;
          }
        }, {
          key: 'defineSchema',
          value: function defineSchema(name, schema) {
            if (this.schemata[name]) {
              throw new Error('schema already registered!');
            } else if (schema instanceof _schema2['default']) {
              throw new Error('schema registered elsewhere!');
            }
            this.schemata[name] = new _schema2['default'](name, schema, this);
            this.schemata[name].parent = this;
            return this.schemata[name];
          }
        }, {
          key: 'getDataType',
          value: function getDataType(name) {
            return this.dataTypes[name] || _dataTypes2['default'][name];
          }
        }, {
          key: 'getRule',
          value: function getRule(name) {
            return this.rules[name] || _rules2['default'][name];
          }
        }, {
          key: 'getSchema',
          value: function getSchema(name) {
            return this.schemata[name];
          }
        }, {
          key: 'removeDataType',
          value: function removeDataType(name) {
            delete this.dataTypes[name];
          }
        }, {
          key: 'removeRule',
          value: function removeRule(name) {
            delete this.rules[name];
          }
        }, {
          key: 'removeSchema',
          value: function removeSchema(name) {
            delete this.schemata[name];
          }
        }, {
          key: 'schemaCheck',
          value: function schemaCheck(name) {
            if (!this.schemata[name]) {
              throw new Error('schema is not registered!');
            }
          }
        }, {
          key: 'validateSync',
          value: function validateSync(name, attrs, options) {
            this.schemaCheck(name);
            return this.schemata[name].validateSync(attrs, options);
          }
        }, {
          key: 'validate',
          value: function validate(name, attrs, options, cb) {
            this.schemaCheck(name);
            return this.schemata[name].validate(attrs, options, cb);
          }
        }, {
          key: 'addDefaultsToTarget',
          value: function addDefaultsToTarget(name, target, overwrite) {
            this.schemaCheck(name);
            return this.schemata[name].addDefaultsToTarget(target, overwrite);
          }
        }, {
          key: 'setDefaults',
          value: function setDefaults(name, attrs) {
            this.schemaCheck(name);
            return this.schemata[name].setDefaults(attrs);
          }
        }, {
          key: 'getDefaults',
          value: function getDefaults(name) {
            this.schemaCheck(name);
            return this.schemata[name].getDefaults();
          }
        }, {
          key: 'stripNonSchemaAttrs',
          value: function stripNonSchemaAttrs(name, attrs) {
            this.schemaCheck(name);
            return this.schemata[name].stripNonSchemaAttrs(attrs);
          }
        }]);
        return Schemator;
      })();
      exports['default'] = Schemator;
      module.exports = exports['default'];
    }, function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {value: true});
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var _moutLangIsString = __webpack_require__(7);
      var _moutLangIsString2 = _interopRequireDefault(_moutLangIsString);
      var _moutLangIsBoolean = __webpack_require__(10);
      var _moutLangIsBoolean2 = _interopRequireDefault(_moutLangIsBoolean);
      var _moutLangIsNumber = __webpack_require__(11);
      var _moutLangIsNumber2 = _interopRequireDefault(_moutLangIsNumber);
      var _moutLangIsObject = __webpack_require__(12);
      var _moutLangIsObject2 = _interopRequireDefault(_moutLangIsObject);
      var _moutLangIsDate = __webpack_require__(13);
      var _moutLangIsDate2 = _interopRequireDefault(_moutLangIsDate);
      var _moutLangIsFunction = __webpack_require__(14);
      var _moutLangIsFunction2 = _interopRequireDefault(_moutLangIsFunction);
      var _moutLangIsUndefined = __webpack_require__(15);
      var _moutLangIsUndefined2 = _interopRequireDefault(_moutLangIsUndefined);
      var _moutLangIsArray = __webpack_require__(16);
      var _moutLangIsArray2 = _interopRequireDefault(_moutLangIsArray);
      var _moutLangIsEmpty = __webpack_require__(17);
      var _moutLangIsEmpty2 = _interopRequireDefault(_moutLangIsEmpty);
      var _moutLangToString = __webpack_require__(18);
      var _moutLangToString2 = _interopRequireDefault(_moutLangToString);
      var _moutLangToNumber = __webpack_require__(19);
      var _moutLangToNumber2 = _interopRequireDefault(_moutLangToNumber);
      var _moutObjectGet = __webpack_require__(20);
      var _moutObjectGet2 = _interopRequireDefault(_moutObjectGet);
      var _moutObjectDeepMixIn = __webpack_require__(22);
      var _moutObjectDeepMixIn2 = _interopRequireDefault(_moutObjectDeepMixIn);
      var _moutObjectDeepFillIn = __webpack_require__(2);
      var _moutObjectDeepFillIn2 = _interopRequireDefault(_moutObjectDeepFillIn);
      var _moutObjectForOwn = __webpack_require__(3);
      var _moutObjectForOwn2 = _interopRequireDefault(_moutObjectForOwn);
      var _moutObjectKeys = __webpack_require__(23);
      var _moutObjectKeys2 = _interopRequireDefault(_moutObjectKeys);
      var _moutObjectPick = __webpack_require__(24);
      var _moutObjectPick2 = _interopRequireDefault(_moutObjectPick);
      var _moutObjectFilter = __webpack_require__(26);
      var _moutObjectFilter2 = _interopRequireDefault(_moutObjectFilter);
      var _moutObjectMap = __webpack_require__(31);
      var _moutObjectMap2 = _interopRequireDefault(_moutObjectMap);
      var _moutObjectMerge = __webpack_require__(32);
      var _moutObjectMerge2 = _interopRequireDefault(_moutObjectMerge);
      var _moutObjectUnset = __webpack_require__(36);
      var _moutObjectUnset2 = _interopRequireDefault(_moutObjectUnset);
      var _moutArrayContains = __webpack_require__(38);
      var _moutArrayContains2 = _interopRequireDefault(_moutArrayContains);
      var _moutArrayIntersection = __webpack_require__(40);
      var _moutArrayIntersection2 = _interopRequireDefault(_moutArrayIntersection);
      var _moutArrayDifference = __webpack_require__(44);
      var _moutArrayDifference2 = _interopRequireDefault(_moutArrayDifference);
      var _moutArrayUnique = __webpack_require__(41);
      var _moutArrayUnique2 = _interopRequireDefault(_moutArrayUnique);
      var _moutNumberToInt = __webpack_require__(46);
      var _moutNumberToInt2 = _interopRequireDefault(_moutNumberToInt);
      exports['default'] = {
        isString: _moutLangIsString2['default'],
        isBoolean: _moutLangIsBoolean2['default'],
        isNumber: _moutLangIsNumber2['default'],
        isObject: _moutLangIsObject2['default'],
        isDate: _moutLangIsDate2['default'],
        isFunction: _moutLangIsFunction2['default'],
        isUndefined: _moutLangIsUndefined2['default'],
        isArray: _moutLangIsArray2['default'],
        isEmpty: _moutLangIsEmpty2['default'],
        toString: _moutLangToString2['default'],
        toNumber: _moutLangToNumber2['default'],
        'get': _moutObjectGet2['default'],
        deepMixIn: _moutObjectDeepMixIn2['default'],
        deepFillIn: _moutObjectDeepFillIn2['default'],
        forOwn: _moutObjectForOwn2['default'],
        keys: _moutObjectKeys2['default'],
        pick: _moutObjectPick2['default'],
        filter: _moutObjectFilter2['default'],
        map: _moutObjectMap2['default'],
        merge: _moutObjectMerge2['default'],
        unset: _moutObjectUnset2['default'],
        contains: _moutArrayContains2['default'],
        intersection: _moutArrayIntersection2['default'],
        difference: _moutArrayDifference2['default'],
        unique: _moutArrayUnique2['default'],
        toInt: _moutNumberToInt2['default'],
        errMsg: function errMsg(rule, actual, expected) {
          return {
            rule: rule,
            actual: actual,
            expected: expected
          };
        },
        parallel: function parallel(tasks, cb) {
          var results = {};
          var completed = 0;
          var length = 0;
          (0, _moutObjectForOwn2['default'])(tasks, function() {
            length += 1;
          });
          (0, _moutObjectForOwn2['default'])(tasks, function(task, key) {
            task(function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[key] = args;
              done(err);
            });
          });
          function done(err) {
            completed += 1;
            if (err || completed >= length) {
              cb(err, results);
            }
          }
        }
      };
      module.exports = exports['default'];
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var isPlainObject = __webpack_require__(6);
      function deepFillIn(target, defaults) {
        var i = 0,
            n = arguments.length,
            obj;
        while (++i < n) {
          obj = arguments[i];
          if (obj) {
            forOwn(obj, function(newValue, key) {
              var curValue = target[key];
              if (curValue == null) {
                target[key] = newValue;
              } else if (isPlainObject(curValue) && isPlainObject(newValue)) {
                deepFillIn(curValue, newValue);
              }
            });
          }
        }
        return target;
      }
      module.exports = deepFillIn;
    }, function(module, exports, __webpack_require__) {
      var hasOwn = __webpack_require__(4);
      var forIn = __webpack_require__(5);
      function forOwn(obj, fn, thisObj) {
        forIn(obj, function(val, key) {
          if (hasOwn(obj, key)) {
            return fn.call(thisObj, obj[key], key, obj);
          }
        });
      }
      module.exports = forOwn;
    }, function(module, exports, __webpack_require__) {
      function hasOwn(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      module.exports = hasOwn;
    }, function(module, exports, __webpack_require__) {
      var hasOwn = __webpack_require__(4);
      var _hasDontEnumBug,
          _dontEnums;
      function checkDontEnum() {
        _dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
        _hasDontEnumBug = true;
        for (var key in {'toString': null}) {
          _hasDontEnumBug = false;
        }
      }
      function forIn(obj, fn, thisObj) {
        var key,
            i = 0;
        if (_hasDontEnumBug == null)
          checkDontEnum();
        for (key in obj) {
          if (exec(fn, obj, key, thisObj) === false) {
            break;
          }
        }
        if (_hasDontEnumBug) {
          var ctor = obj.constructor,
              isProto = !!ctor && obj === ctor.prototype;
          while (key = _dontEnums[i++]) {
            if ((key !== 'constructor' || (!isProto && hasOwn(obj, key))) && obj[key] !== Object.prototype[key]) {
              if (exec(fn, obj, key, thisObj) === false) {
                break;
              }
            }
          }
        }
      }
      function exec(fn, obj, key, thisObj) {
        return fn.call(thisObj, obj[key], key, obj);
      }
      module.exports = forIn;
    }, function(module, exports, __webpack_require__) {
      function isPlainObject(value) {
        return (!!value && typeof value === 'object' && value.constructor === Object);
      }
      module.exports = isPlainObject;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isString(val) {
        return isKind(val, 'String');
      }
      module.exports = isString;
    }, function(module, exports, __webpack_require__) {
      var kindOf = __webpack_require__(9);
      function isKind(val, kind) {
        return kindOf(val) === kind;
      }
      module.exports = isKind;
    }, function(module, exports, __webpack_require__) {
      var _rKind = /^\[object (.*)\]$/,
          _toString = Object.prototype.toString,
          UNDEF;
      function kindOf(val) {
        if (val === null) {
          return 'Null';
        } else if (val === UNDEF) {
          return 'Undefined';
        } else {
          return _rKind.exec(_toString.call(val))[1];
        }
      }
      module.exports = kindOf;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isBoolean(val) {
        return isKind(val, 'Boolean');
      }
      module.exports = isBoolean;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isNumber(val) {
        return isKind(val, 'Number');
      }
      module.exports = isNumber;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isObject(val) {
        return isKind(val, 'Object');
      }
      module.exports = isObject;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isDate(val) {
        return isKind(val, 'Date');
      }
      module.exports = isDate;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      function isFunction(val) {
        return isKind(val, 'Function');
      }
      module.exports = isFunction;
    }, function(module, exports, __webpack_require__) {
      var UNDEF;
      function isUndef(val) {
        return val === UNDEF;
      }
      module.exports = isUndef;
    }, function(module, exports, __webpack_require__) {
      var isKind = __webpack_require__(8);
      var isArray = Array.isArray || function(val) {
        return isKind(val, 'Array');
      };
      module.exports = isArray;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var isArray = __webpack_require__(16);
      function isEmpty(val) {
        if (val == null) {
          return true;
        } else if (typeof val === 'string' || isArray(val)) {
          return !val.length;
        } else if (typeof val === 'object') {
          var result = true;
          forOwn(val, function() {
            result = false;
            return false;
          });
          return result;
        } else {
          return true;
        }
      }
      module.exports = isEmpty;
    }, function(module, exports, __webpack_require__) {
      function toString(val) {
        return val == null ? '' : val.toString();
      }
      module.exports = toString;
    }, function(module, exports, __webpack_require__) {
      var isArray = __webpack_require__(16);
      function toNumber(val) {
        if (typeof val === 'number')
          return val;
        if (!val)
          return 0;
        if (typeof val === 'string')
          return parseFloat(val);
        if (isArray(val))
          return NaN;
        return Number(val);
      }
      module.exports = toNumber;
    }, function(module, exports, __webpack_require__) {
      var isPrimitive = __webpack_require__(21);
      function get(obj, prop) {
        var parts = prop.split('.'),
            last = parts.pop();
        while (prop = parts.shift()) {
          obj = obj[prop];
          if (obj == null)
            return ;
        }
        return obj[last];
      }
      module.exports = get;
    }, function(module, exports, __webpack_require__) {
      function isPrimitive(value) {
        switch (typeof value) {
          case "string":
          case "number":
          case "boolean":
            return true;
        }
        return value == null;
      }
      module.exports = isPrimitive;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var isPlainObject = __webpack_require__(6);
      function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;
        while (++i < n) {
          obj = arguments[i];
          if (obj) {
            forOwn(obj, copyProp, target);
          }
        }
        return target;
      }
      function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
          deepMixIn(existing, val);
        } else {
          this[key] = val;
        }
      }
      module.exports = deepMixIn;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var keys = Object.keys || function(obj) {
        var keys = [];
        forOwn(obj, function(val, key) {
          keys.push(key);
        });
        return keys;
      };
      module.exports = keys;
    }, function(module, exports, __webpack_require__) {
      var slice = __webpack_require__(25);
      function pick(obj, var_keys) {
        var keys = typeof arguments[1] !== 'string' ? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0,
            key;
        while (key = keys[i++]) {
          out[key] = obj[key];
        }
        return out;
      }
      module.exports = pick;
    }, function(module, exports, __webpack_require__) {
      function slice(arr, start, end) {
        var len = arr.length;
        if (start == null) {
          start = 0;
        } else if (start < 0) {
          start = Math.max(len + start, 0);
        } else {
          start = Math.min(start, len);
        }
        if (end == null) {
          end = len;
        } else if (end < 0) {
          end = Math.max(len + end, 0);
        } else {
          end = Math.min(end, len);
        }
        var result = [];
        while (start < end) {
          result.push(arr[start++]);
        }
        return result;
      }
      module.exports = slice;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var makeIterator = __webpack_require__(27);
      function filterValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(value, key, obj) {
          if (callback(value, key, obj)) {
            output[key] = value;
          }
        });
        return output;
      }
      module.exports = filterValues;
    }, function(module, exports, __webpack_require__) {
      var identity = __webpack_require__(28);
      var prop = __webpack_require__(29);
      var deepMatches = __webpack_require__(30);
      function makeIterator(src, thisObj) {
        if (src == null) {
          return identity;
        }
        switch (typeof src) {
          case 'function':
            return (typeof thisObj !== 'undefined') ? function(val, i, arr) {
              return src.call(thisObj, val, i, arr);
            } : src;
          case 'object':
            return function(val) {
              return deepMatches(val, src);
            };
          case 'string':
          case 'number':
            return prop(src);
        }
      }
      module.exports = makeIterator;
    }, function(module, exports, __webpack_require__) {
      function identity(val) {
        return val;
      }
      module.exports = identity;
    }, function(module, exports, __webpack_require__) {
      function prop(name) {
        return function(obj) {
          return obj[name];
        };
      }
      module.exports = prop;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var isArray = __webpack_require__(16);
      function containsMatch(array, pattern) {
        var i = -1,
            length = array.length;
        while (++i < length) {
          if (deepMatches(array[i], pattern)) {
            return true;
          }
        }
        return false;
      }
      function matchArray(target, pattern) {
        var i = -1,
            patternLength = pattern.length;
        while (++i < patternLength) {
          if (!containsMatch(target, pattern[i])) {
            return false;
          }
        }
        return true;
      }
      function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
          if (!deepMatches(target[key], val)) {
            return (result = false);
          }
        });
        return result;
      }
      function deepMatches(target, pattern) {
        if (target && typeof target === 'object') {
          if (isArray(target) && isArray(pattern)) {
            return matchArray(target, pattern);
          } else {
            return matchObject(target, pattern);
          }
        } else {
          return target === pattern;
        }
      }
      module.exports = deepMatches;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      var makeIterator = __webpack_require__(27);
      function mapValues(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var output = {};
        forOwn(obj, function(val, key, obj) {
          output[key] = callback(val, key, obj);
        });
        return output;
      }
      module.exports = mapValues;
    }, function(module, exports, __webpack_require__) {
      var hasOwn = __webpack_require__(4);
      var deepClone = __webpack_require__(33);
      var isObject = __webpack_require__(12);
      function merge() {
        var i = 1,
            key,
            val,
            obj,
            target;
        target = deepClone(arguments[0]);
        while (obj = arguments[i++]) {
          for (key in obj) {
            if (!hasOwn(obj, key)) {
              continue;
            }
            val = obj[key];
            if (isObject(val) && isObject(target[key])) {
              target[key] = merge(target[key], val);
            } else {
              target[key] = deepClone(val);
            }
          }
        }
        return target;
      }
      module.exports = merge;
    }, function(module, exports, __webpack_require__) {
      var clone = __webpack_require__(34);
      var forOwn = __webpack_require__(3);
      var kindOf = __webpack_require__(9);
      var isPlainObject = __webpack_require__(6);
      function deepClone(val, instanceClone) {
        switch (kindOf(val)) {
          case 'Object':
            return cloneObject(val, instanceClone);
          case 'Array':
            return cloneArray(val, instanceClone);
          default:
            return clone(val);
        }
      }
      function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
          var out = {};
          forOwn(source, function(val, key) {
            this[key] = deepClone(val, instanceClone);
          }, out);
          return out;
        } else if (instanceClone) {
          return instanceClone(source);
        } else {
          return source;
        }
      }
      function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
          out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
      }
      module.exports = deepClone;
    }, function(module, exports, __webpack_require__) {
      var kindOf = __webpack_require__(9);
      var isPlainObject = __webpack_require__(6);
      var mixIn = __webpack_require__(35);
      function clone(val) {
        switch (kindOf(val)) {
          case 'Object':
            return cloneObject(val);
          case 'Array':
            return cloneArray(val);
          case 'RegExp':
            return cloneRegExp(val);
          case 'Date':
            return cloneDate(val);
          default:
            return val;
        }
      }
      function cloneObject(source) {
        if (isPlainObject(source)) {
          return mixIn({}, source);
        } else {
          return source;
        }
      }
      function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
      }
      function cloneDate(date) {
        return new Date(+date);
      }
      function cloneArray(arr) {
        return arr.slice();
      }
      module.exports = clone;
    }, function(module, exports, __webpack_require__) {
      var forOwn = __webpack_require__(3);
      function mixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;
        while (++i < n) {
          obj = arguments[i];
          if (obj != null) {
            forOwn(obj, copyProp, target);
          }
        }
        return target;
      }
      function copyProp(val, key) {
        this[key] = val;
      }
      module.exports = mixIn;
    }, function(module, exports, __webpack_require__) {
      var has = __webpack_require__(37);
      function unset(obj, prop) {
        if (has(obj, prop)) {
          var parts = prop.split('.'),
              last = parts.pop();
          while (prop = parts.shift()) {
            obj = obj[prop];
          }
          return (delete obj[last]);
        } else {
          return true;
        }
      }
      module.exports = unset;
    }, function(module, exports, __webpack_require__) {
      var get = __webpack_require__(20);
      var UNDEF;
      function has(obj, prop) {
        return get(obj, prop) !== UNDEF;
      }
      module.exports = has;
    }, function(module, exports, __webpack_require__) {
      var indexOf = __webpack_require__(39);
      function contains(arr, val) {
        return indexOf(arr, val) !== -1;
      }
      module.exports = contains;
    }, function(module, exports, __webpack_require__) {
      function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
          return -1;
        }
        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
          if (arr[i] === item) {
            return i;
          }
          i++;
        }
        return -1;
      }
      module.exports = indexOf;
    }, function(module, exports, __webpack_require__) {
      var unique = __webpack_require__(41);
      var filter = __webpack_require__(42);
      var every = __webpack_require__(43);
      var contains = __webpack_require__(38);
      var slice = __webpack_require__(25);
      function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle) {
              return every(arrs, function(haystack) {
                return contains(haystack, needle);
              });
            });
        return result;
      }
      module.exports = intersection;
    }, function(module, exports, __webpack_require__) {
      var filter = __webpack_require__(42);
      function unique(arr, compare) {
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr) {
          var n = arr.length;
          while (++i < n) {
            if (compare(item, arr[i])) {
              return false;
            }
          }
          return true;
        });
      }
      function isEqual(a, b) {
        return a === b;
      }
      module.exports = unique;
    }, function(module, exports, __webpack_require__) {
      var makeIterator = __webpack_require__(27);
      function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
          return results;
        }
        var i = -1,
            len = arr.length,
            value;
        while (++i < len) {
          value = arr[i];
          if (callback(value, i, arr)) {
            results.push(value);
          }
        }
        return results;
      }
      module.exports = filter;
    }, function(module, exports, __webpack_require__) {
      var makeIterator = __webpack_require__(27);
      function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
          return result;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
          if (!callback(arr[i], i, arr)) {
            result = false;
            break;
          }
        }
        return result;
      }
      module.exports = every;
    }, function(module, exports, __webpack_require__) {
      var unique = __webpack_require__(41);
      var filter = __webpack_require__(42);
      var some = __webpack_require__(45);
      var contains = __webpack_require__(38);
      var slice = __webpack_require__(25);
      function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle) {
              return !some(arrs, function(haystack) {
                return contains(haystack, needle);
              });
            });
        return result;
      }
      module.exports = difference;
    }, function(module, exports, __webpack_require__) {
      var makeIterator = __webpack_require__(27);
      function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
          return result;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
          if (callback(arr[i], i, arr)) {
            result = true;
            break;
          }
        }
        return result;
      }
      module.exports = some;
    }, function(module, exports, __webpack_require__) {
      function toInt(val) {
        return ~~val;
      }
      module.exports = toInt;
    }, function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {value: true});
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var _utils = __webpack_require__(1);
      var _utils2 = _interopRequireDefault(_utils);
      exports['default'] = {
        string: function string(x) {
          return _utils2['default'].isString(x) ? null : _utils2['default'].errMsg('type', typeof x, 'string');
        },
        number: function number(x) {
          return _utils2['default'].isNumber(x) ? null : _utils2['default'].errMsg('type', typeof x, 'number');
        },
        integer: function integer(x) {
          if (!_utils2['default'].isNumber(x)) {
            return _utils2['default'].errMsg('type', typeof x, 'integer');
          } else if (Math.abs(x) - Math.abs(_utils2['default'].toInt(x)) !== 0) {
            return _utils2['default'].errMsg('type', 'real', 'integer');
          } else {
            return null;
          }
        },
        float: function float(x) {
          return _utils2['default'].isNumber(x) ? null : _utils2['default'].errMsg('type', typeof x, 'float');
        },
        array: function array(x) {
          return _utils2['default'].isArray(x) ? null : _utils2['default'].errMsg('type', typeof x, 'array');
        },
        object: function object(x) {
          return _utils2['default'].isObject(x) ? null : _utils2['default'].errMsg('type', typeof x, 'object');
        },
        boolean: function boolean(x) {
          return _utils2['default'].isBoolean(x) ? null : _utils2['default'].errMsg('type', typeof x, 'boolean');
        },
        date: function date(x) {
          return _utils2['default'].isDate(x) ? null : _utils2['default'].errMsg('type', typeof x, 'date');
        }
      };
      module.exports = exports['default'];
    }, function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {value: true});
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var _utils = __webpack_require__(1);
      var _utils2 = _interopRequireDefault(_utils);
      var _dataTypes = __webpack_require__(47);
      var _dataTypes2 = _interopRequireDefault(_dataTypes);
      exports['default'] = {
        nullable: function nullable(x, _nullable) {
          return (x === null || x === undefined) && !_nullable ? _utils2['default'].errMsg('nullable', 'x === ' + x, 'x !== null && x !== undefined') : null;
        },
        max: function max(x, _max) {
          return _utils2['default'].isNumber(x) && _utils2['default'].isNumber(_max) && x > _max ? _utils2['default'].errMsg('max', '' + x + ' > ' + _max, '' + x + ' <= ' + _max) : null;
        },
        min: function min(x, _min) {
          return _utils2['default'].isNumber(x) && _utils2['default'].isNumber(_min) && x < _min ? _utils2['default'].errMsg('min', '' + x + ' < ' + _min, '' + x + ' >= ' + _min) : null;
        },
        maxLength: function maxLength(x, _maxLength) {
          return (_utils2['default'].isString(x) || _utils2['default'].isArray(x)) && _utils2['default'].isNumber(_maxLength) && x.length > _maxLength ? _utils2['default'].errMsg('maxLength', '' + x.length + ' > ' + _maxLength, '' + x.length + ' <= ' + _maxLength) : null;
        },
        minLength: function minLength(x, _minLength) {
          return (_utils2['default'].isString(x) || _utils2['default'].isArray(x)) && _utils2['default'].isNumber(_minLength) && x.length < _minLength ? _utils2['default'].errMsg('minLength', '' + x.length + ' < ' + _minLength, '' + x.length + ' >= ' + _minLength) : null;
        },
        type: function type(x, _type, customType, parent) {
          return customType ? customType(x) : parent.dataTypes[_type] ? parent.dataTypes[_type](x) : _dataTypes2['default'][_type] ? _dataTypes2['default'][_type](x) : null;
        }
      };
      module.exports = exports['default'];
    }, function(module, exports, __webpack_require__) {
      Object.defineProperty(exports, '__esModule', {value: true});
      var _createClass = (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function');
        }
      }
      var _utils = __webpack_require__(1);
      var _utils2 = _interopRequireDefault(_utils);
      var _rules = __webpack_require__(48);
      var _rules2 = _interopRequireDefault(_rules);
      var hasObject = function hasObject(v) {
        var has = false;
        _utils2['default'].forOwn(v, function(_v) {
          if (_utils2['default'].isObject(_v)) {
            has = true;
            return false;
          }
        });
        return has;
      };
      function _executeRulesSync(targetKey, options, errors, value, key) {
        var _this = this;
        var nestedKey = targetKey + (targetKey.length ? '.' : '') + key;
        var schemaRules = _utils2['default'].get(this.schema, nestedKey);
        if (!schemaRules) {
          return ;
        } else if (_utils2['default'].isObject(value) || hasObject(schemaRules)) {
          var err = _validateSync.apply(this, [nestedKey, value || {}, options]);
          if (err) {
            errors[key] = err;
          }
        } else {
          if (!_utils2['default'].isObject(schemaRules)) {
            return ;
          } else if (schemaRules.nullable === true) {
            var nullable = this.parent.rules.nullable || _rules2['default'].nullable;
            var nErr = nullable.call(options.ctx, value, true, undefined, this.parent);
            if (nErr === null) {
              return ;
            }
          }
          _utils2['default'].forOwn(schemaRules, function(ruleValue, ruleKey) {
            var rule = _this.parent.rules[ruleKey] || _rules2['default'][ruleKey];
            if (rule && !rule.async) {
              var err = rule.call(options.ctx, value, ruleValue, undefined, _this.parent);
              if (err) {
                if (!errors[key]) {
                  errors[key] = {errors: []};
                }
                errors[key].errors.push(err);
              }
            }
          });
        }
      }
      function _validateSync(targetKey, attrs, options) {
        var _this2 = this;
        var errors = {};
        try {
          _utils2['default'].forOwn(attrs, function(value, key) {
            _executeRulesSync.call(_this2, targetKey, options, errors, value, key);
          });
          if (!options.ignoreMissing) {
            var schema = targetKey ? _utils2['default'].get(this.schema, targetKey) || {} : this.schema;
            var missing = _utils2['default'].difference(_utils2['default'].keys(schema), _utils2['default'].keys(attrs));
            missing = _utils2['default'].pick(this.schema, missing);
            missing = _utils2['default'].map(missing, function() {
              return undefined;
            });
            _utils2['default'].forOwn(missing, function(value, key) {
              _executeRulesSync.call(_this2, targetKey, options, errors, value, key);
            });
          }
          if (!_utils2['default'].isEmpty(errors)) {
            return errors;
          } else {
            return null;
          }
        } catch (err) {
          return err;
        }
      }
      function _executeRules(options, value, key, prefix, errors, deepQueue, ruleQueue) {
        var _this3 = this;
        var nestedKey = prefix + key;
        var schemaRules = _utils2['default'].get(this.schema, nestedKey);
        if (!schemaRules) {
          return ;
        } else if (_utils2['default'].isObject(value) || hasObject(schemaRules)) {
          deepQueue[key] = (function(nK, val) {
            return function(next) {
              _validate.apply(_this3, [nK, val || {}, options, next]);
            };
          })(nestedKey, value);
        } else {
          if (!_utils2['default'].isObject(schemaRules)) {
            return ;
          } else if (schemaRules.nullable === true) {
            var nullable = this.parent.rules.nullable || _rules2['default'].nullable;
            var nErr = nullable.call(options.ctx, value, true, undefined, this.parent);
            if (nErr === null) {
              return ;
            }
          }
          _utils2['default'].forOwn(schemaRules, function(ruleValue, ruleKey) {
            var rule = _this3.parent.rules[ruleKey] || _rules2['default'][ruleKey];
            if (rule && rule.async) {
              ruleQueue['' + ruleKey + '_' + ruleValue] = (function(r, key, val, rVal) {
                return function(next) {
                  r.call(options.ctx, val, rVal, function(err) {
                    next(null, {
                      err: err,
                      key: key
                    });
                  });
                };
              })(rule, key, value, ruleValue);
            } else {
              var err = rule.call(options.ctx, value, ruleValue, undefined, _this3.parent);
              if (err) {
                if (!errors[key]) {
                  errors[key] = {errors: []};
                }
                errors[key].errors.push(err);
              }
            }
          });
        }
      }
      function _validate(targetKey, attrs, options, cb) {
        var _this4 = this;
        var errors = {};
        var prefix = targetKey + (targetKey.length ? '.' : '');
        var deepQueue = {};
        var ruleQueue = {};
        var first = options.first;
        delete options.first;
        _utils2['default'].forOwn(attrs, function(value, key) {
          _executeRules.call(_this4, options, value, key, prefix, errors, deepQueue, ruleQueue);
        });
        if (!options.ignoreMissing) {
          var schema = targetKey ? _utils2['default'].get(this.schema, targetKey) || {} : this.schema;
          var missing = _utils2['default'].difference(_utils2['default'].keys(schema), _utils2['default'].keys(attrs));
          missing = _utils2['default'].pick(this.schema, missing);
          missing = _utils2['default'].map(missing, function() {
            return undefined;
          });
          _utils2['default'].forOwn(missing, function(value, key) {
            _executeRules.call(_this4, options, value, key, prefix, errors, deepQueue, ruleQueue);
          });
        }
        var finalQueue = {};
        if (!_utils2['default'].isEmpty(deepQueue)) {
          finalQueue.deepQueue = function(next) {
            _utils2['default'].parallel(deepQueue, next);
          };
        }
        if (!_utils2['default'].isEmpty(ruleQueue)) {
          finalQueue.ruleQueue = function(next) {
            _utils2['default'].parallel(ruleQueue, next);
          };
        }
        if (!_utils2['default'].isEmpty(finalQueue)) {
          _utils2['default'].parallel(finalQueue, function(err, results) {
            if (results.deepQueue) {
              results.deepQueue = _utils2['default'].filter(results.deepQueue, function(x) {
                return x !== undefined && x !== null;
              });
              _utils2['default'].deepMixIn(errors, results.deepQueue);
            }
            if (results.ruleQueue) {
              if (results.ruleQueue) {
                results.ruleQueue = _utils2['default'].filter(results.ruleQueue, function(x) {
                  return x.err !== undefined && x.err !== null;
                });
              }
              _utils2['default'].forOwn(results.ruleQueue, function(value) {
                if (!errors[value.key]) {
                  errors[value.key] = {errors: []};
                }
                errors[value.key].errors.push(value.err);
              });
            }
            if (!_utils2['default'].isEmpty(errors)) {
              first ? cb(errors) : cb(null, errors);
            } else {
              cb(null);
            }
          });
        } else {
          if (!_utils2['default'].isEmpty(errors)) {
            first ? cb(errors) : cb(null, errors);
          } else {
            cb(null);
          }
        }
      }
      function _validateSchema(attrs, rules) {
        rules = rules || [];
        var keys = _utils2['default'].keys(attrs);
        var noRules = _utils2['default'].intersection(keys, rules).length === 0;
        _utils2['default'].forOwn(attrs, function(value, key) {
          if (noRules && _utils2['default'].isString(value)) {
            attrs[key] = {type: value};
          } else if (_utils2['default'].isObject(value)) {
            _validateSchema(value, rules);
          }
        });
      }
      var errors = {
        a: 'Schema#validateSync(attrs[, options]): ',
        b: 'Schema#validate(attrs[, options], cb): '
      };
      var Schema = (function() {
        function Schema(name, schema, parent) {
          _classCallCheck(this, Schema);
          if (!_utils2['default'].isString(name)) {
            throw new Error('"name" must be a string!');
          } else if (!_utils2['default'].isObject(schema)) {
            throw new Error('"schema" must be an object!');
          }
          this.name = name;
          _validateSchema(schema, parent ? parent.availableRules() : _rules2['default']);
          this.schema = schema;
        }
        _createClass(Schema, [{
          key: 'validateSync',
          value: function validateSync(attrs, options) {
            options = options ? options === true ? {ignoreMissing: true} : options : {};
            if (!_utils2['default'].isObject(attrs)) {
              throw new Error('' + errors.a + 'attrs: Must be an object!');
            } else if (!_utils2['default'].isObject(options)) {
              throw new Error('' + errors.a + 'options: Must be an object!');
            }
            options.ctx = attrs;
            return _validateSync.call(this, '', attrs, options);
          }
        }, {
          key: 'validate',
          value: function validate(attrs, options, cb) {
            options = options ? options === true ? {ignoreMissing: true} : options : {};
            if (_utils2['default'].isFunction(options)) {
              cb = options;
              options = {};
            }
            if (!_utils2['default'].isFunction(cb)) {
              throw new Error('' + errors.b + 'cb: Must be a function!');
            } else if (!_utils2['default'].isObject(attrs)) {
              return cb(new Error('' + errors.b + 'attrs: Must be an object!'));
            } else if (!_utils2['default'].isObject(options)) {
              return cb(new Error('' + errors.b + 'options: Must be an object!'));
            }
            options.first = true;
            options.ctx = attrs;
            _validate.call(this, '', attrs, options, cb);
          }
        }, {
          key: 'addDefaultsToTarget',
          value: function addDefaultsToTarget(target, overwrite) {
            if (!_utils2['default'].isObject(target)) {
              throw new Error('"target" must be an object!');
            } else if (!this.defaults) {
              throw new Error('No defaults have been set!');
            } else if (overwrite) {
              _utils2['default'].deepMixIn(target, this.defaults);
            } else {
              _utils2['default'].deepFillIn(target, this.defaults);
            }
          }
        }, {
          key: 'setDefaults',
          value: function setDefaults(attrs) {
            if (!_utils2['default'].isObject(attrs)) {
              throw new Error('Schema#defaults(attrs): attrs: Must be an object!');
            } else {
              this.defaults = _utils2['default'].merge({}, attrs);
            }
            return this;
          }
        }, {
          key: 'getDefaults',
          value: function getDefaults() {
            return _utils2['default'].merge({}, this.defaults);
          }
        }, {
          key: 'stripNonSchemaAttrs',
          value: function stripNonSchemaAttrs(attrs) {
            _stripNonSchemaAttrs(attrs, this.schema);
            return attrs;
          }
        }]);
        return Schema;
      })();
      function _stripNonSchemaAttrs(attrs, schemaLevel) {
        _utils2['default'].forOwn(attrs, function(value, key) {
          if (schemaLevel[key]) {
            if (_utils2['default'].isObject(value) && _utils2['default'].isObject(schemaLevel[key])) {
              _stripNonSchemaAttrs(value, schemaLevel[key]);
            }
          } else {
            _utils2['default'].unset(attrs, key);
          }
        });
      }
      exports['default'] = Schema;
      module.exports = exports['default'];
    }]);
  });
  ;
  global.define = __define;
  return module.exports;
});

System.register("npm:js-data-schema@1.2.5", ["npm:js-data-schema@1.2.5/dist/js-data-schema"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:js-data-schema@1.2.5/dist/js-data-schema");
  global.define = __define;
  return module.exports;
});

(function() {
function define(){};  define.amd = {};
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    System.register("github:js-data/js-data@2.3.0/dist/js-data-debug", [], false, typeof factory == "function" ? factory : function() {
      return factory;
    });
  else if (typeof exports === 'object')
    exports["JSData"] = factory();
  else
    root["JSData"] = factory();
})(this, function() {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    var _datastoreIndex = __webpack_require__(1);
    var _utils = __webpack_require__(2);
    var _errors = __webpack_require__(3);
    module.exports = {
      DS: _datastoreIndex['default'],
      DSUtils: _utils['default'],
      DSErrors: _errors['default'],
      createStore: function createStore(options) {
        return new _datastoreIndex['default'](options);
      },
      version: {
        full: '2.3.0',
        major: parseInt('2', 10),
        minor: parseInt('3', 10),
        patch: parseInt('0', 10),
        alpha: true ? 'false' : false,
        beta: true ? 'false' : false
      }
    };
  }, function(module, exports, __webpack_require__) {
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var _utils = __webpack_require__(2);
    var _errors = __webpack_require__(3);
    var _sync_methodsIndex = __webpack_require__(4);
    var _async_methodsIndex = __webpack_require__(5);
    function lifecycleNoopCb(resource, attrs, cb) {
      cb(null, attrs);
    }
    function lifecycleNoop(resource, attrs) {
      return attrs;
    }
    function compare(_x, _x2, _x3, _x4) {
      var _again = true;
      _function: while (_again) {
        var orderBy = _x,
            index = _x2,
            a = _x3,
            b = _x4;
        def = cA = cB = undefined;
        _again = false;
        var def = orderBy[index];
        var cA = _utils['default'].get(a, def[0]),
            cB = _utils['default'].get(b, def[0]);
        if (_utils['default']._s(cA)) {
          cA = _utils['default'].upperCase(cA);
        }
        if (_utils['default']._s(cB)) {
          cB = _utils['default'].upperCase(cB);
        }
        if (def[1] === 'DESC') {
          if (cB < cA) {
            return -1;
          } else if (cB > cA) {
            return 1;
          } else {
            if (index < orderBy.length - 1) {
              _x = orderBy;
              _x2 = index + 1;
              _x3 = a;
              _x4 = b;
              _again = true;
              continue _function;
            } else {
              return 0;
            }
          }
        } else {
          if (cA < cB) {
            return -1;
          } else if (cA > cB) {
            return 1;
          } else {
            if (index < orderBy.length - 1) {
              _x = orderBy;
              _x2 = index + 1;
              _x3 = a;
              _x4 = b;
              _again = true;
              continue _function;
            } else {
              return 0;
            }
          }
        }
      }
    }
    var Defaults = (function() {
      function Defaults() {
        _classCallCheck(this, Defaults);
      }
      _createClass(Defaults, [{
        key: 'errorFn',
        value: function errorFn(a, b) {
          if (this.error && typeof this.error === 'function') {
            try {
              if (typeof a === 'string') {
                throw new Error(a);
              } else {
                throw a;
              }
            } catch (err) {
              a = err;
            }
            this.error(this.name || null, a || null, b || null);
          }
        }
      }]);
      return Defaults;
    })();
    var defaultsPrototype = Defaults.prototype;
    defaultsPrototype.actions = {};
    defaultsPrototype.afterCreate = lifecycleNoopCb;
    defaultsPrototype.afterCreateCollection = lifecycleNoop;
    defaultsPrototype.afterCreateInstance = lifecycleNoop;
    defaultsPrototype.afterDestroy = lifecycleNoopCb;
    defaultsPrototype.afterEject = lifecycleNoop;
    defaultsPrototype.afterInject = lifecycleNoop;
    defaultsPrototype.afterReap = lifecycleNoop;
    defaultsPrototype.afterUpdate = lifecycleNoopCb;
    defaultsPrototype.afterValidate = lifecycleNoopCb;
    defaultsPrototype.allowSimpleWhere = true;
    defaultsPrototype.basePath = '';
    defaultsPrototype.beforeCreate = lifecycleNoopCb;
    defaultsPrototype.beforeCreateCollection = lifecycleNoop;
    defaultsPrototype.beforeCreateInstance = lifecycleNoop;
    defaultsPrototype.beforeDestroy = lifecycleNoopCb;
    defaultsPrototype.beforeEject = lifecycleNoop;
    defaultsPrototype.beforeInject = lifecycleNoop;
    defaultsPrototype.beforeReap = lifecycleNoop;
    defaultsPrototype.beforeUpdate = lifecycleNoopCb;
    defaultsPrototype.beforeValidate = lifecycleNoopCb;
    defaultsPrototype.bypassCache = false;
    defaultsPrototype.cacheResponse = !!_utils['default'].w;
    defaultsPrototype.clearEmptyQueries = true;
    defaultsPrototype.computed = {};
    defaultsPrototype.defaultAdapter = 'http';
    defaultsPrototype.debug = false;
    defaultsPrototype.defaultValues = {};
    defaultsPrototype.eagerEject = false;
    defaultsPrototype.eagerInject = false;
    defaultsPrototype.endpoint = '';
    defaultsPrototype.error = console ? function(a, b, c) {
      return console[typeof console.error === 'function' ? 'error' : 'log'](a, b, c);
    } : false;
    defaultsPrototype.fallbackAdapters = ['http'];
    defaultsPrototype.findStrictCache = false;
    defaultsPrototype.idAttribute = 'id';
    defaultsPrototype.ignoredChanges = [/\$/];
    defaultsPrototype.instanceEvents = !!_utils['default'].w;
    defaultsPrototype.keepChangeHistory = false;
    defaultsPrototype.linkRelations = true;
    defaultsPrototype.log = console ? function(a, b, c, d, e) {
      return console[typeof console.info === 'function' ? 'info' : 'log'](a, b, c, d, e);
    } : false;
    defaultsPrototype.logFn = function(a, b, c, d) {
      var _this = this;
      if (_this.debug && _this.log && typeof _this.log === 'function') {
        _this.log(_this.name || null, a || null, b || null, c || null, d || null);
      }
    };
    defaultsPrototype.maxAge = false;
    defaultsPrototype.methods = {};
    defaultsPrototype.notify = !!_utils['default'].w;
    defaultsPrototype.omit = [];
    defaultsPrototype.onConflict = 'merge';
    defaultsPrototype.reapAction = !!_utils['default'].w ? 'inject' : 'none';
    defaultsPrototype.reapInterval = !!_utils['default'].w ? 30000 : false;
    defaultsPrototype.relationsEnumerable = false;
    defaultsPrototype.resetHistoryOnInject = true;
    defaultsPrototype.returnMeta = false;
    defaultsPrototype.strategy = 'single';
    defaultsPrototype.upsert = !!_utils['default'].w;
    defaultsPrototype.useClass = true;
    defaultsPrototype.useFilter = false;
    defaultsPrototype.validate = lifecycleNoopCb;
    defaultsPrototype.watchChanges = !!_utils['default'].w;
    defaultsPrototype.defaultFilter = function(collection, resourceName, params, options) {
      var filtered = collection;
      var where = null;
      var reserved = {
        skip: '',
        offset: '',
        where: '',
        limit: '',
        orderBy: '',
        sort: ''
      };
      params = params || {};
      options = options || {};
      if (_utils['default']._o(params.where)) {
        where = params.where;
      } else {
        where = {};
      }
      if (options.allowSimpleWhere) {
        _utils['default'].forOwn(params, function(value, key) {
          if (!(key in reserved) && !(key in where)) {
            where[key] = {'==': value};
          }
        });
      }
      if (_utils['default'].isEmpty(where)) {
        where = null;
      }
      if (where) {
        filtered = _utils['default'].filter(filtered, function(attrs) {
          var first = true;
          var keep = true;
          _utils['default'].forOwn(where, function(clause, field) {
            if (!_utils['default']._o(clause)) {
              clause = {'==': clause};
            }
            _utils['default'].forOwn(clause, function(term, op) {
              var expr = undefined;
              var isOr = op[0] === '|';
              var val = _utils['default'].get(attrs, field);
              op = isOr ? op.substr(1) : op;
              if (op === '==') {
                expr = val == term;
              } else if (op === '===') {
                expr = val === term;
              } else if (op === '!=') {
                expr = val != term;
              } else if (op === '!==') {
                expr = val !== term;
              } else if (op === '>') {
                expr = val > term;
              } else if (op === '>=') {
                expr = val >= term;
              } else if (op === '<') {
                expr = val < term;
              } else if (op === '<=') {
                expr = val <= term;
              } else if (op === 'isectEmpty') {
                expr = !_utils['default'].intersection(val || [], term || []).length;
              } else if (op === 'isectNotEmpty') {
                expr = _utils['default'].intersection(val || [], term || []).length;
              } else if (op === 'in') {
                if (_utils['default']._s(term)) {
                  expr = term.indexOf(val) !== -1;
                } else {
                  expr = _utils['default'].contains(term, val);
                }
              } else if (op === 'notIn') {
                if (_utils['default']._s(term)) {
                  expr = term.indexOf(val) === -1;
                } else {
                  expr = !_utils['default'].contains(term, val);
                }
              } else if (op === 'contains') {
                if (_utils['default']._s(val)) {
                  expr = val.indexOf(term) !== -1;
                } else {
                  expr = _utils['default'].contains(val, term);
                }
              } else if (op === 'notContains') {
                if (_utils['default']._s(val)) {
                  expr = val.indexOf(term) === -1;
                } else {
                  expr = !_utils['default'].contains(val, term);
                }
              }
              if (expr !== undefined) {
                keep = first ? expr : isOr ? keep || expr : keep && expr;
              }
              first = false;
            });
          });
          return keep;
        });
      }
      var orderBy = null;
      if (_utils['default']._s(params.orderBy)) {
        orderBy = [[params.orderBy, 'ASC']];
      } else if (_utils['default']._a(params.orderBy)) {
        orderBy = params.orderBy;
      }
      if (!orderBy && _utils['default']._s(params.sort)) {
        orderBy = [[params.sort, 'ASC']];
      } else if (!orderBy && _utils['default']._a(params.sort)) {
        orderBy = params.sort;
      }
      if (orderBy) {
        (function() {
          var index = 0;
          _utils['default'].forEach(orderBy, function(def, i) {
            if (_utils['default']._s(def)) {
              orderBy[i] = [def, 'ASC'];
            } else if (!_utils['default']._a(def)) {
              throw new _errors['default'].IA('DS.filter("' + resourceName + '"[, params][, options]): ' + _utils['default'].toJson(def) + ': Must be a string or an array!', {params: {'orderBy[i]': {
                    actual: typeof def,
                    expected: 'string|array'
                  }}});
            }
          });
          filtered = _utils['default'].sort(filtered, function(a, b) {
            return compare(orderBy, index, a, b);
          });
        })();
      }
      var limit = _utils['default']._n(params.limit) ? params.limit : null;
      var skip = null;
      if (_utils['default']._n(params.skip)) {
        skip = params.skip;
      } else if (_utils['default']._n(params.offset)) {
        skip = params.offset;
      }
      if (limit && skip) {
        filtered = _utils['default'].slice(filtered, skip, Math.min(filtered.length, skip + limit));
      } else if (_utils['default']._n(limit)) {
        filtered = _utils['default'].slice(filtered, 0, Math.min(filtered.length, limit));
      } else if (_utils['default']._n(skip)) {
        if (skip < filtered.length) {
          filtered = _utils['default'].slice(filtered, skip);
        } else {
          filtered = [];
        }
      }
      if (filtered === collection) {
        return filtered.slice();
      } else {
        return filtered;
      }
    };
    var DS = (function() {
      function DS(options) {
        _classCallCheck(this, DS);
        var _this = this;
        options = options || {};
        _this.store = {};
        _this.definitions = {};
        _this.adapters = {};
        _this.defaults = new Defaults();
        _this.observe = _utils['default'].observe;
        _utils['default'].forOwn(options, function(v, k) {
          if (k === 'omit') {
            _this.defaults.omit = v.concat(Defaults.prototype.omit);
          } else {
            _this.defaults[k] = v;
          }
        });
        _this.defaults.logFn('new data store created', _this.defaults);
        var P = _utils['default'].Promise;
        if (P && !P.prototype.spread) {
          P.prototype.spread = function(cb) {
            return this.then(function(arr) {
              return cb.apply(this, arr);
            });
          };
        }
        _utils['default'].Events(_this);
      }
      _createClass(DS, [{
        key: 'getAdapterName',
        value: function getAdapterName(options) {
          var errorIfNotExist = false;
          options = options || {};
          this.defaults.logFn('getAdapterName', options);
          if (_utils['default']._s(options)) {
            errorIfNotExist = true;
            options = {adapter: options};
          }
          if (this.adapters[options.adapter]) {
            return options.adapter;
          } else if (errorIfNotExist) {
            throw new Error(options.adapter + ' is not a registered adapter!');
          } else {
            return options.defaultAdapter;
          }
        }
      }, {
        key: 'getAdapter',
        value: function getAdapter(options) {
          options = options || {};
          this.defaults.logFn('getAdapter', options);
          return this.adapters[this.getAdapterName(options)];
        }
      }, {
        key: 'registerAdapter',
        value: function registerAdapter(name, Adapter, options) {
          var _this = this;
          options = options || {};
          _this.defaults.logFn('registerAdapter', name, Adapter, options);
          if (_utils['default'].isFunction(Adapter)) {
            _this.adapters[name] = new Adapter(options);
          } else {
            _this.adapters[name] = Adapter;
          }
          if (options['default']) {
            _this.defaults.defaultAdapter = name;
          }
          _this.defaults.logFn('default adapter is ' + _this.defaults.defaultAdapter);
        }
      }, {
        key: 'is',
        value: function is(resourceName, instance) {
          var definition = this.definitions[resourceName];
          if (!definition) {
            throw new _errors['default'].NER(resourceName);
          }
          return instance instanceof definition[definition['class']];
        }
      }, {
        key: 'clear',
        value: function clear() {
          var _this2 = this;
          var ejected = {};
          _utils['default'].forOwn(this.definitions, function(definition) {
            var name = definition.name;
            ejected[name] = definition.ejectAll();
            _this2.store[name].completedQueries = {};
            _this2.store[name].queryData = {};
          });
          return ejected;
        }
      }]);
      return DS;
    })();
    var dsPrototype = DS.prototype;
    dsPrototype.getAdapterName.shorthand = false;
    dsPrototype.getAdapter.shorthand = false;
    dsPrototype.registerAdapter.shorthand = false;
    dsPrototype.errors = _errors['default'];
    dsPrototype.utils = _utils['default'];
    function addMethods(target, obj) {
      _utils['default'].forOwn(obj, function(v, k) {
        target[k] = v;
        target[k].before = function(fn) {
          var orig = target[k];
          target[k] = function() {
            for (var _len = arguments.length,
                args = Array(_len),
                _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return orig.apply(this, fn.apply(this, args) || args);
          };
        };
      });
    }
    addMethods(dsPrototype, _sync_methodsIndex['default']);
    addMethods(dsPrototype, _async_methodsIndex['default']);
    exports['default'] = DS;
  }, function(module, exports, __webpack_require__) {
    var _errors = __webpack_require__(3);
    var BinaryHeap = __webpack_require__(7);
    var forEach = __webpack_require__(8);
    var slice = __webpack_require__(9);
    var forOwn = __webpack_require__(13);
    var contains = __webpack_require__(10);
    var deepMixIn = __webpack_require__(14);
    var pascalCase = __webpack_require__(19);
    var remove = __webpack_require__(11);
    var pick = __webpack_require__(15);
    var _keys = __webpack_require__(16);
    var sort = __webpack_require__(12);
    var upperCase = __webpack_require__(20);
    var get = __webpack_require__(17);
    var set = __webpack_require__(18);
    var observe = __webpack_require__(6);
    var w = undefined;
    var objectProto = Object.prototype;
    var toString = objectProto.toString;
    var P = undefined;
    try {
      P = Promise;
    } catch (err) {
      console.error('js-data requires a global Promise constructor!');
    }
    var isArray = Array.isArray || function isArray(value) {
      return toString.call(value) == '[object Array]' || false;
    };
    var isRegExp = function isRegExp(value) {
      return toString.call(value) == '[object RegExp]' || false;
    };
    var isString = function isString(value) {
      return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == '[object String]' || false;
    };
    var isObject = function isObject(value) {
      return toString.call(value) == '[object Object]' || false;
    };
    var isDate = function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == '[object Date]' || false;
    };
    var isNumber = function isNumber(value) {
      var type = typeof value;
      return type == 'number' || value && type == 'object' && toString.call(value) == '[object Number]' || false;
    };
    var isFunction = function isFunction(value) {
      return typeof value == 'function' || value && toString.call(value) === '[object Function]' || false;
    };
    var isStringOrNumber = function isStringOrNumber(value) {
      return isString(value) || isNumber(value);
    };
    var isStringOrNumberErr = function isStringOrNumberErr(field) {
      return new _errors['default'].IA('"' + field + '" must be a string or a number!');
    };
    var isObjectErr = function isObjectErr(field) {
      return new _errors['default'].IA('"' + field + '" must be an object!');
    };
    var isArrayErr = function isArrayErr(field) {
      return new _errors['default'].IA('"' + field + '" must be an array!');
    };
    var isEmpty = function isEmpty(val) {
      if (val == null) {
        return true;
      } else if (typeof val === 'string' || isArray(val)) {
        return !val.length;
      } else if (typeof val === 'object') {
        var result = true;
        forOwn(val, function() {
          result = false;
          return false;
        });
        return result;
      } else {
        return true;
      }
    };
    var intersection = function intersection(array1, array2) {
      if (!array1 || !array2) {
        return [];
      }
      var result = [];
      var item = undefined;
      for (var i = 0,
          _length = array1.length; i < _length; i++) {
        item = array1[i];
        if (contains(result, item)) {
          continue;
        }
        if (contains(array2, item)) {
          result.push(item);
        }
      }
      return result;
    };
    var filter = function filter(array, cb, thisObj) {
      var results = [];
      forEach(array, function(value, key, arr) {
        if (cb(value, key, arr)) {
          results.push(value);
        }
      }, thisObj);
      return results;
    };
    try {
      w = window;
      w = {};
    } catch (e) {
      w = null;
    }
    function Events(target) {
      var events = {};
      target = target || this;
      target.on = function(type, func, ctx) {
        events[type] = events[type] || [];
        events[type].push({
          f: func,
          c: ctx
        });
      };
      target.off = function(type, func) {
        var listeners = events[type];
        if (!listeners) {
          events = {};
        } else if (func) {
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].f === func) {
              listeners.splice(i, 1);
              break;
            }
          }
        } else {
          listeners.splice(0, listeners.length);
        }
      };
      target.emit = function() {
        for (var _len = arguments.length,
            args = Array(_len),
            _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var listeners = events[args.shift()] || [];
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].f.apply(listeners[i].c, args);
          }
        }
      };
    }
    var toPromisify = ['beforeValidate', 'validate', 'afterValidate', 'beforeCreate', 'afterCreate', 'beforeUpdate', 'afterUpdate', 'beforeDestroy', 'afterDestroy'];
    var isBlacklisted = observe.isBlacklisted;
    var copy = function copy(source, destination, stackSource, stackDest, blacklist) {
      if (!destination) {
        destination = source;
        if (source) {
          if (isArray(source)) {
            destination = copy(source, [], stackSource, stackDest, blacklist);
          } else if (isDate(source)) {
            destination = new Date(source.getTime());
          } else if (isRegExp(source)) {
            destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
            destination.lastIndex = source.lastIndex;
          } else if (isObject(source)) {
            destination = copy(source, Object.create(Object.getPrototypeOf(source)), stackSource, stackDest, blacklist);
          }
        }
      } else {
        if (source === destination) {
          throw new Error('Cannot copy! Source and destination are identical.');
        }
        stackSource = stackSource || [];
        stackDest = stackDest || [];
        if (isObject(source)) {
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          stackSource.push(source);
          stackDest.push(destination);
        }
        var result = undefined;
        if (isArray(source)) {
          var i = undefined;
          destination.length = 0;
          for (i = 0; i < source.length; i++) {
            result = copy(source[i], null, stackSource, stackDest, blacklist);
            if (isObject(source[i])) {
              stackSource.push(source[i]);
              stackDest.push(result);
            }
            destination.push(result);
          }
        } else {
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              delete destination[key];
            });
          }
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              if (isBlacklisted(key, blacklist)) {
                continue;
              }
              result = copy(source[key], null, stackSource, stackDest, blacklist);
              if (isObject(source[key])) {
                stackSource.push(source[key]);
                stackDest.push(result);
              }
              destination[key] = result;
            }
          }
        }
      }
      return destination;
    };
    var equals = function equals(_x, _x2) {
      var _again = true;
      _function: while (_again) {
        var o1 = _x,
            o2 = _x2;
        t1 = t2 = length = key = keySet = undefined;
        _again = false;
        if (o1 === o2) {
          return true;
        }
        if (o1 === null || o2 === null) {
          return false;
        }
        if (o1 !== o1 && o2 !== o2) {
          return true;
        }
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2)) {
                return false;
              }
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key])) {
                    return false;
                  }
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2)) {
                return false;
              }
              _x = o1.getTime();
              _x2 = o2.getTime();
              _again = true;
              continue _function;
            } else if (isRegExp(o1) && isRegExp(o2)) {
              return o1.toString() == o2.toString();
            } else {
              if (isArray(o2)) {
                return false;
              }
              keySet = {};
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key])) {
                  continue;
                }
                if (!equals(o1[key], o2[key])) {
                  return false;
                }
                keySet[key] = true;
              }
              for (key in o2) {
                if (!keySet.hasOwnProperty(key) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key])) {
                  return false;
                }
              }
              return true;
            }
          }
        }
        return false;
      }
    };
    var resolveId = function resolveId(definition, idOrInstance) {
      if (isString(idOrInstance) || isNumber(idOrInstance)) {
        return idOrInstance;
      } else if (idOrInstance && definition) {
        return idOrInstance[definition.idAttribute] || idOrInstance;
      } else {
        return idOrInstance;
      }
    };
    var resolveItem = function resolveItem(resource, idOrInstance) {
      if (resource && (isString(idOrInstance) || isNumber(idOrInstance))) {
        return resource.index[idOrInstance] || idOrInstance;
      } else {
        return idOrInstance;
      }
    };
    var isValidString = function isValidString(val) {
      return val != null && val !== '';
    };
    var join = function join(items, separator) {
      separator = separator || '';
      return filter(items, isValidString).join(separator);
    };
    var makePath = function makePath() {
      for (var _len2 = arguments.length,
          args = Array(_len2),
          _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var result = join(args, '/');
      return result.replace(/([^:\/]|^)\/{2,}/g, '$1/');
    };
    exports['default'] = {
      Promise: P,
      _: function _(parent, options) {
        var _this = this;
        parent = parent || {};
        options = options || {};
        if (options && options.constructor === parent.constructor) {
          return options;
        } else if (!isObject(options)) {
          throw new _errors['default'].IA('"options" must be an object!');
        }
        forEach(toPromisify, function(name) {
          if (typeof options[name] === 'function' && options[name].toString().indexOf('for (var _len = arg') === -1) {
            options[name] = _this.promisify(options[name]);
          }
        });
        var O = function Options(attrs) {
          var self = this;
          forOwn(attrs, function(value, key) {
            self[key] = value;
          });
        };
        O.prototype = parent;
        O.prototype.orig = function() {
          var orig = {};
          forOwn(this, function(value, key) {
            orig[key] = value;
          });
          return orig;
        };
        return new O(options);
      },
      _n: isNumber,
      _s: isString,
      _sn: isStringOrNumber,
      _snErr: isStringOrNumberErr,
      _o: isObject,
      _oErr: isObjectErr,
      _a: isArray,
      _aErr: isArrayErr,
      compute: function compute(fn, field) {
        var _this = this;
        var args = [];
        forEach(fn.deps, function(dep) {
          args.push(get(_this, dep));
        });
        set(_this, field, fn[fn.length - 1].apply(_this, args));
      },
      contains: contains,
      copy: copy,
      deepMixIn: deepMixIn,
      diffObjectFromOldObject: observe.diffObjectFromOldObject,
      BinaryHeap: BinaryHeap,
      equals: equals,
      Events: Events,
      filter: filter,
      fillIn: function fillIn(target, obj) {
        forOwn(obj, function(v, k) {
          if (!(k in target)) {
            target[k] = v;
          }
        });
        return target;
      },
      forEach: forEach,
      forOwn: forOwn,
      fromJson: function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      },
      get: get,
      intersection: intersection,
      isArray: isArray,
      isBlacklisted: isBlacklisted,
      isEmpty: isEmpty,
      isFunction: isFunction,
      isObject: isObject,
      isNumber: isNumber,
      isString: isString,
      keys: _keys,
      makePath: makePath,
      observe: observe,
      omit: function omit(obj, bl) {
        var toRemove = [];
        forOwn(obj, function(v, k) {
          if (isBlacklisted(k, bl)) {
            toRemove.push(k);
          }
        });
        forEach(toRemove, function(k) {
          delete obj[k];
        });
        return obj;
      },
      pascalCase: pascalCase,
      pick: pick,
      promisify: function promisify(fn, target) {
        var _this = this;
        if (!fn) {
          return ;
        } else if (typeof fn !== 'function') {
          throw new Error('Can only promisify functions!');
        }
        return function() {
          for (var _len3 = arguments.length,
              args = Array(_len3),
              _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return new _this.Promise(function(resolve, reject) {
            args.push(function(err, result) {
              if (err) {
                reject(err);
              } else {
                resolve(result);
              }
            });
            try {
              var promise = fn.apply(target || this, args);
              if (promise && promise.then) {
                promise.then(resolve, reject);
              }
            } catch (err) {
              reject(err);
            }
          });
        };
      },
      remove: remove,
      set: set,
      slice: slice,
      sort: sort,
      toJson: JSON.stringify,
      updateTimestamp: function updateTimestamp(timestamp) {
        var newTimestamp = typeof Date.now === 'function' ? Date.now() : new Date().getTime();
        if (timestamp && newTimestamp <= timestamp) {
          return timestamp + 1;
        } else {
          return newTimestamp;
        }
      },
      upperCase: upperCase,
      removeCircular: function removeCircular(object) {
        return (function rmCirc(value, ctx) {
          var i = undefined;
          var nu = undefined;
          if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {
            var cur = ctx.cur;
            var parent = ctx.ctx;
            while (parent) {
              if (parent.cur === cur) {
                return undefined;
              }
              parent = parent.ctx;
            }
            if (isArray(value)) {
              nu = [];
              for (i = 0; i < value.length; i += 1) {
                nu[i] = rmCirc(value[i], {
                  ctx: ctx,
                  cur: value[i]
                });
              }
            } else {
              nu = {};
              forOwn(value, function(v, k) {
                nu[k] = rmCirc(value[k], {
                  ctx: ctx,
                  cur: value[k]
                });
              });
            }
            return nu;
          }
          return value;
        })(object, {
          ctx: null,
          cur: object
        });
      },
      resolveItem: resolveItem,
      resolveId: resolveId,
      respond: function respond(response, meta, options) {
        if (options.returnMeta === 'array') {
          return [response, meta];
        } else if (options.returnMeta === 'object') {
          return {
            response: response,
            meta: meta
          };
        } else {
          return response;
        }
      },
      w: w,
      applyRelationGettersToTarget: function applyRelationGettersToTarget(store, definition, target) {
        this.forEach(definition.relationList, function(def) {
          var relationName = def.relation;
          var localField = def.localField;
          var localKey = def.localKey;
          var foreignKey = def.foreignKey;
          var localKeys = def.localKeys;
          var enumerable = typeof def.enumerable === 'boolean' ? def.enumerable : !!definition.relationsEnumerable;
          if (typeof def.link === 'boolean' ? def.link : !!definition.linkRelations) {
            delete target[localField];
            var prop = {enumerable: enumerable};
            if (def.type === 'belongsTo') {
              prop.get = function() {
                return get(this, localKey) ? definition.getResource(relationName).get(get(this, localKey)) : undefined;
              };
              prop.set = function(parent) {
                set(this, localKey, get(parent, definition.getResource(relationName).idAttribute));
                return get(this, localField);
              };
            } else if (def.type === 'hasMany') {
              prop.get = function() {
                var params = {};
                if (foreignKey) {
                  params[foreignKey] = this[definition.idAttribute];
                  return definition.getResource(relationName).defaultFilter.call(store, store.store[relationName].collection, relationName, params, {allowSimpleWhere: true});
                } else if (localKeys) {
                  var keys = get(this, localKeys) || [];
                  return definition.getResource(relationName).getAll(isArray(keys) ? keys : _keys(keys));
                }
                return undefined;
              };
              prop.set = function(children) {
                var _this2 = this;
                if (foreignKey) {
                  forEach(children, function(child) {
                    set(child, foreignKey, get(_this2, definition.idAttribute));
                  });
                } else if (localKeys) {
                  (function() {
                    var keys = [];
                    forEach(children, function(child) {
                      keys.push(get(child, definition.getResource(relationName).idAttribute));
                    });
                    set(_this2, localKeys, keys);
                  })();
                }
                return get(this, localField);
              };
            } else if (def.type === 'hasOne') {
              if (localKey) {
                prop.get = function() {
                  return get(this, localKey) ? definition.getResource(relationName).get(get(this, localKey)) : undefined;
                };
                prop.set = function(sibling) {
                  set(this, localKey, get(sibling, definition.getResource(relationName).idAttribute));
                  return get(this, localField);
                };
              } else {
                prop.get = function() {
                  var params = {};
                  params[foreignKey] = this[definition.idAttribute];
                  var items = params[foreignKey] ? definition.getResource(relationName).defaultFilter.call(store, store.store[relationName].collection, relationName, params, {allowSimpleWhere: true}) : [];
                  if (items.length) {
                    return items[0];
                  }
                  return undefined;
                };
                prop.set = function(sibling) {
                  set(sibling, foreignKey, get(this, definition.idAttribute));
                  return get(this, localField);
                };
              }
            }
            if (def.get) {
              (function() {
                var orig = prop.get;
                prop.get = function() {
                  var _this3 = this;
                  return def.get(definition, def, this, function() {
                    for (var _len4 = arguments.length,
                        args = Array(_len4),
                        _key4 = 0; _key4 < _len4; _key4++) {
                      args[_key4] = arguments[_key4];
                    }
                    return orig.apply(_this3, args);
                  });
                };
              })();
            }
            Object.defineProperty(target, localField, prop);
          }
        });
      }
    };
  }, function(module, exports, __webpack_require__) {
    var _get = function get(_x, _x2, _x3) {
      var _again = true;
      _function: while (_again) {
        var object = _x,
            property = _x2,
            receiver = _x3;
        desc = parent = getter = undefined;
        _again = false;
        if (object === null)
          object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return undefined;
          } else {
            _x = parent;
            _x2 = property;
            _x3 = receiver;
            _again = true;
            continue _function;
          }
        } else if ('value' in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === undefined) {
            return undefined;
          }
          return getter.call(receiver);
        }
      }
    };
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== 'function' && superClass !== null) {
        throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }});
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var IllegalArgumentError = (function(_Error) {
      _inherits(IllegalArgumentError, _Error);
      function IllegalArgumentError(message) {
        _classCallCheck(this, IllegalArgumentError);
        _get(Object.getPrototypeOf(IllegalArgumentError.prototype), 'constructor', this).call(this);
        if (typeof Error.captureStackTrace === 'function') {
          Error.captureStackTrace(this, this.constructor);
        }
        this.type = this.constructor.name;
        this.message = message;
      }
      return IllegalArgumentError;
    })(Error);
    var RuntimeError = (function(_Error2) {
      _inherits(RuntimeError, _Error2);
      function RuntimeError(message) {
        _classCallCheck(this, RuntimeError);
        _get(Object.getPrototypeOf(RuntimeError.prototype), 'constructor', this).call(this);
        if (typeof Error.captureStackTrace === 'function') {
          Error.captureStackTrace(this, this.constructor);
        }
        this.type = this.constructor.name;
        this.message = message;
      }
      return RuntimeError;
    })(Error);
    var NonexistentResourceError = (function(_Error3) {
      _inherits(NonexistentResourceError, _Error3);
      function NonexistentResourceError(resourceName) {
        _classCallCheck(this, NonexistentResourceError);
        _get(Object.getPrototypeOf(NonexistentResourceError.prototype), 'constructor', this).call(this);
        if (typeof Error.captureStackTrace === 'function') {
          Error.captureStackTrace(this, this.constructor);
        }
        this.type = this.constructor.name;
        this.message = resourceName + ' is not a registered resource!';
      }
      return NonexistentResourceError;
    })(Error);
    exports['default'] = {
      IllegalArgumentError: IllegalArgumentError,
      IA: IllegalArgumentError,
      RuntimeError: RuntimeError,
      R: RuntimeError,
      NonexistentResourceError: NonexistentResourceError,
      NER: NonexistentResourceError
    };
  }, function(module, exports, __webpack_require__) {
    var _utils = __webpack_require__(2);
    var _errors = __webpack_require__(3);
    var NER = _errors['default'].NER;
    var IA = _errors['default'].IA;
    var R = _errors['default'].R;
    var fakeId = 'DS_' + new Date().getTime();
    function diffIsEmpty(diff) {
      return !(_utils['default'].isEmpty(diff.added) && _utils['default'].isEmpty(diff.removed) && _utils['default'].isEmpty(diff.changed));
    }
    function check(fnName, resourceName, id, options) {
      var _this = this;
      var definition = _this.definitions[resourceName];
      options = options || {};
      id = _utils['default'].resolveId(definition, id);
      if (!definition) {
        throw new NER(resourceName);
      } else if (!_utils['default']._sn(id)) {
        throw _utils['default']._snErr('id');
      }
      id = id === fakeId ? undefined : id;
      options = _utils['default']._(definition, options);
      options.logFn(fnName, id, options);
      return {
        _this: _this,
        definition: definition,
        _resourceName: resourceName,
        _id: id,
        _options: options
      };
    }
    exports['default'] = {
      changes: function changes(resourceName, id, options) {
        var _check$call = check.call(this, 'changes', resourceName, id, options);
        var _this = _check$call._this;
        var definition = _check$call.definition;
        var _resourceName = _check$call._resourceName;
        var _id = _check$call._id;
        var _options = _check$call._options;
        var item = definition.get(_id);
        if (item) {
          var _ret = (function() {
            var observer = _this.store[_resourceName].observers[_id];
            if (observer && typeof observer === 'function') {
              observer.deliver();
            }
            var ignoredChanges = _options.ignoredChanges || [];
            _utils['default'].forEach(definition.relationFields, function(field) {
              if (!_utils['default'].contains(ignoredChanges, field)) {
                ignoredChanges.push(field);
              }
            });
            var diff = _utils['default'].diffObjectFromOldObject(item, _this.store[_resourceName].previousAttributes[_id], _utils['default'].equals, ignoredChanges);
            _utils['default'].forOwn(diff, function(changeset, name) {
              var toKeep = [];
              _utils['default'].forOwn(changeset, function(value, field) {
                if (!_utils['default'].isFunction(value)) {
                  toKeep.push(field);
                }
              });
              diff[name] = _utils['default'].pick(diff[name], toKeep);
            });
            _utils['default'].forEach(definition.relationFields, function(field) {
              delete diff.added[field];
              delete diff.removed[field];
              delete diff.changed[field];
            });
            return {v: diff};
          })();
          if (typeof _ret === 'object')
            return _ret.v;
        }
      },
      changeHistory: function changeHistory(resourceName, id) {
        var _check$call2 = check.call(this, 'changeHistory', resourceName, id || fakeId);
        var _this = _check$call2._this;
        var definition = _check$call2.definition;
        var _resourceName = _check$call2._resourceName;
        var _id = _check$call2._id;
        var resource = _this.store[_resourceName];
        if (!definition.keepChangeHistory) {
          definition.errorFn('changeHistory is disabled for this resource!');
        } else {
          if (_resourceName) {
            var item = definition.get(_id);
            if (item) {
              return resource.changeHistories[_id];
            }
          } else {
            return resource.changeHistory;
          }
        }
      },
      compute: function compute(resourceName, instance) {
        var _this = this;
        var definition = _this.definitions[resourceName];
        instance = _utils['default'].resolveItem(_this.store[resourceName], instance);
        if (!definition) {
          throw new NER(resourceName);
        } else if (!instance) {
          throw new R('Item not in the store!');
        } else if (!_utils['default']._o(instance) && !_utils['default']._sn(instance)) {
          throw new IA('"instance" must be an object, string or number!');
        }
        definition.logFn('compute', instance);
        _utils['default'].forOwn(definition.computed, function(fn, field) {
          _utils['default'].compute.call(instance, fn, field);
        });
        return instance;
      },
      createInstance: function createInstance(resourceName, attrs, options) {
        var definition = this.definitions[resourceName];
        var item = undefined;
        attrs = attrs || {};
        if (!definition) {
          throw new NER(resourceName);
        } else if (attrs && !_utils['default'].isObject(attrs)) {
          throw new IA('"attrs" must be an object!');
        }
        options = _utils['default']._(definition, options);
        options.logFn('createInstance', attrs, options);
        options.beforeCreateInstance(options, attrs);
        var Constructor = definition[definition['class']];
        item = new Constructor();
        if (options.defaultValues) {
          _utils['default'].deepMixIn(item, options.defaultValues);
        }
        _utils['default'].deepMixIn(item, attrs);
        if (definition.computed) {
          definition.compute(item);
        }
        options.afterCreateInstance(options, item);
        return item;
      },
      createCollection: function createCollection(resourceName, arr, params, options) {
        var _this = this;
        var definition = _this.definitions[resourceName];
        arr = arr || [];
        params = params || {};
        if (!definition) {
          throw new NER(resourceName);
        } else if (arr && !_utils['default'].isArray(arr)) {
          throw new IA('"arr" must be an array!');
        }
        options = _utils['default']._(definition, options);
        options.logFn('createCollection', arr, options);
        options.beforeCreateCollection(options, arr);
        Object.defineProperties(arr, {
          fetch: {value: function value(params, options) {
              var __this = this;
              __this.params = params || __this.params;
              return definition.findAll(__this.params, options).then(function(data) {
                if (data === __this) {
                  return __this;
                }
                data.unshift(__this.length);
                data.unshift(0);
                __this.splice.apply(__this, data);
                data.shift();
                data.shift();
                if (data.$$injected) {
                  _this.store[resourceName].queryData[_utils['default'].toJson(__this.params)] = __this;
                  __this.$$injected = true;
                }
                return __this;
              });
            }},
          params: {
            value: params,
            writable: true
          },
          resourceName: {value: resourceName}
        });
        options.afterCreateCollection(options, arr);
        return arr;
      },
      defineResource: __webpack_require__(27),
      digest: function digest() {
        this.observe.Platform.performMicrotaskCheckpoint();
      },
      eject: __webpack_require__(28),
      ejectAll: __webpack_require__(29),
      filter: __webpack_require__(30),
      get: function get(resourceName, id) {
        var _check$call3 = check.call(this, 'get', resourceName, id);
        var _this = _check$call3._this;
        var _resourceName = _check$call3._resourceName;
        var _id = _check$call3._id;
        return _this.store[_resourceName].index[_id];
      },
      getAll: function getAll(resourceName, ids) {
        var _this = this;
        var definition = _this.definitions[resourceName];
        var resource = _this.store[resourceName];
        var collection = [];
        if (!definition) {
          throw new NER(resourceName);
        } else if (ids && !_utils['default']._a(ids)) {
          throw _utils['default']._aErr('ids');
        }
        definition.logFn('getAll', ids);
        if (_utils['default']._a(ids)) {
          var _length = ids.length;
          for (var i = 0; i < _length; i++) {
            if (resource.index[ids[i]]) {
              collection.push(resource.index[ids[i]]);
            }
          }
        } else {
          collection = resource.collection.slice();
        }
        return collection;
      },
      hasChanges: function hasChanges(resourceName, id) {
        var _check$call4 = check.call(this, 'hasChanges', resourceName, id);
        var definition = _check$call4.definition;
        var _id = _check$call4._id;
        return definition.get(_id) ? diffIsEmpty(definition.changes(_id)) : false;
      },
      inject: __webpack_require__(31),
      lastModified: function lastModified(resourceName, id) {
        var _check$call5 = check.call(this, 'lastModified', resourceName, id || fakeId);
        var _this = _check$call5._this;
        var _resourceName = _check$call5._resourceName;
        var _id = _check$call5._id;
        var resource = _this.store[_resourceName];
        if (_id) {
          if (!(_id in resource.modified)) {
            resource.modified[_id] = 0;
          }
          return resource.modified[_id];
        }
        return resource.collectionModified;
      },
      lastSaved: function lastSaved(resourceName, id) {
        var _check$call6 = check.call(this, 'lastSaved', resourceName, id || fakeId);
        var _this = _check$call6._this;
        var _resourceName = _check$call6._resourceName;
        var _id = _check$call6._id;
        var resource = _this.store[_resourceName];
        if (!(_id in resource.saved)) {
          resource.saved[_id] = 0;
        }
        return resource.saved[_id];
      },
      previous: function previous(resourceName, id) {
        var _check$call7 = check.call(this, 'previous', resourceName, id);
        var _this = _check$call7._this;
        var _resourceName = _check$call7._resourceName;
        var _id = _check$call7._id;
        var resource = _this.store[_resourceName];
        return resource.previousAttributes[_id] ? _utils['default'].copy(resource.previousAttributes[_id]) : undefined;
      },
      revert: function revert(resourceName, id) {
        var _check$call8 = check.call(this, 'revert', resourceName, id);
        var _this = _check$call8._this;
        var definition = _check$call8.definition;
        var _resourceName = _check$call8._resourceName;
        var _id = _check$call8._id;
        return definition.inject(_this.previous(_resourceName, _id));
      }
    };
  }, function(module, exports, __webpack_require__) {
    exports['default'] = {
      create: __webpack_require__(34),
      destroy: __webpack_require__(35),
      destroyAll: __webpack_require__(36),
      find: __webpack_require__(37),
      findAll: __webpack_require__(38),
      loadRelations: __webpack_require__(39),
      reap: __webpack_require__(40),
      refresh: function refresh(resourceName, id, options) {
        var _this = this;
        var DSUtils = _this.utils;
        return new DSUtils.Promise(function(resolve, reject) {
          var definition = _this.definitions[resourceName];
          id = DSUtils.resolveId(_this.definitions[resourceName], id);
          if (!definition) {
            reject(new _this.errors.NER(resourceName));
          } else if (!DSUtils._sn(id)) {
            reject(DSUtils._snErr('id'));
          } else {
            options = DSUtils._(definition, options);
            options.bypassCache = true;
            options.logFn('refresh', id, options);
            resolve(_this.get(resourceName, id));
          }
        }).then(function(item) {
          return item ? _this.find(resourceName, id, options) : item;
        });
      },
      refreshAll: function refreshAll(resourceName, params, options) {
        var _this = this;
        var DSUtils = _this.utils;
        var definition = _this.definitions[resourceName];
        params = params || {};
        return new DSUtils.Promise(function(resolve, reject) {
          if (!definition) {
            reject(new _this.errors.NER(resourceName));
          } else if (!DSUtils._o(params)) {
            reject(DSUtils._oErr('params'));
          } else {
            options = DSUtils._(definition, options);
            options.bypassCache = true;
            options.logFn('refreshAll', params, options);
            resolve(_this.filter(resourceName, params, options));
          }
        }).then(function(existing) {
          options.bypassCache = true;
          return _this.findAll(resourceName, params, options).then(function(found) {
            DSUtils.forEach(existing, function(item) {
              if (found.indexOf(item) === -1) {
                definition.eject(item);
              }
            });
            return found;
          });
        });
      },
      save: __webpack_require__(41),
      update: __webpack_require__(42),
      updateAll: __webpack_require__(43)
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var testingExposeCycleCount = global.testingExposeCycleCount;
      function detectObjectObserve() {
        if (typeof Object.observe !== 'function' || typeof Array.observe !== 'function') {
          return false;
        }
        var records = [];
        function callback(recs) {
          records = recs;
        }
        var test = {};
        var arr = [];
        Object.observe(test, callback);
        Array.observe(arr, callback);
        test.id = 1;
        test.id = 2;
        delete test.id;
        arr.push(1, 2);
        arr.length = 0;
        Object.deliverChangeRecords(callback);
        if (records.length !== 5)
          return false;
        if (records[0].type != 'add' || records[1].type != 'update' || records[2].type != 'delete' || records[3].type != 'splice' || records[4].type != 'splice') {
          return false;
        }
        Object.unobserve(test, callback);
        Array.unobserve(arr, callback);
        return true;
      }
      var hasObserve = detectObjectObserve();
      var createObject = ('__proto__' in {}) ? function(obj) {
        return obj;
      } : function(obj) {
        var proto = obj.__proto__;
        if (!proto)
          return obj;
        var newObject = Object.create(proto);
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          Object.defineProperty(newObject, name, Object.getOwnPropertyDescriptor(obj, name));
        });
        return newObject;
      };
      var MAX_DIRTY_CHECK_CYCLES = 1000;
      function dirtyCheck(observer) {
        var cycles = 0;
        while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
          cycles++;
        }
        if (testingExposeCycleCount)
          global.dirtyCheckCycleCount = cycles;
        return cycles > 0;
      }
      function objectIsEmpty(object) {
        for (var prop in object)
          return false;
        return true;
      }
      function diffIsEmpty(diff) {
        return objectIsEmpty(diff.added) && objectIsEmpty(diff.removed) && objectIsEmpty(diff.changed);
      }
      function isBlacklisted(prop, bl) {
        if (!bl || !bl.length) {
          return false;
        }
        var matches;
        for (var i = 0; i < bl.length; i++) {
          if ((Object.prototype.toString.call(bl[i]) === '[object RegExp]' && bl[i].test(prop)) || bl[i] === prop) {
            return matches = prop;
          }
        }
        return !!matches;
      }
      function diffObjectFromOldObject(object, oldObject, equals, bl) {
        var added = {};
        var removed = {};
        var changed = {};
        for (var prop in oldObject) {
          var newValue = object[prop];
          if (isBlacklisted(prop, bl))
            continue;
          if (newValue !== undefined && (equals ? equals(newValue, oldObject[prop]) : newValue === oldObject[prop]))
            continue;
          if (!(prop in object)) {
            removed[prop] = undefined;
            continue;
          }
          if (equals ? !equals(newValue, oldObject[prop]) : newValue !== oldObject[prop])
            changed[prop] = newValue;
        }
        for (var prop in object) {
          if (prop in oldObject)
            continue;
          if (isBlacklisted(prop, bl))
            continue;
          added[prop] = object[prop];
        }
        if (Array.isArray(object) && object.length !== oldObject.length)
          changed.length = object.length;
        return {
          added: added,
          removed: removed,
          changed: changed
        };
      }
      var eomTasks = [];
      function runEOMTasks() {
        if (!eomTasks.length)
          return false;
        for (var i = 0; i < eomTasks.length; i++) {
          eomTasks[i]();
        }
        eomTasks.length = 0;
        return true;
      }
      var runEOM = hasObserve ? (function() {
        return function(fn) {
          return Promise.resolve().then(fn);
        };
      })() : (function() {
        return function(fn) {
          eomTasks.push(fn);
        };
      })();
      var observedObjectCache = [];
      function newObservedObject() {
        var observer;
        var object;
        var discardRecords = false;
        var first = true;
        function callback(records) {
          if (observer && observer.state_ === OPENED && !discardRecords)
            observer.check_(records);
        }
        return {
          open: function(obs) {
            if (observer)
              throw Error('ObservedObject in use');
            if (!first)
              Object.deliverChangeRecords(callback);
            observer = obs;
            first = false;
          },
          observe: function(obj, arrayObserve) {
            object = obj;
            if (arrayObserve)
              Array.observe(object, callback);
            else
              Object.observe(object, callback);
          },
          deliver: function(discard) {
            discardRecords = discard;
            Object.deliverChangeRecords(callback);
            discardRecords = false;
          },
          close: function() {
            observer = undefined;
            Object.unobserve(object, callback);
            observedObjectCache.push(this);
          }
        };
      }
      function getObservedObject(observer, object, arrayObserve) {
        var dir = observedObjectCache.pop() || newObservedObject();
        dir.open(observer);
        dir.observe(object, arrayObserve);
        return dir;
      }
      var UNOPENED = 0;
      var OPENED = 1;
      var CLOSED = 2;
      var nextObserverId = 1;
      function Observer() {
        this.state_ = UNOPENED;
        this.callback_ = undefined;
        this.target_ = undefined;
        this.directObserver_ = undefined;
        this.value_ = undefined;
        this.id_ = nextObserverId++;
      }
      Observer.prototype = {
        open: function(callback, target) {
          if (this.state_ != UNOPENED)
            throw Error('Observer has already been opened.');
          addToAll(this);
          this.callback_ = callback;
          this.target_ = target;
          this.connect_();
          this.state_ = OPENED;
          return this.value_;
        },
        close: function() {
          if (this.state_ != OPENED)
            return ;
          removeFromAll(this);
          this.disconnect_();
          this.value_ = undefined;
          this.callback_ = undefined;
          this.target_ = undefined;
          this.state_ = CLOSED;
        },
        deliver: function() {
          if (this.state_ != OPENED)
            return ;
          dirtyCheck(this);
        },
        report_: function(changes) {
          try {
            this.callback_.apply(this.target_, changes);
          } catch (ex) {
            Observer._errorThrownDuringCallback = true;
            console.error('Exception caught during observer callback: ' + (ex.stack || ex));
          }
        },
        discardChanges: function() {
          this.check_(undefined, true);
          return this.value_;
        }
      };
      var collectObservers = !hasObserve;
      var allObservers;
      Observer._allObserversCount = 0;
      if (collectObservers) {
        allObservers = [];
      }
      function addToAll(observer) {
        Observer._allObserversCount++;
        if (!collectObservers)
          return ;
        allObservers.push(observer);
      }
      function removeFromAll(observer) {
        Observer._allObserversCount--;
      }
      var runningMicrotaskCheckpoint = false;
      global.Platform = global.Platform || {};
      global.Platform.performMicrotaskCheckpoint = function() {
        if (runningMicrotaskCheckpoint)
          return ;
        if (!collectObservers)
          return ;
        runningMicrotaskCheckpoint = true;
        var cycles = 0;
        var anyChanged,
            toCheck;
        do {
          cycles++;
          toCheck = allObservers;
          allObservers = [];
          anyChanged = false;
          for (var i = 0; i < toCheck.length; i++) {
            var observer = toCheck[i];
            if (observer.state_ != OPENED)
              continue;
            if (observer.check_())
              anyChanged = true;
            allObservers.push(observer);
          }
          if (runEOMTasks())
            anyChanged = true;
        } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);
        if (testingExposeCycleCount)
          global.dirtyCheckCycleCount = cycles;
        runningMicrotaskCheckpoint = false;
      };
      if (collectObservers) {
        global.Platform.clearObservers = function() {
          allObservers = [];
        };
      }
      function ObjectObserver(object) {
        Observer.call(this);
        this.value_ = object;
        this.oldObject_ = undefined;
      }
      ObjectObserver.prototype = createObject({
        __proto__: Observer.prototype,
        arrayObserve: false,
        connect_: function(callback, target) {
          if (hasObserve) {
            this.directObserver_ = getObservedObject(this, this.value_, this.arrayObserve);
          } else {
            this.oldObject_ = this.copyObject(this.value_);
          }
        },
        copyObject: function(object) {
          var copy = Array.isArray(object) ? [] : {};
          for (var prop in object) {
            copy[prop] = object[prop];
          }
          ;
          if (Array.isArray(object))
            copy.length = object.length;
          return copy;
        },
        check_: function(changeRecords, skipChanges) {
          var diff;
          var oldValues;
          if (hasObserve) {
            if (!changeRecords)
              return false;
            oldValues = {};
            diff = diffObjectFromChangeRecords(this.value_, changeRecords, oldValues);
          } else {
            oldValues = this.oldObject_;
            diff = diffObjectFromOldObject(this.value_, this.oldObject_);
          }
          if (diffIsEmpty(diff))
            return false;
          if (!hasObserve)
            this.oldObject_ = this.copyObject(this.value_);
          this.report_([diff.added || {}, diff.removed || {}, diff.changed || {}, function(property) {
            return oldValues[property];
          }]);
          return true;
        },
        disconnect_: function() {
          if (hasObserve) {
            this.directObserver_.close();
            this.directObserver_ = undefined;
          } else {
            this.oldObject_ = undefined;
          }
        },
        deliver: function() {
          if (this.state_ != OPENED)
            return ;
          if (hasObserve)
            this.directObserver_.deliver(false);
          else
            dirtyCheck(this);
        },
        discardChanges: function() {
          if (this.directObserver_)
            this.directObserver_.deliver(true);
          else
            this.oldObject_ = this.copyObject(this.value_);
          return this.value_;
        }
      });
      var observerSentinel = {};
      var expectedRecordTypes = {
        add: true,
        update: true,
        'delete': true
      };
      function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
        var added = {};
        var removed = {};
        for (var i = 0; i < changeRecords.length; i++) {
          var record = changeRecords[i];
          if (!expectedRecordTypes[record.type]) {
            console.error('Unknown changeRecord type: ' + record.type);
            console.error(record);
            continue;
          }
          if (!(record.name in oldValues))
            oldValues[record.name] = record.oldValue;
          if (record.type == 'update')
            continue;
          if (record.type == 'add') {
            if (record.name in removed)
              delete removed[record.name];
            else
              added[record.name] = true;
            continue;
          }
          if (record.name in added) {
            delete added[record.name];
            delete oldValues[record.name];
          } else {
            removed[record.name] = true;
          }
        }
        for (var prop in added)
          added[prop] = object[prop];
        for (var prop in removed)
          removed[prop] = undefined;
        var changed = {};
        for (var prop in oldValues) {
          if (prop in added || prop in removed)
            continue;
          var newValue = object[prop];
          if (oldValues[prop] !== newValue)
            changed[prop] = newValue;
        }
        return {
          added: added,
          removed: removed,
          changed: changed
        };
      }
      global.Observer = Observer;
      global.isBlacklisted = isBlacklisted;
      global.Observer.runEOM_ = runEOM;
      global.Observer.observerSentinel_ = observerSentinel;
      global.Observer.hasObjectObserve = hasObserve;
      global.diffObjectFromOldObject = diffObjectFromOldObject;
      global.ObjectObserver = ObjectObserver;
    })(exports);
  }, function(module, exports, __webpack_require__) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (true)
        module.exports = factory();
      else if (typeof define === 'function' && define.amd)
        System.register("github:js-data/js-data@2.3.0/dist/js-data-debug", [], false, typeof factory == "function" ? factory : function() {
          return factory;
        });
      else if (typeof exports === 'object')
        exports["BinaryHeap"] = factory();
      else
        root["BinaryHeap"] = factory();
    })(this, function() {
      return (function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          module.loaded = true;
          return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      })([function(module, exports, __webpack_require__) {
        function bubbleUp(heap, weightFunc, n) {
          var element = heap[n];
          var weight = weightFunc(element);
          while (n > 0) {
            var parentN = Math.floor((n + 1) / 2) - 1;
            var _parent = heap[parentN];
            if (weight >= weightFunc(_parent)) {
              break;
            } else {
              heap[parentN] = element;
              heap[n] = _parent;
              n = parentN;
            }
          }
        }
        var bubbleDown = function bubbleDown(heap, weightFunc, n) {
          var length = heap.length;
          var node = heap[n];
          var nodeWeight = weightFunc(node);
          while (true) {
            var child2N = (n + 1) * 2,
                child1N = child2N - 1;
            var swap = null;
            if (child1N < length) {
              var child1 = heap[child1N],
                  child1Weight = weightFunc(child1);
              if (child1Weight < nodeWeight) {
                swap = child1N;
              }
            }
            if (child2N < length) {
              var child2 = heap[child2N],
                  child2Weight = weightFunc(child2);
              if (child2Weight < (swap === null ? nodeWeight : weightFunc(heap[child1N]))) {
                swap = child2N;
              }
            }
            if (swap === null) {
              break;
            } else {
              heap[n] = heap[swap];
              heap[swap] = node;
              n = swap;
            }
          }
        };
        function BinaryHeap(weightFunc, compareFunc) {
          if (!weightFunc) {
            weightFunc = function(x) {
              return x;
            };
          }
          if (!compareFunc) {
            compareFunc = function(x, y) {
              return x === y;
            };
          }
          if (typeof weightFunc !== 'function') {
            throw new Error('BinaryHeap([weightFunc][, compareFunc]): "weightFunc" must be a function!');
          }
          if (typeof compareFunc !== 'function') {
            throw new Error('BinaryHeap([weightFunc][, compareFunc]): "compareFunc" must be a function!');
          }
          this.weightFunc = weightFunc;
          this.compareFunc = compareFunc;
          this.heap = [];
        }
        var BHProto = BinaryHeap.prototype;
        BHProto.push = function(node) {
          this.heap.push(node);
          bubbleUp(this.heap, this.weightFunc, this.heap.length - 1);
        };
        BHProto.peek = function() {
          return this.heap[0];
        };
        BHProto.pop = function() {
          var front = this.heap[0];
          var end = this.heap.pop();
          if (this.heap.length > 0) {
            this.heap[0] = end;
            bubbleDown(this.heap, this.weightFunc, 0);
          }
          return front;
        };
        BHProto.remove = function(node) {
          var length = this.heap.length;
          for (var i = 0; i < length; i++) {
            if (this.compareFunc(this.heap[i], node)) {
              var removed = this.heap[i];
              var end = this.heap.pop();
              if (i !== length - 1) {
                this.heap[i] = end;
                bubbleUp(this.heap, this.weightFunc, i);
                bubbleDown(this.heap, this.weightFunc, i);
              }
              return removed;
            }
          }
          return null;
        };
        BHProto.removeAll = function() {
          this.heap = [];
        };
        BHProto.size = function() {
          return this.heap.length;
        };
        module.exports = BinaryHeap;
      }]);
    });
    ;
  }, function(module, exports, __webpack_require__) {
    function forEach(arr, callback, thisObj) {
      if (arr == null) {
        return ;
      }
      var i = -1,
          len = arr.length;
      while (++i < len) {
        if (callback.call(thisObj, arr[i], i, arr) === false) {
          break;
        }
      }
    }
    module.exports = forEach;
  }, function(module, exports, __webpack_require__) {
    function slice(arr, start, end) {
      var len = arr.length;
      if (start == null) {
        start = 0;
      } else if (start < 0) {
        start = Math.max(len + start, 0);
      } else {
        start = Math.min(start, len);
      }
      if (end == null) {
        end = len;
      } else if (end < 0) {
        end = Math.max(len + end, 0);
      } else {
        end = Math.min(end, len);
      }
      var result = [];
      while (start < end) {
        result.push(arr[start++]);
      }
      return result;
    }
    module.exports = slice;
  }, function(module, exports, __webpack_require__) {
    var indexOf = __webpack_require__(21);
    function contains(arr, val) {
      return indexOf(arr, val) !== -1;
    }
    module.exports = contains;
  }, function(module, exports, __webpack_require__) {
    var indexOf = __webpack_require__(21);
    function remove(arr, item) {
      var idx = indexOf(arr, item);
      if (idx !== -1)
        arr.splice(idx, 1);
    }
    module.exports = remove;
  }, function(module, exports, __webpack_require__) {
    function mergeSort(arr, compareFn) {
      if (arr == null) {
        return [];
      } else if (arr.length < 2) {
        return arr;
      }
      if (compareFn == null) {
        compareFn = defaultCompare;
      }
      var mid,
          left,
          right;
      mid = ~~(arr.length / 2);
      left = mergeSort(arr.slice(0, mid), compareFn);
      right = mergeSort(arr.slice(mid, arr.length), compareFn);
      return merge(left, right, compareFn);
    }
    function defaultCompare(a, b) {
      return a < b ? -1 : (a > b ? 1 : 0);
    }
    function merge(left, right, compareFn) {
      var result = [];
      while (left.length && right.length) {
        if (compareFn(left[0], right[0]) <= 0) {
          result.push(left.shift());
        } else {
          result.push(right.shift());
        }
      }
      if (left.length) {
        result.push.apply(result, left);
      }
      if (right.length) {
        result.push.apply(result, right);
      }
      return result;
    }
    module.exports = mergeSort;
  }, function(module, exports, __webpack_require__) {
    var hasOwn = __webpack_require__(22);
    var forIn = __webpack_require__(23);
    function forOwn(obj, fn, thisObj) {
      forIn(obj, function(val, key) {
        if (hasOwn(obj, key)) {
          return fn.call(thisObj, obj[key], key, obj);
        }
      });
    }
    module.exports = forOwn;
  }, function(module, exports, __webpack_require__) {
    var forOwn = __webpack_require__(13);
    var isPlainObject = __webpack_require__(24);
    function deepMixIn(target, objects) {
      var i = 0,
          n = arguments.length,
          obj;
      while (++i < n) {
        obj = arguments[i];
        if (obj) {
          forOwn(obj, copyProp, target);
        }
      }
      return target;
    }
    function copyProp(val, key) {
      var existing = this[key];
      if (isPlainObject(val) && isPlainObject(existing)) {
        deepMixIn(existing, val);
      } else {
        this[key] = val;
      }
    }
    module.exports = deepMixIn;
  }, function(module, exports, __webpack_require__) {
    var slice = __webpack_require__(9);
    function pick(obj, var_keys) {
      var keys = typeof arguments[1] !== 'string' ? arguments[1] : slice(arguments, 1),
          out = {},
          i = 0,
          key;
      while (key = keys[i++]) {
        out[key] = obj[key];
      }
      return out;
    }
    module.exports = pick;
  }, function(module, exports, __webpack_require__) {
    var forOwn = __webpack_require__(13);
    var keys = Object.keys || function(obj) {
      var keys = [];
      forOwn(obj, function(val, key) {
        keys.push(key);
      });
      return keys;
    };
    module.exports = keys;
  }, function(module, exports, __webpack_require__) {
    var isPrimitive = __webpack_require__(26);
    function get(obj, prop) {
      var parts = prop.split('.'),
          last = parts.pop();
      while (prop = parts.shift()) {
        obj = obj[prop];
        if (obj == null)
          return ;
      }
      return obj[last];
    }
    module.exports = get;
  }, function(module, exports, __webpack_require__) {
    var namespace = __webpack_require__(25);
    function set(obj, prop, val) {
      var parts = (/^(.+)\.(.+)$/).exec(prop);
      if (parts) {
        namespace(obj, parts[1])[parts[2]] = val;
      } else {
        obj[prop] = val;
      }
    }
    module.exports = set;
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    var camelCase = __webpack_require__(33);
    var upperCase = __webpack_require__(20);
    function pascalCase(str) {
      str = toString(str);
      return camelCase(str).replace(/^[a-z]/, upperCase);
    }
    module.exports = pascalCase;
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    function upperCase(str) {
      str = toString(str);
      return str.toUpperCase();
    }
    module.exports = upperCase;
  }, function(module, exports, __webpack_require__) {
    function indexOf(arr, item, fromIndex) {
      fromIndex = fromIndex || 0;
      if (arr == null) {
        return -1;
      }
      var len = arr.length,
          i = fromIndex < 0 ? len + fromIndex : fromIndex;
      while (i < len) {
        if (arr[i] === item) {
          return i;
        }
        i++;
      }
      return -1;
    }
    module.exports = indexOf;
  }, function(module, exports, __webpack_require__) {
    function hasOwn(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = hasOwn;
  }, function(module, exports, __webpack_require__) {
    var hasOwn = __webpack_require__(22);
    var _hasDontEnumBug,
        _dontEnums;
    function checkDontEnum() {
      _dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
      _hasDontEnumBug = true;
      for (var key in {'toString': null}) {
        _hasDontEnumBug = false;
      }
    }
    function forIn(obj, fn, thisObj) {
      var key,
          i = 0;
      if (_hasDontEnumBug == null)
        checkDontEnum();
      for (key in obj) {
        if (exec(fn, obj, key, thisObj) === false) {
          break;
        }
      }
      if (_hasDontEnumBug) {
        var ctor = obj.constructor,
            isProto = !!ctor && obj === ctor.prototype;
        while (key = _dontEnums[i++]) {
          if ((key !== 'constructor' || (!isProto && hasOwn(obj, key))) && obj[key] !== Object.prototype[key]) {
            if (exec(fn, obj, key, thisObj) === false) {
              break;
            }
          }
        }
      }
    }
    function exec(fn, obj, key, thisObj) {
      return fn.call(thisObj, obj[key], key, obj);
    }
    module.exports = forIn;
  }, function(module, exports, __webpack_require__) {
    function isPlainObject(value) {
      return (!!value && typeof value === 'object' && value.constructor === Object);
    }
    module.exports = isPlainObject;
  }, function(module, exports, __webpack_require__) {
    var forEach = __webpack_require__(8);
    function namespace(obj, path) {
      if (!path)
        return obj;
      forEach(path.split('.'), function(key) {
        if (!obj[key]) {
          obj[key] = {};
        }
        obj = obj[key];
      });
      return obj;
    }
    module.exports = namespace;
  }, function(module, exports, __webpack_require__) {
    function isPrimitive(value) {
      switch (typeof value) {
        case "string":
        case "number":
        case "boolean":
          return true;
      }
      return value == null;
    }
    module.exports = isPrimitive;
  }, function(module, exports, __webpack_require__) {
    var _utils = __webpack_require__(2);
    var _errors = __webpack_require__(3);
    var instanceMethods = ['compute', 'eject', 'refresh', 'save', 'update', 'destroy', 'loadRelations', 'changeHistory', 'changes', 'hasChanges', 'lastModified', 'lastSaved', 'previous', 'revert'];
    module.exports = function defineResource(definition) {
      var _this = this;
      var definitions = _this.definitions;
      if (_utils['default']._s(definition)) {
        definition = {name: definition.replace(/\s/gi, '')};
      }
      if (!_utils['default']._o(definition)) {
        throw _utils['default']._oErr('definition');
      } else if (!_utils['default']._s(definition.name)) {
        throw new _errors['default'].IA('"name" must be a string!');
      } else if (definitions[definition.name]) {
        throw new _errors['default'].R(definition.name + ' is already registered!');
      }
      function Resource(options) {
        this.defaultValues = {};
        this.methods = {};
        this.computed = {};
        _utils['default'].deepMixIn(this, options);
        var parent = _this.defaults;
        if (definition['extends'] && definitions[definition['extends']]) {
          parent = definitions[definition['extends']];
        }
        _utils['default'].fillIn(this.defaultValues, parent.defaultValues);
        _utils['default'].fillIn(this.methods, parent.methods);
        _utils['default'].fillIn(this.computed, parent.computed);
        this.endpoint = 'endpoint' in options ? options.endpoint : this.name;
      }
      try {
        var def;
        var _class;
        var _ret = (function() {
          if (definition['extends'] && definitions[definition['extends']]) {
            Resource.prototype = definitions[definition['extends']];
          } else {
            Resource.prototype = _this.defaults;
          }
          definitions[definition.name] = new Resource(definition);
          def = definitions[definition.name];
          def.getResource = function(resourceName) {
            return _this.definitions[resourceName];
          };
          def.logFn('Preparing resource.');
          if (!_utils['default']._s(def.idAttribute)) {
            throw new _errors['default'].IA('"idAttribute" must be a string!');
          }
          if (def.relations) {
            def.relationList = [];
            def.relationFields = [];
            _utils['default'].forOwn(def.relations, function(relatedModels, type) {
              _utils['default'].forOwn(relatedModels, function(defs, relationName) {
                if (!_utils['default']._a(defs)) {
                  relatedModels[relationName] = [defs];
                }
                _utils['default'].forEach(relatedModels[relationName], function(d) {
                  d.type = type;
                  d.relation = relationName;
                  d.name = def.name;
                  def.relationList.push(d);
                  if (d.localField) {
                    def.relationFields.push(d.localField);
                  }
                });
              });
            });
            if (def.relations.belongsTo) {
              _utils['default'].forOwn(def.relations.belongsTo, function(relatedModel, modelName) {
                _utils['default'].forEach(relatedModel, function(relation) {
                  if (relation.parent) {
                    def.parent = modelName;
                    def.parentKey = relation.localKey;
                    def.parentField = relation.localField;
                  }
                });
              });
            }
            if (typeof Object.freeze === 'function') {
              Object.freeze(def.relations);
              Object.freeze(def.relationList);
            }
          }
          _class = def['class'] = _utils['default'].pascalCase(def.name);
          try {
            if (typeof def.useClass === 'function') {
              eval('function ' + _class + '() { def.useClass.call(this); }');
              def[_class] = eval(_class);
              def[_class].prototype = (function(proto) {
                function Ctor() {}
                Ctor.prototype = proto;
                return new Ctor();
              })(def.useClass.prototype);
            } else {
              eval('function ' + _class + '() {}');
              def[_class] = eval(_class);
            }
          } catch (e) {
            def[_class] = function() {};
          }
          _utils['default'].forOwn(def.methods, function(fn, m) {
            def[_class].prototype[m] = fn;
          });
          def[_class].prototype.set = function(key, value) {
            var _this2 = this;
            _utils['default'].set(this, key, value);
            def.compute(this);
            if (def.instanceEvents) {
              setTimeout(function() {
                _this2.emit('DS.change', def, _this2);
              }, 0);
            }
            def.handleChange(this);
            return this;
          };
          def[_class].prototype.get = function(key) {
            return _utils['default'].get(this, key);
          };
          if (def.instanceEvents) {
            _utils['default'].Events(def[_class].prototype);
          }
          _utils['default'].applyRelationGettersToTarget(_this, def, def[_class].prototype);
          var parentOmit = null;
          if (!def.hasOwnProperty('omit')) {
            parentOmit = def.omit;
            def.omit = [];
          } else {
            parentOmit = _this.defaults.omit;
          }
          def.omit = def.omit.concat(parentOmit || []);
          _utils['default'].forOwn(def.computed, function(fn, field) {
            if (_utils['default'].isFunction(fn)) {
              def.computed[field] = [fn];
              fn = def.computed[field];
            }
            if (def.methods && field in def.methods) {
              def.errorFn('Computed property "' + field + '" conflicts with previously defined prototype method!');
            }
            def.omit.push(field);
            if (_utils['default'].isArray(fn)) {
              var deps;
              if (fn.length === 1) {
                var match = fn[0].toString().match(/function.*?\(([\s\S]*?)\)/);
                deps = match[1].split(',');
                deps = _utils['default'].filter(deps, function(x) {
                  return x;
                });
                def.computed[field] = deps.concat(fn);
                fn = def.computed[field];
                if (deps.length) {
                  def.errorFn('Use the computed property array syntax for compatibility with minified code!');
                }
              }
              deps = fn.slice(0, fn.length - 1);
              _utils['default'].forEach(deps, function(val, index) {
                deps[index] = val.trim();
              });
              fn.deps = _utils['default'].filter(deps, function(dep) {
                return !!dep;
              });
            } else if (_utils['default'].isObject(fn)) {
              Object.defineProperty(def[_class].prototype, field, fn);
            }
          });
          _utils['default'].forEach(instanceMethods, function(name) {
            def[_class].prototype['DS' + _utils['default'].pascalCase(name)] = function() {
              for (var _len = arguments.length,
                  args = Array(_len),
                  _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              args.unshift(this[def.idAttribute] || this);
              args.unshift(def.name);
              return _this[name].apply(_this, args);
            };
          });
          def[_class].prototype.DSCreate = function() {
            for (var _len2 = arguments.length,
                args = Array(_len2),
                _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            args.unshift(this);
            args.unshift(def.name);
            return _this.create.apply(_this, args);
          };
          _this.store[def.name] = {
            collection: [],
            expiresHeap: new _utils['default'].BinaryHeap(function(x) {
              return x.expires;
            }, function(x, y) {
              return x.item === y;
            }),
            completedQueries: {},
            queryData: {},
            pendingQueries: {},
            index: {},
            modified: {},
            saved: {},
            previousAttributes: {},
            observers: {},
            changeHistories: {},
            changeHistory: [],
            collectionModified: 0
          };
          var resource = _this.store[def.name];
          if (def.reapInterval) {
            setInterval(function() {
              return def.reap();
            }, def.reapInterval);
          }
          var fns = ['registerAdapter', 'getAdapterName', 'getAdapter', 'is', '!clear'];
          for (var key in _this) {
            if (typeof _this[key] === 'function') {
              fns.push(key);
            }
          }
          _utils['default'].forEach(fns, function(key) {
            var k = key;
            if (k[0] === '!') {
              return ;
            }
            if (_this[k].shorthand !== false) {
              def[k] = function() {
                for (var _len3 = arguments.length,
                    args = Array(_len3),
                    _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }
                args.unshift(def.name);
                return _this[k].apply(_this, args);
              };
              def[k].before = function(fn) {
                var orig = def[k];
                def[k] = function() {
                  for (var _len4 = arguments.length,
                      args = Array(_len4),
                      _key4 = 0; _key4 < _len4; _key4++) {
                    args[_key4] = arguments[_key4];
                  }
                  return orig.apply(def, fn.apply(def, args) || args);
                };
              };
            } else {
              def[k] = function() {
                for (var _len5 = arguments.length,
                    args = Array(_len5),
                    _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }
                return _this[k].apply(_this, args);
              };
            }
          });
          def.beforeValidate = _utils['default'].promisify(def.beforeValidate);
          def.validate = _utils['default'].promisify(def.validate);
          def.afterValidate = _utils['default'].promisify(def.afterValidate);
          def.beforeCreate = _utils['default'].promisify(def.beforeCreate);
          def.afterCreate = _utils['default'].promisify(def.afterCreate);
          def.beforeUpdate = _utils['default'].promisify(def.beforeUpdate);
          def.afterUpdate = _utils['default'].promisify(def.afterUpdate);
          def.beforeDestroy = _utils['default'].promisify(def.beforeDestroy);
          def.afterDestroy = _utils['default'].promisify(def.afterDestroy);
          var defaultAdapter = undefined;
          if (def.hasOwnProperty('defaultAdapter')) {
            defaultAdapter = def.defaultAdapter;
          }
          _utils['default'].forOwn(def.actions, function(action, name) {
            if (def[name] && !def.actions[name]) {
              throw new Error('Cannot override existing method "' + name + '"!');
            }
            action.request = action.request || function(config) {
              return config;
            };
            action.response = action.response || function(response) {
              return response;
            };
            action.responseError = action.responseError || function(err) {
              return _utils['default'].Promise.reject(err);
            };
            def[name] = function(id, options) {
              if (_utils['default']._o(id)) {
                options = id;
              }
              options = options || {};
              var adapter = def.getAdapter(action.adapter || defaultAdapter || 'http');
              var config = _utils['default'].deepMixIn({}, action);
              if (!options.hasOwnProperty('endpoint') && config.endpoint) {
                options.endpoint = config.endpoint;
              }
              if (typeof options.getEndpoint === 'function') {
                config.url = options.getEndpoint(def, options);
              } else {
                var args = [options.basePath || adapter.defaults.basePath || def.basePath, adapter.getEndpoint(def, _utils['default']._sn(id) ? id : null, options)];
                if (_utils['default']._sn(id)) {
                  args.push(id);
                }
                args.push(action.pathname || name);
                config.url = _utils['default'].makePath.apply(null, args);
              }
              config.method = config.method || 'GET';
              _utils['default'].deepMixIn(config, options);
              return new _utils['default'].Promise(function(r) {
                return r(config);
              }).then(options.request || action.request).then(function(config) {
                return adapter.HTTP(config);
              }).then(options.response || action.response, options.responseError || action.responseError);
            };
          });
          _utils['default'].Events(def);
          def.handleChange = function(data) {
            resource.collectionModified = _utils['default'].updateTimestamp(resource.collectionModified);
            if (def.notify) {
              setTimeout(function() {
                def.emit('DS.change', def, data);
              }, 0);
            }
          };
          def.logFn('Done preparing resource.');
          return {v: def};
        })();
        if (typeof _ret === 'object')
          return _ret.v;
      } catch (err) {
        _this.defaults.errorFn(err);
        delete definitions[definition.name];
        delete _this.store[definition.name];
        throw err;
      }
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function eject(resourceName, id, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var item = undefined;
      var found = false;
      id = DSUtils.resolveId(definition, id);
      if (!definition) {
        throw new _this.errors.NER(resourceName);
      } else if (!DSUtils._sn(id)) {
        throw DSUtils._snErr('id');
      }
      options = DSUtils._(definition, options);
      options.logFn('eject', id, options);
      for (var i = 0; i < resource.collection.length; i++) {
        if (resource.collection[i][definition.idAttribute] == id) {
          item = resource.collection[i];
          resource.expiresHeap.remove(item);
          found = true;
          break;
        }
      }
      if (found) {
        var _ret = (function() {
          definition.beforeEject(options, item);
          if (options.notify) {
            definition.emit('DS.beforeEject', definition, item);
          }
          var toRemove = [];
          DSUtils.forOwn(resource.queryData, function(items, queryHash) {
            if (items.$$injected) {
              DSUtils.remove(items, item);
            }
            if (!items.length && options.clearEmptyQueries) {
              toRemove.push(queryHash);
            }
          });
          DSUtils.forEach(resource.changeHistories[id], function(changeRecord) {
            DSUtils.remove(resource.changeHistory, changeRecord);
          });
          DSUtils.forEach(toRemove, function(queryHash) {
            delete resource.completedQueries[queryHash];
            delete resource.queryData[queryHash];
          });
          if (resource.observers[id] && typeof resource.observers[id].close === 'function') {
            resource.observers[id].close();
          }
          delete resource.observers[id];
          delete resource.index[id];
          delete resource.previousAttributes[id];
          delete resource.completedQueries[id];
          delete resource.pendingQueries[id];
          delete resource.changeHistories[id];
          delete resource.modified[id];
          delete resource.saved[id];
          resource.collection.splice(i, 1);
          definition.handleChange(item);
          definition.afterEject(options, item);
          if (options.notify) {
            definition.emit('DS.afterEject', definition, item);
          }
          return {v: item};
        })();
        if (typeof _ret === 'object')
          return _ret.v;
      }
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function ejectAll(resourceName, params, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      params = params || {};
      if (!definition) {
        throw new _this.errors.NER(resourceName);
      } else if (!DSUtils._o(params)) {
        throw DSUtils._oErr('params');
      }
      definition.logFn('ejectAll', params, options);
      var resource = _this.store[resourceName];
      var queryHash = DSUtils.toJson(params);
      var items = definition.filter(params);
      if (DSUtils.isEmpty(params)) {
        resource.completedQueries = {};
      } else {
        delete resource.completedQueries[queryHash];
      }
      DSUtils.forEach(items, function(item) {
        if (item && item[definition.idAttribute]) {
          definition.eject(item[definition.idAttribute], options);
        }
      });
      definition.handleChange(items);
      return items;
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function filter(resourceName, params, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      if (!definition) {
        throw new _this.errors.NER(resourceName);
      } else if (params && !DSUtils._o(params)) {
        throw DSUtils._oErr('params');
      }
      params = params || {};
      options = DSUtils._(definition, options);
      options.logFn('filter', params, options);
      return definition.defaultFilter.call(_this, _this.store[resourceName].collection, resourceName, params, options);
    };
  }, function(module, exports, __webpack_require__) {
    var _utils = __webpack_require__(2);
    var _errors = __webpack_require__(3);
    function makeObserverHandler(definition, resource) {
      var DS = this;
      var name = definition.name;
      return function _react(added, removed, changed, oldValueFn, firstTime) {
        var target = this;
        var item = undefined;
        var innerId = oldValueFn && oldValueFn(definition.idAttribute) ? oldValueFn(definition.idAttribute) : target[definition.idAttribute];
        _utils['default'].forEach(definition.relationFields, function(field) {
          delete added[field];
          delete removed[field];
          delete changed[field];
        });
        if (!_utils['default'].isEmpty(added) || !_utils['default'].isEmpty(removed) || !_utils['default'].isEmpty(changed) || firstTime) {
          item = DS.get(name, innerId);
          resource.modified[innerId] = _utils['default'].updateTimestamp(resource.modified[innerId]);
          if (item && definition.instanceEvents) {
            setTimeout(function() {
              item.emit('DS.change', definition, item);
            }, 0);
          }
          definition.handleChange(item);
          if (definition.keepChangeHistory) {
            var changeRecord = {
              resourceName: name,
              target: item,
              added: added,
              removed: removed,
              changed: changed,
              timestamp: resource.modified[innerId]
            };
            resource.changeHistories[innerId].push(changeRecord);
            resource.changeHistory.push(changeRecord);
          }
        }
        if (definition.computed) {
          item = item || DS.get(name, innerId);
          _utils['default'].forOwn(definition.computed, function(fn, field) {
            var compute = false;
            _utils['default'].forEach(fn.deps, function(dep) {
              if (dep in added || dep in removed || dep in changed || !(field in item)) {
                compute = true;
              }
            });
            compute = compute || !fn.deps.length;
            if (compute) {
              _utils['default'].compute.call(item, fn, field);
            }
          });
        }
        if (definition.idAttribute in changed) {
          definition.errorFn('Doh! You just changed the primary key of an object! Your data for the "' + name + '" resource is now in an undefined (probably broken) state.');
        }
      };
    }
    function _inject(definition, resource, attrs, options) {
      var _this = this;
      var injected = undefined;
      if (_utils['default']._a(attrs)) {
        injected = [];
        for (var i = 0; i < attrs.length; i++) {
          injected.push(_inject.call(_this, definition, resource, attrs[i], options));
        }
      } else {
        var _react = makeObserverHandler.call(_this, definition, resource);
        var c = definition.computed;
        var idA = definition.idAttribute;
        if (c && c[idA]) {
          (function() {
            var args = [];
            _utils['default'].forEach(c[idA].deps, function(dep) {
              args.push(attrs[dep]);
            });
            attrs[idA] = c[idA][c[idA].length - 1].apply(attrs, args);
          })();
        }
        if (!(idA in attrs)) {
          var error = new _errors['default'].R(definition.name + '.inject: "attrs" must contain the property specified by "idAttribute"!');
          options.errorFn(error);
          throw error;
        } else {
          try {
            (function() {
              _utils['default'].forEach(definition.relationList, function(def) {
                var relationName = def.relation;
                var relationDef = _this.definitions[relationName];
                var toInject = attrs[def.localField];
                if (toInject) {
                  if (!relationDef) {
                    throw new _errors['default'].R(definition.name + ' relation is defined but the resource is not!');
                  }
                  if (_utils['default']._a(toInject)) {
                    (function() {
                      var items = [];
                      _utils['default'].forEach(toInject, function(toInjectItem) {
                        if (toInjectItem !== _this.store[relationName].index[toInjectItem[relationDef.idAttribute]]) {
                          try {
                            var injectedItem = relationDef.inject(toInjectItem, options.orig());
                            if (def.foreignKey) {
                              _utils['default'].set(injectedItem, def.foreignKey, attrs[definition.idAttribute]);
                            }
                            items.push(injectedItem);
                          } catch (err) {
                            options.errorFn(err, 'Failed to inject ' + def.type + ' relation: "' + relationName + '"!');
                          }
                        }
                      });
                    })();
                  } else {
                    if (toInject !== _this.store[relationName].index[toInject[relationDef.idAttribute]]) {
                      try {
                        var _injected = relationDef.inject(attrs[def.localField], options.orig());
                        if (def.foreignKey) {
                          _utils['default'].set(_injected, def.foreignKey, attrs[definition.idAttribute]);
                        }
                      } catch (err) {
                        options.errorFn(err, 'Failed to inject ' + def.type + ' relation: "' + relationName + '"!');
                      }
                    }
                  }
                }
              });
              var id = attrs[idA];
              var item = definition.get(id);
              var initialLastModified = item ? resource.modified[id] : 0;
              if (!item) {
                if (attrs instanceof definition[definition['class']]) {
                  item = attrs;
                } else {
                  item = new definition[definition['class']]();
                }
                _utils['default'].forEach(definition.relationList, function(def) {
                  delete attrs[def.localField];
                });
                _utils['default'].deepMixIn(item, attrs);
                resource.collection.push(item);
                resource.changeHistories[id] = [];
                if (definition.watchChanges) {
                  resource.observers[id] = new _this.observe.ObjectObserver(item);
                  resource.observers[id].open(_react, item);
                }
                resource.index[id] = item;
                _react.call(item, {}, {}, {}, null, true);
                resource.previousAttributes[id] = _utils['default'].copy(item, null, null, null, definition.relationFields);
              } else {
                if (options.onConflict === 'merge') {
                  _utils['default'].deepMixIn(item, attrs);
                } else if (options.onConflict === 'replace') {
                  _utils['default'].forOwn(item, function(v, k) {
                    if (k !== definition.idAttribute) {
                      if (!attrs.hasOwnProperty(k)) {
                        delete item[k];
                      }
                    }
                  });
                  _utils['default'].forOwn(attrs, function(v, k) {
                    if (k !== definition.idAttribute) {
                      item[k] = v;
                    }
                  });
                }
                if (definition.resetHistoryOnInject) {
                  resource.previousAttributes[id] = _utils['default'].copy(item, null, null, null, definition.relationFields);
                  if (resource.changeHistories[id].length) {
                    _utils['default'].forEach(resource.changeHistories[id], function(changeRecord) {
                      _utils['default'].remove(resource.changeHistory, changeRecord);
                    });
                    resource.changeHistories[id].splice(0, resource.changeHistories[id].length);
                  }
                }
                if (resource.observers[id] && typeof resource.observers[id] === 'function') {
                  resource.observers[id].deliver();
                }
              }
              resource.modified[id] = initialLastModified && resource.modified[id] === initialLastModified ? _utils['default'].updateTimestamp(resource.modified[id]) : resource.modified[id];
              resource.expiresHeap.remove(item);
              var timestamp = new Date().getTime();
              resource.expiresHeap.push({
                item: item,
                timestamp: timestamp,
                expires: definition.maxAge ? timestamp + definition.maxAge : Number.MAX_VALUE
              });
              injected = item;
            })();
          } catch (err) {
            options.errorFn(err, attrs);
          }
        }
      }
      return injected;
    }
    module.exports = function inject(resourceName, attrs, options) {
      var _this = this;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var injected = undefined;
      if (!definition) {
        throw new _errors['default'].NER(resourceName);
      } else if (!_utils['default']._o(attrs) && !_utils['default']._a(attrs)) {
        throw new _errors['default'].IA(resourceName + '.inject: "attrs" must be an object or an array!');
      }
      options = _utils['default']._(definition, options);
      options.logFn('inject', attrs, options);
      options.beforeInject(options, attrs);
      if (options.notify) {
        definition.emit('DS.beforeInject', definition, attrs);
      }
      injected = _inject.call(_this, definition, resource, attrs, options);
      definition.handleChange(injected);
      options.afterInject(options, injected);
      if (options.notify) {
        definition.emit('DS.afterInject', definition, injected);
      }
      return injected;
    };
  }, function(module, exports, __webpack_require__) {
    function toString(val) {
      return val == null ? '' : val.toString();
    }
    module.exports = toString;
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    var replaceAccents = __webpack_require__(44);
    var removeNonWord = __webpack_require__(45);
    var upperCase = __webpack_require__(20);
    var lowerCase = __webpack_require__(46);
    function camelCase(str) {
      str = toString(str);
      str = replaceAccents(str);
      str = removeNonWord(str).replace(/[\-_]/g, ' ').replace(/\s[a-z]/g, upperCase).replace(/\s+/g, '').replace(/^[A-Z]/g, lowerCase);
      return str;
    }
    module.exports = camelCase;
  }, function(module, exports, __webpack_require__) {
    module.exports = function create(resourceName, attrs, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var adapter = undefined;
      options = options || {};
      attrs = attrs || {};
      var rejectionError = undefined;
      if (!definition) {
        rejectionError = new _this.errors.NER(resourceName);
      } else if (!DSUtils._o(attrs)) {
        rejectionError = DSUtils._oErr('attrs');
      } else {
        options = DSUtils._(definition, options);
        if (options.upsert && DSUtils._sn(attrs[definition.idAttribute])) {
          return _this.update(resourceName, attrs[definition.idAttribute], attrs, options);
        }
        options.logFn('create', attrs, options);
      }
      return new DSUtils.Promise(function(resolve, reject) {
        if (rejectionError) {
          reject(rejectionError);
        } else {
          resolve(attrs);
        }
      }).then(function(attrs) {
        return options.beforeValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.validate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.afterValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.beforeCreate.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.beforeCreate', definition, attrs);
        }
        adapter = _this.getAdapterName(options);
        return _this.adapters[adapter].create(definition, DSUtils.omit(attrs, options.omit), options);
      }).then(function(attrs) {
        return options.afterCreate.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.afterCreate', definition, attrs);
        }
        if (options.cacheResponse) {
          var created = _this.inject(definition.name, attrs, options.orig());
          var id = created[definition.idAttribute];
          var resource = _this.store[resourceName];
          resource.completedQueries[id] = new Date().getTime();
          resource.saved[id] = DSUtils.updateTimestamp(resource.saved[id]);
          return created;
        } else {
          return _this.createInstance(resourceName, attrs, options);
        }
      }).then(function(item) {
        return DSUtils.respond(item, {adapter: adapter}, options);
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function destroy(resourceName, id, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var item = undefined;
      var adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        id = DSUtils.resolveId(definition, id);
        if (!definition) {
          reject(new _this.errors.NER(resourceName));
        } else if (!DSUtils._sn(id)) {
          reject(DSUtils._snErr('id'));
        } else {
          item = definition.get(id) || {id: id};
          options = DSUtils._(definition, options);
          options.logFn('destroy', id, options);
          resolve(item);
        }
      }).then(function(attrs) {
        return options.beforeDestroy.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.beforeDestroy', definition, attrs);
        }
        if (options.eagerEject) {
          definition.eject(id);
        }
        adapter = definition.getAdapter(options);
        return adapter.destroy(definition, id, options);
      }).then(function() {
        return options.afterDestroy.call(item, options, item);
      }).then(function(item) {
        if (options.notify) {
          definition.emit('DS.afterDestroy', definition, item);
        }
        definition.eject(id);
        return DSUtils.respond(id, {adapter: adapter}, options);
      })['catch'](function(err) {
        if (options && options.eagerEject && item) {
          definition.inject(item, {notify: false});
        }
        return DSUtils.Promise.reject(err);
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function destroyAll(resourceName, params, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var ejected = undefined,
          toEject = undefined,
          adapter = undefined;
      params = params || {};
      return new DSUtils.Promise(function(resolve, reject) {
        if (!definition) {
          reject(new _this.errors.NER(resourceName));
        } else if (!DSUtils._o(params)) {
          reject(DSUtils._oErr('attrs'));
        } else {
          options = DSUtils._(definition, options);
          options.logFn('destroyAll', params, options);
          resolve();
        }
      }).then(function() {
        toEject = definition.defaultFilter.call(_this, resourceName, params);
        return options.beforeDestroy(options, toEject);
      }).then(function() {
        if (options.notify) {
          definition.emit('DS.beforeDestroy', definition, toEject);
        }
        if (options.eagerEject) {
          ejected = definition.ejectAll(params);
        }
        adapter = definition.getAdapterName(options);
        return _this.adapters[adapter].destroyAll(definition, params, options);
      }).then(function() {
        return options.afterDestroy(options, toEject);
      }).then(function() {
        if (options.notify) {
          definition.emit('DS.afterDestroy', definition, toEject);
        }
        return ejected || definition.ejectAll(params);
      }).then(function(items) {
        return DSUtils.respond(items, {adapter: adapter}, options);
      })['catch'](function(err) {
        if (options && options.eagerEject && ejected) {
          definition.inject(ejected, {notify: false});
        }
        return DSUtils.Promise.reject(err);
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function find(resourceName, id, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        if (!definition) {
          reject(new _this.errors.NER(resourceName));
        } else if (!DSUtils._sn(id)) {
          reject(DSUtils._snErr('id'));
        } else {
          options = DSUtils._(definition, options);
          options.logFn('find', id, options);
          if (options.params) {
            options.params = DSUtils.copy(options.params);
          }
          if (options.bypassCache || !options.cacheResponse) {
            delete resource.completedQueries[id];
          }
          if ((!options.findStrictCache || id in resource.completedQueries) && definition.get(id) && !options.bypassCache) {
            resolve(definition.get(id));
          } else {
            delete resource.completedQueries[id];
            resolve();
          }
        }
      }).then(function(item) {
        if (!item) {
          if (!(id in resource.pendingQueries)) {
            var promise = undefined;
            var strategy = options.findStrategy || options.strategy;
            if (strategy === 'fallback') {
              (function() {
                var makeFallbackCall = function makeFallbackCall(index) {
                  adapter = definition.getAdapterName((options.findFallbackAdapters || options.fallbackAdapters)[index]);
                  return _this.adapters[adapter].find(definition, id, options)['catch'](function(err) {
                    index++;
                    if (index < options.fallbackAdapters.length) {
                      return makeFallbackCall(index);
                    } else {
                      return DSUtils.Promise.reject(err);
                    }
                  });
                };
                promise = makeFallbackCall(0);
              })();
            } else {
              adapter = definition.getAdapterName(options);
              promise = _this.adapters[adapter].find(definition, id, options);
            }
            resource.pendingQueries[id] = promise.then(function(data) {
              delete resource.pendingQueries[id];
              if (options.cacheResponse) {
                var injected = definition.inject(data, options.orig());
                resource.completedQueries[id] = new Date().getTime();
                resource.saved[id] = DSUtils.updateTimestamp(resource.saved[id]);
                return injected;
              } else {
                return definition.createInstance(data, options.orig());
              }
            });
          }
          return resource.pendingQueries[id];
        } else {
          return item;
        }
      }).then(function(item) {
        return DSUtils.respond(item, {adapter: adapter}, options);
      })['catch'](function(err) {
        if (resource) {
          delete resource.pendingQueries[id];
        }
        return DSUtils.Promise.reject(err);
      });
    };
  }, function(module, exports, __webpack_require__) {
    function processResults(data, resourceName, queryHash, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var idAttribute = _this.definitions[resourceName].idAttribute;
      var date = new Date().getTime();
      data = data || [];
      delete resource.pendingQueries[queryHash];
      resource.completedQueries[queryHash] = date;
      var injected = definition.inject(data, options.orig());
      if (DSUtils._a(injected)) {
        DSUtils.forEach(injected, function(item) {
          if (item) {
            var id = item[idAttribute];
            if (id) {
              resource.completedQueries[id] = date;
              resource.saved[id] = DSUtils.updateTimestamp(resource.saved[id]);
            }
          }
        });
      } else {
        options.errorFn('response is expected to be an array!');
        resource.completedQueries[injected[idAttribute]] = date;
      }
      return injected;
    }
    module.exports = function findAll(resourceName, params, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var queryHash = undefined,
          adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        params = params || {};
        if (!_this.definitions[resourceName]) {
          reject(new _this.errors.NER(resourceName));
        } else if (!DSUtils._o(params)) {
          reject(DSUtils._oErr('params'));
        } else {
          options = DSUtils._(definition, options);
          queryHash = DSUtils.toJson(params);
          options.logFn('findAll', params, options);
          if (options.params) {
            options.params = DSUtils.copy(options.params);
          }
          if (options.bypassCache || !options.cacheResponse) {
            delete resource.completedQueries[queryHash];
            delete resource.queryData[queryHash];
          }
          if (queryHash in resource.completedQueries) {
            if (options.useFilter) {
              if (options.localKeys) {
                resolve(definition.getAll(options.localKeys, options.orig()));
              } else {
                resolve(definition.filter(params, options.orig()));
              }
            } else {
              resolve(resource.queryData[queryHash]);
            }
          } else {
            resolve();
          }
        }
      }).then(function(items) {
        if (!(queryHash in resource.completedQueries)) {
          if (!(queryHash in resource.pendingQueries)) {
            var promise = undefined;
            var strategy = options.findAllStrategy || options.strategy;
            if (strategy === 'fallback') {
              (function() {
                var makeFallbackCall = function makeFallbackCall(index) {
                  adapter = definition.getAdapterName((options.findAllFallbackAdapters || options.fallbackAdapters)[index]);
                  return _this.adapters[adapter].findAll(definition, params, options)['catch'](function(err) {
                    index++;
                    if (index < options.fallbackAdapters.length) {
                      return makeFallbackCall(index);
                    } else {
                      return DSUtils.Promise.reject(err);
                    }
                  });
                };
                promise = makeFallbackCall(0);
              })();
            } else {
              adapter = definition.getAdapterName(options);
              promise = _this.adapters[adapter].findAll(definition, params, options);
            }
            resource.pendingQueries[queryHash] = promise.then(function(data) {
              delete resource.pendingQueries[queryHash];
              if (options.cacheResponse) {
                resource.queryData[queryHash] = processResults.call(_this, data, resourceName, queryHash, options);
                resource.queryData[queryHash].$$injected = true;
                return resource.queryData[queryHash];
              } else {
                DSUtils.forEach(data, function(item, i) {
                  data[i] = definition.createInstance(item, options.orig());
                });
                return data;
              }
            });
          }
          return resource.pendingQueries[queryHash];
        } else {
          return items;
        }
      }).then(function(items) {
        return DSUtils.respond(items, {adapter: adapter}, options);
      })['catch'](function(err) {
        if (resource) {
          delete resource.pendingQueries[queryHash];
        }
        return DSUtils.Promise.reject(err);
      });
    };
  }, function(module, exports, __webpack_require__) {
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = function loadRelations(resourceName, instance, relations, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var DSErrors = _this.errors;
      var definition = _this.definitions[resourceName];
      return new DSUtils.Promise(function(resolve, reject) {
        if (DSUtils._sn(instance)) {
          instance = definition.get(instance);
        }
        if (DSUtils._s(relations)) {
          relations = [relations];
        }
        relations = relations || [];
        if (!definition) {
          reject(new DSErrors.NER(resourceName));
        } else if (!DSUtils._o(instance)) {
          reject(new DSErrors.IA('"instance(id)" must be a string, number or object!'));
        } else if (!DSUtils._a(relations)) {
          reject(new DSErrors.IA('"relations" must be a string or an array!'));
        } else {
          (function() {
            var _options = DSUtils._(definition, options);
            _options.logFn('loadRelations', instance, relations, _options);
            var tasks = [];
            DSUtils.forEach(definition.relationList, function(def) {
              var relationName = def.relation;
              var relationDef = definition.getResource(relationName);
              var __options = DSUtils._(relationDef, options);
              if (!relations.length || DSUtils.contains(relations, relationName) || DSUtils.contains(relations, def.localField)) {
                var task = undefined;
                var params = {};
                if (__options.allowSimpleWhere) {
                  params[def.foreignKey] = instance[definition.idAttribute];
                } else {
                  params.where = {};
                  params.where[def.foreignKey] = {'==': instance[definition.idAttribute]};
                }
                if (def.type === 'hasMany') {
                  var orig = __options.orig();
                  if (def.localKeys) {
                    delete params[def.foreignKey];
                    var keys = DSUtils.get(instance, def.localKeys) || [];
                    keys = DSUtils._a(keys) ? keys : DSUtils.keys(keys);
                    params.where = _defineProperty({}, relationDef.idAttribute, {'in': keys});
                    orig.localKeys = keys;
                  }
                  task = relationDef.findAll(params, orig);
                } else if (def.type === 'hasOne') {
                  if (def.localKey && DSUtils.get(instance, def.localKey)) {
                    task = relationDef.find(DSUtils.get(instance, def.localKey), __options.orig());
                  } else if (def.foreignKey) {
                    task = relationDef.findAll(params, __options.orig()).then(function(hasOnes) {
                      return hasOnes.length ? hasOnes[0] : null;
                    });
                  }
                } else if (DSUtils.get(instance, def.localKey)) {
                  task = relationDef.find(DSUtils.get(instance, def.localKey), __options.orig());
                }
                if (task) {
                  tasks.push(task);
                }
              }
            });
            resolve(tasks);
          })();
        }
      }).then(function(tasks) {
        return DSUtils.Promise.all(tasks);
      }).then(function() {
        return instance;
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function reap(resourceName, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      return new DSUtils.Promise(function(resolve, reject) {
        if (!definition) {
          reject(new _this.errors.NER(resourceName));
        } else {
          options = DSUtils._(definition, options);
          if (!options.hasOwnProperty('notify')) {
            options.notify = false;
          }
          options.logFn('reap', options);
          var items = [];
          var now = new Date().getTime();
          var expiredItem = undefined;
          while ((expiredItem = resource.expiresHeap.peek()) && expiredItem.expires < now) {
            items.push(expiredItem.item);
            delete expiredItem.item;
            resource.expiresHeap.pop();
          }
          resolve(items);
        }
      }).then(function(items) {
        if (items.length) {
          definition.beforeReap(options, items);
          if (options.notify) {
            definition.emit('DS.beforeReap', definition, items);
          }
        }
        if (options.reapAction === 'inject') {
          (function() {
            var timestamp = new Date().getTime();
            DSUtils.forEach(items, function(item) {
              resource.expiresHeap.push({
                item: item,
                timestamp: timestamp,
                expires: definition.maxAge ? timestamp + definition.maxAge : Number.MAX_VALUE
              });
            });
          })();
        } else if (options.reapAction === 'eject') {
          DSUtils.forEach(items, function(item) {
            definition.eject(item[definition.idAttribute]);
          });
        } else if (options.reapAction === 'refresh') {
          var _ret2 = (function() {
            var tasks = [];
            DSUtils.forEach(items, function(item) {
              tasks.push(definition.refresh(item[definition.idAttribute]));
            });
            return {v: DSUtils.Promise.all(tasks)};
          })();
          if (typeof _ret2 === 'object')
            return _ret2.v;
        }
        return items;
      }).then(function(items) {
        if (items.length) {
          definition.afterReap(options, items);
          if (options.notify) {
            definition.emit('DS.afterReap', definition, items);
          }
        }
        return items;
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function save(resourceName, id, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var DSErrors = _this.errors;
      var definition = _this.definitions[resourceName];
      var resource = _this.store[resourceName];
      var item = undefined,
          noChanges = undefined,
          adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        id = DSUtils.resolveId(definition, id);
        if (!definition) {
          reject(new DSErrors.NER(resourceName));
        } else if (!DSUtils._sn(id)) {
          reject(DSUtils._snErr('id'));
        } else if (!definition.get(id)) {
          reject(new DSErrors.R('id "' + id + '" not found in cache!'));
        } else {
          item = definition.get(id);
          options = DSUtils._(definition, options);
          options.logFn('save', id, options);
          resolve(item);
        }
      }).then(function(attrs) {
        return options.beforeValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.validate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.afterValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.beforeUpdate.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.beforeUpdate', definition, attrs);
        }
        if (options.changesOnly) {
          if (resource.observers[id] && typeof resource.observers[id] === 'function') {
            resource.observers[id].deliver();
          }
          var toKeep = [];
          var changes = definition.changes(id);
          for (var key in changes.added) {
            toKeep.push(key);
          }
          for (key in changes.changed) {
            toKeep.push(key);
          }
          changes = DSUtils.pick(attrs, toKeep);
          if (DSUtils.isEmpty(changes)) {
            options.logFn('save - no changes', id, options);
            noChanges = true;
            return attrs;
          } else {
            attrs = changes;
          }
        }
        adapter = definition.getAdapterName(options);
        return _this.adapters[adapter].update(definition, id, DSUtils.omit(attrs, options.omit), options);
      }).then(function(data) {
        return options.afterUpdate.call(data, options, data);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.afterUpdate', definition, attrs);
        }
        if (noChanges) {
          return attrs;
        } else if (options.cacheResponse) {
          var injected = definition.inject(attrs, options.orig());
          var _id = injected[definition.idAttribute];
          resource.saved[_id] = DSUtils.updateTimestamp(resource.saved[_id]);
          if (!definition.resetHistoryOnInject) {
            resource.previousAttributes[_id] = DSUtils.copy(injected, null, null, null, definition.relationFields);
          }
          return injected;
        } else {
          return definition.createInstance(attrs, options.orig());
        }
      }).then(function(item) {
        return DSUtils.respond(item, {adapter: adapter}, options);
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function update(resourceName, id, attrs, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var DSErrors = _this.errors;
      var definition = _this.definitions[resourceName];
      var adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        id = DSUtils.resolveId(definition, id);
        if (!definition) {
          reject(new DSErrors.NER(resourceName));
        } else if (!DSUtils._sn(id)) {
          reject(DSUtils._snErr('id'));
        } else {
          options = DSUtils._(definition, options);
          options.logFn('update', id, attrs, options);
          resolve(attrs);
        }
      }).then(function(attrs) {
        return options.beforeValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.validate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.afterValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.beforeUpdate.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.beforeUpdate', definition, attrs);
        }
        adapter = definition.getAdapterName(options);
        return _this.adapters[adapter].update(definition, id, DSUtils.omit(attrs, options.omit), options);
      }).then(function(data) {
        return options.afterUpdate.call(data, options, data);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.afterUpdate', definition, attrs);
        }
        if (options.cacheResponse) {
          var injected = definition.inject(attrs, options.orig());
          var resource = _this.store[resourceName];
          var _id = injected[definition.idAttribute];
          resource.saved[_id] = DSUtils.updateTimestamp(resource.saved[_id]);
          if (!definition.resetHistoryOnInject) {
            resource.previousAttributes[_id] = DSUtils.copy(injected, null, null, null, definition.relationFields);
          }
          return injected;
        } else {
          return definition.createInstance(attrs, options.orig());
        }
      }).then(function(item) {
        return DSUtils.respond(item, {adapter: adapter}, options);
      });
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = function updateAll(resourceName, attrs, params, options) {
      var _this = this;
      var DSUtils = _this.utils;
      var DSErrors = _this.errors;
      var definition = _this.definitions[resourceName];
      var adapter = undefined;
      return new DSUtils.Promise(function(resolve, reject) {
        if (!definition) {
          reject(new DSErrors.NER(resourceName));
        } else {
          options = DSUtils._(definition, options);
          options.logFn('updateAll', attrs, params, options);
          resolve(attrs);
        }
      }).then(function(attrs) {
        return options.beforeValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.validate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.afterValidate.call(attrs, options, attrs);
      }).then(function(attrs) {
        return options.beforeUpdate.call(attrs, options, attrs);
      }).then(function(attrs) {
        if (options.notify) {
          definition.emit('DS.beforeUpdate', definition, attrs);
        }
        adapter = definition.getAdapterName(options);
        return _this.adapters[adapter].updateAll(definition, DSUtils.omit(attrs, options.omit), params, options);
      }).then(function(data) {
        return options.afterUpdate.call(data, options, data);
      }).then(function(data) {
        if (options.notify) {
          definition.emit('DS.afterUpdate', definition, attrs);
        }
        var origOptions = options.orig();
        if (options.cacheResponse) {
          var _ret = (function() {
            var injected = definition.inject(data, origOptions);
            var resource = _this.store[resourceName];
            DSUtils.forEach(injected, function(i) {
              var id = i[definition.idAttribute];
              resource.saved[id] = DSUtils.updateTimestamp(resource.saved[id]);
              if (!definition.resetHistoryOnInject) {
                resource.previousAttributes[id] = DSUtils.copy(i, null, null, null, definition.relationFields);
              }
            });
            return {v: injected};
          })();
          if (typeof _ret === 'object')
            return _ret.v;
        } else {
          var _ret2 = (function() {
            var instances = [];
            DSUtils.forEach(data, function(item) {
              instances.push(definition.createInstance(item, origOptions));
            });
            return {v: instances};
          })();
          if (typeof _ret2 === 'object')
            return _ret2.v;
        }
      }).then(function(items) {
        return DSUtils.respond(items, {adapter: adapter}, options);
      });
    };
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    function replaceAccents(str) {
      str = toString(str);
      if (str.search(/[\xC0-\xFF]/g) > -1) {
        str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
      }
      return str;
    }
    module.exports = replaceAccents;
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    var PATTERN = /[^\x20\x2D0-9A-Z\x5Fa-z\xC0-\xD6\xD8-\xF6\xF8-\xFF]/g;
    function removeNonWord(str) {
      str = toString(str);
      return str.replace(PATTERN, '');
    }
    module.exports = removeNonWord;
  }, function(module, exports, __webpack_require__) {
    var toString = __webpack_require__(32);
    function lowerCase(str) {
      str = toString(str);
      return str.toLowerCase();
    }
    module.exports = lowerCase;
  }]);
});
})();
(function() {
function define(){};  define.amd = {};
System.register("github:js-data/js-data@2.3.0", ["github:js-data/js-data@2.3.0/dist/js-data-debug"], false, function(__require, __exports, __module) {
  return (function(main) {
    return main;
  }).call(this, __require('github:js-data/js-data@2.3.0/dist/js-data-debug'));
});
})();
(function() {
function define(){};  define.amd = {};
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require("js-data"));
  else if (typeof define === 'function' && define.amd)
    System.register("github:js-data/js-data-localstorage@2.1.1/dist/js-data-localstorage", ["github:js-data/js-data@2.3.0"], false, function(__require, __exports, __module) {
      return (factory).call(this, __require('github:js-data/js-data@2.3.0'));
    });
  else if (typeof exports === 'object')
    exports["DSLocalStorageAdapter"] = factory(require("js-data"));
  else
    root["DSLocalStorageAdapter"] = factory(root["JSData"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var JSData = __webpack_require__(1);
    var guid = __webpack_require__(2);
    var unique = __webpack_require__(3);
    var map = __webpack_require__(4);
    var emptyStore = new JSData.DS();
    var DSUtils = JSData.DSUtils;
    var filter = emptyStore.defaults.defaultFilter;
    var Defaults = function Defaults() {
      _classCallCheck(this, Defaults);
    };
    Defaults.prototype.basePath = '';
    var queue = [];
    var taskInProcess = false;
    function enqueue(task) {
      queue.push(task);
    }
    function dequeue() {
      if (queue.length && !taskInProcess) {
        taskInProcess = true;
        queue[0]();
      }
    }
    function queueTask(task) {
      if (!queue.length) {
        enqueue(task);
        dequeue();
      } else {
        enqueue(task);
      }
    }
    function createTask(fn) {
      return new DSUtils.Promise(fn).then(function(result) {
        taskInProcess = false;
        queue.shift();
        setTimeout(dequeue, 0);
        return result;
      }, function(err) {
        taskInProcess = false;
        queue.shift();
        setTimeout(dequeue, 0);
        return DSUtils.Promise.reject(err);
      });
    }
    var DSLocalStorageAdapter = (function() {
      function DSLocalStorageAdapter(options) {
        _classCallCheck(this, DSLocalStorageAdapter);
        options = options || {};
        this.defaults = new Defaults();
        DSUtils.deepMixIn(this.defaults, options);
      }
      _createClass(DSLocalStorageAdapter, [{
        key: 'getPath',
        value: function getPath(resourceConfig, options) {
          return DSUtils.makePath(options.basePath || this.defaults.basePath || resourceConfig.basePath, resourceConfig.name);
        }
      }, {
        key: 'getIdPath',
        value: function getIdPath(resourceConfig, options, id) {
          return DSUtils.makePath(options.basePath || this.defaults.basePath || resourceConfig.basePath, resourceConfig.endpoint, id);
        }
      }, {
        key: 'getIds',
        value: function getIds(resourceConfig, options) {
          var ids = undefined;
          var idsPath = this.getPath(resourceConfig, options);
          var idsJson = localStorage.getItem(idsPath);
          if (idsJson) {
            ids = DSUtils.fromJson(idsJson);
          } else {
            localStorage.setItem(idsPath, DSUtils.toJson({}));
            ids = {};
          }
          return ids;
        }
      }, {
        key: 'saveKeys',
        value: function saveKeys(ids, resourceConfig, options) {
          localStorage.setItem(this.getPath(resourceConfig, options), DSUtils.toJson(ids));
        }
      }, {
        key: 'ensureId',
        value: function ensureId(id, resourceConfig, options) {
          var ids = this.getIds(resourceConfig, options);
          ids[id] = 1;
          this.saveKeys(ids, resourceConfig, options);
        }
      }, {
        key: 'removeId',
        value: function removeId(id, resourceConfig, options) {
          var ids = this.getIds(resourceConfig, options);
          delete ids[id];
          this.saveKeys(ids, resourceConfig, options);
        }
      }, {
        key: 'GET',
        value: function GET(key) {
          return new DSUtils.Promise(function(resolve) {
            var item = localStorage.getItem(key);
            resolve(item ? DSUtils.fromJson(item) : undefined);
          });
        }
      }, {
        key: 'PUT',
        value: function PUT(key, value) {
          var DSLocalStorageAdapter = this;
          return DSLocalStorageAdapter.GET(key).then(function(item) {
            if (item) {
              DSUtils.deepMixIn(item, DSUtils.removeCircular(value));
            }
            localStorage.setItem(key, DSUtils.toJson(item || value));
            return DSLocalStorageAdapter.GET(key);
          });
        }
      }, {
        key: 'DEL',
        value: function DEL(key) {
          return new DSUtils.Promise(function(resolve) {
            localStorage.removeItem(key);
            resolve();
          });
        }
      }, {
        key: 'find',
        value: function find(resourceConfig, id, options) {
          var _this = this;
          var instance = undefined;
          options = options || {};
          options['with'] = options['with'] || [];
          return new DSUtils.Promise(function(resolve, reject) {
            _this.GET(_this.getIdPath(resourceConfig, options || {}, id)).then(function(item) {
              return !item ? reject(new Error('Not Found!')) : item;
            }).then(function(_instance) {
              instance = _instance;
              var tasks = [];
              DSUtils.forEach(resourceConfig.relationList, function(def) {
                var relationName = def.relation;
                var relationDef = resourceConfig.getResource(relationName);
                var containedName = null;
                if (DSUtils.contains(options['with'], relationName)) {
                  containedName = relationName;
                } else if (DSUtils.contains(options['with'], def.localField)) {
                  containedName = def.localField;
                }
                if (containedName) {
                  (function() {
                    var __options = DSUtils.deepMixIn({}, options.orig ? options.orig() : options);
                    __options['with'] = options['with'].slice();
                    __options = DSUtils._(relationDef, __options);
                    DSUtils.remove(__options['with'], containedName);
                    DSUtils.forEach(__options['with'], function(relation, i) {
                      if (relation && relation.indexOf(containedName) === 0 && relation.length >= containedName.length && relation[containedName.length] === '.') {
                        __options['with'][i] = relation.substr(containedName.length + 1);
                      } else {
                        __options['with'][i] = '';
                      }
                    });
                    var task = undefined;
                    if ((def.type === 'hasOne' || def.type === 'hasMany') && def.foreignKey) {
                      task = _this.findAll(resourceConfig.getResource(relationName), {where: _defineProperty({}, def.foreignKey, {'==': instance[resourceConfig.idAttribute]})}, __options).then(function(relatedItems) {
                        if (def.type === 'hasOne' && relatedItems.length) {
                          DSUtils.set(instance, def.localField, relatedItems[0]);
                        } else {
                          DSUtils.set(instance, def.localField, relatedItems);
                        }
                        return relatedItems;
                      });
                    } else if (def.type === 'hasMany' && def.localKeys) {
                      var localKeys = [];
                      var itemKeys = instance[def.localKeys] || [];
                      itemKeys = Array.isArray(itemKeys) ? itemKeys : DSUtils.keys(itemKeys);
                      localKeys = localKeys.concat(itemKeys || []);
                      task = _this.findAll(resourceConfig.getResource(relationName), {where: _defineProperty({}, relationDef.idAttribute, {'in': DSUtils.filter(unique(localKeys), function(x) {
                            return x;
                          })})}, __options).then(function(relatedItems) {
                        DSUtils.set(instance, def.localField, relatedItems);
                        return relatedItems;
                      });
                    } else if (def.type === 'belongsTo' || def.type === 'hasOne' && def.localKey) {
                      task = _this.find(resourceConfig.getResource(relationName), DSUtils.get(instance, def.localKey), __options).then(function(relatedItem) {
                        DSUtils.set(instance, def.localField, relatedItem);
                        return relatedItem;
                      });
                    }
                    if (task) {
                      tasks.push(task);
                    }
                  })();
                }
              });
              return DSUtils.Promise.all(tasks);
            }).then(function() {
              return resolve(instance);
            })['catch'](reject);
          });
        }
      }, {
        key: 'findAll',
        value: function findAll(resourceConfig, params, options) {
          var _this2 = this;
          var items = null;
          options = options || {};
          options['with'] = options['with'] || [];
          return new DSUtils.Promise(function(resolve, reject) {
            try {
              (function() {
                options = options || {};
                if (!('allowSimpleWhere' in options)) {
                  options.allowSimpleWhere = true;
                }
                var items = [];
                var ids = DSUtils.keys(_this2.getIds(resourceConfig, options));
                DSUtils.forEach(ids, function(id) {
                  var itemJson = localStorage.getItem(_this2.getIdPath(resourceConfig, options, id));
                  if (itemJson) {
                    items.push(DSUtils.fromJson(itemJson));
                  }
                });
                resolve(filter.call(emptyStore, items, resourceConfig.name, params, options));
              })();
            } catch (err) {
              reject(err);
            }
          }).then(function(_items) {
            items = _items;
            var tasks = [];
            DSUtils.forEach(resourceConfig.relationList, function(def) {
              var relationName = def.relation;
              var relationDef = resourceConfig.getResource(relationName);
              var containedName = null;
              if (DSUtils.contains(options['with'], relationName)) {
                containedName = relationName;
              } else if (DSUtils.contains(options['with'], def.localField)) {
                containedName = def.localField;
              }
              if (containedName) {
                (function() {
                  var __options = DSUtils.deepMixIn({}, options.orig ? options.orig() : options);
                  __options['with'] = options['with'].slice();
                  __options = DSUtils._(relationDef, __options);
                  DSUtils.remove(__options['with'], containedName);
                  DSUtils.forEach(__options['with'], function(relation, i) {
                    if (relation && relation.indexOf(containedName) === 0 && relation.length >= containedName.length && relation[containedName.length] === '.') {
                      __options['with'][i] = relation.substr(containedName.length + 1);
                    } else {
                      __options['with'][i] = '';
                    }
                  });
                  var task = undefined;
                  if ((def.type === 'hasOne' || def.type === 'hasMany') && def.foreignKey) {
                    task = _this2.findAll(resourceConfig.getResource(relationName), {where: _defineProperty({}, def.foreignKey, {'in': DSUtils.filter(map(items, function(item) {
                          return DSUtils.get(item, resourceConfig.idAttribute);
                        }), function(x) {
                          return x;
                        })})}, __options).then(function(relatedItems) {
                      DSUtils.forEach(items, function(item) {
                        var attached = [];
                        DSUtils.forEach(relatedItems, function(relatedItem) {
                          if (DSUtils.get(relatedItem, def.foreignKey) === item[resourceConfig.idAttribute]) {
                            attached.push(relatedItem);
                          }
                        });
                        if (def.type === 'hasOne' && attached.length) {
                          DSUtils.set(item, def.localField, attached[0]);
                        } else {
                          DSUtils.set(item, def.localField, attached);
                        }
                      });
                      return relatedItems;
                    });
                  } else if (def.type === 'hasMany' && def.localKeys) {
                    (function() {
                      var localKeys = [];
                      DSUtils.forEach(items, function(item) {
                        var itemKeys = item[def.localKeys] || [];
                        itemKeys = Array.isArray(itemKeys) ? itemKeys : DSUtils.keys(itemKeys);
                        localKeys = localKeys.concat(itemKeys || []);
                      });
                      task = _this2.findAll(resourceConfig.getResource(relationName), {where: _defineProperty({}, relationDef.idAttribute, {'in': DSUtils.filter(unique(localKeys), function(x) {
                            return x;
                          })})}, __options).then(function(relatedItems) {
                        DSUtils.forEach(items, function(item) {
                          var attached = [];
                          var itemKeys = item[def.localKeys] || [];
                          itemKeys = Array.isArray(itemKeys) ? itemKeys : DSUtils.keys(itemKeys);
                          DSUtils.forEach(relatedItems, function(relatedItem) {
                            if (itemKeys && DSUtils.contains(itemKeys, relatedItem[relationDef.idAttribute])) {
                              attached.push(relatedItem);
                            }
                          });
                          DSUtils.set(item, def.localField, attached);
                        });
                        return relatedItems;
                      });
                    })();
                  } else if (def.type === 'belongsTo' || def.type === 'hasOne' && def.localKey) {
                    task = _this2.findAll(resourceConfig.getResource(relationName), {where: _defineProperty({}, relationDef.idAttribute, {'in': DSUtils.filter(map(items, function(item) {
                          return DSUtils.get(item, def.localKey);
                        }), function(x) {
                          return x;
                        })})}, __options).then(function(relatedItems) {
                      DSUtils.forEach(items, function(item) {
                        DSUtils.forEach(relatedItems, function(relatedItem) {
                          if (relatedItem[relationDef.idAttribute] === item[def.localKey]) {
                            DSUtils.set(item, def.localField, relatedItem);
                          }
                        });
                      });
                      return relatedItems;
                    });
                  }
                  if (task) {
                    tasks.push(task);
                  }
                })();
              }
            });
            return DSUtils.Promise.all(tasks);
          }).then(function() {
            return items;
          });
        }
      }, {
        key: 'create',
        value: function create(resourceConfig, attrs, options) {
          var _this3 = this;
          return createTask(function(resolve, reject) {
            queueTask(function() {
              attrs[resourceConfig.idAttribute] = attrs[resourceConfig.idAttribute] || guid();
              options = options || {};
              _this3.PUT(DSUtils.makePath(_this3.getIdPath(resourceConfig, options, attrs[resourceConfig.idAttribute])), DSUtils.omit(attrs, resourceConfig.relationFields || [])).then(function(item) {
                _this3.ensureId(item[resourceConfig.idAttribute], resourceConfig, options);
                resolve(item);
              })['catch'](reject);
            });
          });
        }
      }, {
        key: 'update',
        value: function update(resourceConfig, id, attrs, options) {
          var _this4 = this;
          return createTask(function(resolve, reject) {
            queueTask(function() {
              options = options || {};
              _this4.PUT(_this4.getIdPath(resourceConfig, options, id), DSUtils.omit(attrs, resourceConfig.relationFields || [])).then(function(item) {
                _this4.ensureId(item[resourceConfig.idAttribute], resourceConfig, options);
                resolve(item);
              })['catch'](reject);
            });
          });
        }
      }, {
        key: 'updateAll',
        value: function updateAll(resourceConfig, attrs, params, options) {
          var _this5 = this;
          return this.findAll(resourceConfig, params, options).then(function(items) {
            var tasks = [];
            DSUtils.forEach(items, function(item) {
              return tasks.push(_this5.update(resourceConfig, item[resourceConfig.idAttribute], DSUtils.omit(attrs, resourceConfig.relationFields || []), options));
            });
            return DSUtils.Promise.all(tasks);
          });
        }
      }, {
        key: 'destroy',
        value: function destroy(resourceConfig, id, options) {
          var _this6 = this;
          return createTask(function(resolve, reject) {
            queueTask(function() {
              options = options || {};
              _this6.DEL(_this6.getIdPath(resourceConfig, options, id)).then(function() {
                return _this6.removeId(id, resourceConfig.name, options);
              }).then(function() {
                return resolve(null);
              }, reject);
            });
          });
        }
      }, {
        key: 'destroyAll',
        value: function destroyAll(resourceConfig, params, options) {
          var _this7 = this;
          return this.findAll(resourceConfig, params, options).then(function(items) {
            var tasks = [];
            DSUtils.forEach(items, function(item) {
              return tasks.push(_this7.destroy(resourceConfig, item[resourceConfig.idAttribute], options));
            });
            return DSUtils.Promise.all(tasks);
          });
        }
      }]);
      return DSLocalStorageAdapter;
    })();
    module.exports = DSLocalStorageAdapter;
  }, function(module, exports, __webpack_require__) {
    module.exports = __WEBPACK_EXTERNAL_MODULE_1__;
  }, function(module, exports, __webpack_require__) {
    var randHex = __webpack_require__(5);
    var choice = __webpack_require__(6);
    function guid() {
      return (randHex(8) + '-' + randHex(4) + '-' + '4' + randHex(3) + '-' + choice(8, 9, 'a', 'b') + randHex(3) + '-' + randHex(12));
    }
    module.exports = guid;
  }, function(module, exports, __webpack_require__) {
    var filter = __webpack_require__(7);
    function unique(arr, compare) {
      compare = compare || isEqual;
      return filter(arr, function(item, i, arr) {
        var n = arr.length;
        while (++i < n) {
          if (compare(item, arr[i])) {
            return false;
          }
        }
        return true;
      });
    }
    function isEqual(a, b) {
      return a === b;
    }
    module.exports = unique;
  }, function(module, exports, __webpack_require__) {
    var makeIterator = __webpack_require__(8);
    function map(arr, callback, thisObj) {
      callback = makeIterator(callback, thisObj);
      var results = [];
      if (arr == null) {
        return results;
      }
      var i = -1,
          len = arr.length;
      while (++i < len) {
        results[i] = callback(arr[i], i, arr);
      }
      return results;
    }
    module.exports = map;
  }, function(module, exports, __webpack_require__) {
    var choice = __webpack_require__(6);
    var _chars = '0123456789abcdef'.split('');
    function randHex(size) {
      size = size && size > 0 ? size : 6;
      var str = '';
      while (size--) {
        str += choice(_chars);
      }
      return str;
    }
    module.exports = randHex;
  }, function(module, exports, __webpack_require__) {
    var randInt = __webpack_require__(9);
    var isArray = __webpack_require__(10);
    function choice(items) {
      var target = (arguments.length === 1 && isArray(items)) ? items : arguments;
      return target[randInt(0, target.length - 1)];
    }
    module.exports = choice;
  }, function(module, exports, __webpack_require__) {
    var makeIterator = __webpack_require__(8);
    function filter(arr, callback, thisObj) {
      callback = makeIterator(callback, thisObj);
      var results = [];
      if (arr == null) {
        return results;
      }
      var i = -1,
          len = arr.length,
          value;
      while (++i < len) {
        value = arr[i];
        if (callback(value, i, arr)) {
          results.push(value);
        }
      }
      return results;
    }
    module.exports = filter;
  }, function(module, exports, __webpack_require__) {
    var identity = __webpack_require__(11);
    var prop = __webpack_require__(12);
    var deepMatches = __webpack_require__(13);
    function makeIterator(src, thisObj) {
      if (src == null) {
        return identity;
      }
      switch (typeof src) {
        case 'function':
          return (typeof thisObj !== 'undefined') ? function(val, i, arr) {
            return src.call(thisObj, val, i, arr);
          } : src;
        case 'object':
          return function(val) {
            return deepMatches(val, src);
          };
        case 'string':
        case 'number':
          return prop(src);
      }
    }
    module.exports = makeIterator;
  }, function(module, exports, __webpack_require__) {
    var MIN_INT = __webpack_require__(14);
    var MAX_INT = __webpack_require__(15);
    var rand = __webpack_require__(16);
    function randInt(min, max) {
      min = min == null ? MIN_INT : ~~min;
      max = max == null ? MAX_INT : ~~max;
      return Math.round(rand(min - 0.5, max + 0.499999999999));
    }
    module.exports = randInt;
  }, function(module, exports, __webpack_require__) {
    var isKind = __webpack_require__(17);
    var isArray = Array.isArray || function(val) {
      return isKind(val, 'Array');
    };
    module.exports = isArray;
  }, function(module, exports, __webpack_require__) {
    function identity(val) {
      return val;
    }
    module.exports = identity;
  }, function(module, exports, __webpack_require__) {
    function prop(name) {
      return function(obj) {
        return obj[name];
      };
    }
    module.exports = prop;
  }, function(module, exports, __webpack_require__) {
    var forOwn = __webpack_require__(18);
    var isArray = __webpack_require__(10);
    function containsMatch(array, pattern) {
      var i = -1,
          length = array.length;
      while (++i < length) {
        if (deepMatches(array[i], pattern)) {
          return true;
        }
      }
      return false;
    }
    function matchArray(target, pattern) {
      var i = -1,
          patternLength = pattern.length;
      while (++i < patternLength) {
        if (!containsMatch(target, pattern[i])) {
          return false;
        }
      }
      return true;
    }
    function matchObject(target, pattern) {
      var result = true;
      forOwn(pattern, function(val, key) {
        if (!deepMatches(target[key], val)) {
          return (result = false);
        }
      });
      return result;
    }
    function deepMatches(target, pattern) {
      if (target && typeof target === 'object') {
        if (isArray(target) && isArray(pattern)) {
          return matchArray(target, pattern);
        } else {
          return matchObject(target, pattern);
        }
      } else {
        return target === pattern;
      }
    }
    module.exports = deepMatches;
  }, function(module, exports, __webpack_require__) {
    module.exports = -2147483648;
  }, function(module, exports, __webpack_require__) {
    module.exports = 2147483647;
  }, function(module, exports, __webpack_require__) {
    var random = __webpack_require__(19);
    var MIN_INT = __webpack_require__(14);
    var MAX_INT = __webpack_require__(15);
    function rand(min, max) {
      min = min == null ? MIN_INT : min;
      max = max == null ? MAX_INT : max;
      return min + (max - min) * random();
    }
    module.exports = rand;
  }, function(module, exports, __webpack_require__) {
    var kindOf = __webpack_require__(20);
    function isKind(val, kind) {
      return kindOf(val) === kind;
    }
    module.exports = isKind;
  }, function(module, exports, __webpack_require__) {
    var hasOwn = __webpack_require__(21);
    var forIn = __webpack_require__(22);
    function forOwn(obj, fn, thisObj) {
      forIn(obj, function(val, key) {
        if (hasOwn(obj, key)) {
          return fn.call(thisObj, obj[key], key, obj);
        }
      });
    }
    module.exports = forOwn;
  }, function(module, exports, __webpack_require__) {
    function random() {
      return random.get();
    }
    random.get = Math.random;
    module.exports = random;
  }, function(module, exports, __webpack_require__) {
    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;
    function kindOf(val) {
      if (val === null) {
        return 'Null';
      } else if (val === UNDEF) {
        return 'Undefined';
      } else {
        return _rKind.exec(_toString.call(val))[1];
      }
    }
    module.exports = kindOf;
  }, function(module, exports, __webpack_require__) {
    function hasOwn(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = hasOwn;
  }, function(module, exports, __webpack_require__) {
    var hasOwn = __webpack_require__(21);
    var _hasDontEnumBug,
        _dontEnums;
    function checkDontEnum() {
      _dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
      _hasDontEnumBug = true;
      for (var key in {'toString': null}) {
        _hasDontEnumBug = false;
      }
    }
    function forIn(obj, fn, thisObj) {
      var key,
          i = 0;
      if (_hasDontEnumBug == null)
        checkDontEnum();
      for (key in obj) {
        if (exec(fn, obj, key, thisObj) === false) {
          break;
        }
      }
      if (_hasDontEnumBug) {
        var ctor = obj.constructor,
            isProto = !!ctor && obj === ctor.prototype;
        while (key = _dontEnums[i++]) {
          if ((key !== 'constructor' || (!isProto && hasOwn(obj, key))) && obj[key] !== Object.prototype[key]) {
            if (exec(fn, obj, key, thisObj) === false) {
              break;
            }
          }
        }
      }
    }
    function exec(fn, obj, key, thisObj) {
      return fn.call(thisObj, obj[key], key, obj);
    }
    module.exports = forIn;
  }]);
});
;
})();
(function() {
function define(){};  define.amd = {};
System.register("github:js-data/js-data-localstorage@2.1.1", ["github:js-data/js-data-localstorage@2.1.1/dist/js-data-localstorage"], false, function(__require, __exports, __module) {
  return (function(main) {
    return main;
  }).call(this, __require('github:js-data/js-data-localstorage@2.1.1/dist/js-data-localstorage'));
});
})();
System.register("github:angular/bower-angular@1.4.4/angular", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.4/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
          return false;
        }
        var length = "length" in Object(obj) && obj.length;
        if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
          return true;
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
      function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
          throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
        }
        if (isTypedArray(destination)) {
          throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
        }
        if (!destination) {
          destination = source;
          if (isObject(source)) {
            var index;
            if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
              return stackDest[index];
            }
            if (isArray(source)) {
              return copy(source, [], stackSource, stackDest);
            } else if (isTypedArray(source)) {
              destination = new source.constructor(source);
            } else if (isDate(source)) {
              destination = new Date(source.getTime());
            } else if (isRegExp(source)) {
              destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              destination.lastIndex = source.lastIndex;
            } else {
              var emptyObject = Object.create(getPrototypeOf(source));
              return copy(source, emptyObject, stackSource, stackDest);
            }
            if (stackDest) {
              stackSource.push(source);
              stackDest.push(destination);
            }
          }
        } else {
          if (source === destination)
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          stackSource = stackSource || [];
          stackDest = stackDest || [];
          if (isObject(source)) {
            stackSource.push(source);
            stackDest.push(destination);
          }
          var result,
              key;
          if (isArray(source)) {
            destination.length = 0;
            for (var i = 0; i < source.length; i++) {
              destination.push(copy(source[i], null, stackSource, stackDest));
            }
          } else {
            var h = destination.$$hashKey;
            if (isArray(destination)) {
              destination.length = 0;
            } else {
              forEach(destination, function(value, key) {
                delete destination[key];
              });
            }
            if (isBlankObject(source)) {
              for (key in source) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            } else if (source && typeof source.hasOwnProperty === 'function') {
              for (key in source) {
                if (source.hasOwnProperty(key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            } else {
              for (key in source) {
                if (hasOwnProperty.call(source, key)) {
                  destination[key] = copy(source[key], null, stackSource, stackDest);
                }
              }
            }
            setHashKey(destination, h);
          }
        }
        return destination;
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return ;
        }
        var jqName = jq();
        jQuery = window.jQuery;
        if (isDefined(jqName)) {
          jQuery = jqName === null ? undefined : window[jqName];
        }
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes = [node];
        do {
          node = node.nextSibling;
          if (!node)
            break;
          blockNodes.push(node);
        } while (node !== endNode);
        return jqLite(blockNodes);
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '<<already seen>>';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (typeof obj === 'undefined') {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.4',
        major: 1,
        minor: 4,
        dot: 4,
        codeName: 'pylon-requirement'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return ;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          forEach(type.split(' '), function(type) {
            if (isDefined(fn)) {
              var listenerFns = events[type];
              arrayRemove(listenerFns || [], fn);
              if (listenerFns && listenerFns.length > 0) {
                return ;
              }
            }
            removeEventListenerFn(element, type, handle);
            delete events[type];
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return ;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if ((value = jqLite.data(element, names[i])) !== undefined)
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return ;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return ;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return ;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              eventFns[i].call(element, event);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return ;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          while (i--) {
            type = types[i];
            var eventFns = events[type];
            if (!eventFns) {
              events[type] = [];
              if (type === 'mouseenter' || type === 'mouseleave') {
                jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                  var target = this,
                      related = event.relatedTarget;
                  if (!related || (related !== target && !target.contains(related))) {
                    handle(event, type);
                  }
                });
              } else {
                if (type !== '$destroy') {
                  addEventListenerFn(element, type, handle);
                }
              }
              eventFns = events[type];
            }
            eventFns.push(fn);
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return ;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return ;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return ;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function addRemoveClassesPostDigest(element, add, remove) {
            var classVal,
                data = postDigestQueue.get(element);
            if (!data) {
              postDigestQueue.put(element, data = {});
              postDigestElements.push(element);
            }
            var updateData = function(classes, value) {
              var changed = false;
              if (classes) {
                classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                forEach(classes, function(className) {
                  if (className) {
                    changed = true;
                    data[className] = value;
                  }
                });
              }
              return changed;
            };
            var classesAdded = updateData(add, true);
            var classesRemoved = updateData(remove, false);
            if ((!classesAdded && !classesRemoved) || postDigestElements.length > 1)
              return ;
            $rootScope.$$postDigest(function() {
              forEach(postDigestElements, function(element) {
                var data = postDigestQueue.get(element);
                if (data) {
                  var existing = splitClasses(element.attr('class'));
                  var toAdd = '';
                  var toRemove = '';
                  forEach(data, function(status, className) {
                    var hasClass = !!existing[className];
                    if (status !== hasClass) {
                      if (status) {
                        toAdd += (toAdd.length ? ' ' : '') + className;
                      } else {
                        toRemove += (toRemove.length ? ' ' : '') + className;
                      }
                    }
                  });
                  forEach(element, function(elm) {
                    toAdd && jqLiteAddClass(elm, toAdd);
                    toRemove && jqLiteRemoveClass(elm, toRemove);
                  });
                  postDigestQueue.remove(element);
                }
              });
              postDigestElements.length = 0;
            });
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise().catch(f1);
            },
            'finally': function(f1) {
              return this.getPromise().finally(f1);
            }
          };
          return function(element, options) {
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            reloadLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || reloadLocation) {
                reloadLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
            }
            return self;
          } else {
            return reloadLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return ;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = {},
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = {},
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return ;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return ;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return ;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = {};
                size = 0;
                lruHash = {};
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(node, key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || value === undefined) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                    var destroyBindings = nodeLinkFn.$$destroyBindings;
                    if (destroyBindings) {
                      nodeLinkFn.$$destroyBindings = null;
                      childScope.$on('$destroyed', destroyBindings);
                    }
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                  if (directiveIsMultiElement(directiveNName)) {
                    if (ngAttrName === directiveNName + 'Start') {
                      attrStartName = name;
                      attrEndName = name.substr(0, name.length - 5) + 'end';
                      name = name.substr(0, name.length - 6);
                    }
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn);
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective) {
                    markDirectivesAsIsolate(templateDirectives);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
              var i,
                  ii,
                  linkFn,
                  controller,
                  isolateScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
              }
              if (elementControllers) {
                var scopeDirective = newIsolateScopeDirective || newScopeDirective;
                var bindings;
                var controllerForBindings;
                if (scopeDirective && elementControllers[scopeDirective.name]) {
                  bindings = scopeDirective.$$bindings.bindToController;
                  controller = elementControllers[scopeDirective.name];
                  if (controller && controller.identifier && bindings) {
                    controllerForBindings = controller;
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                  }
                }
                for (i in elementControllers) {
                  controller = elementControllers[i];
                  var controllerResult = controller();
                  if (controllerResult !== controller.instance) {
                    controller.instance = controllerResult;
                    $element.data('$' + i + 'Controller', controllerResult);
                    if (controller === controllerForBindings) {
                      thisLinkFn.$$destroyBindings();
                      thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                    }
                  }
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectivesAsIsolate(directives) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {$$isolateScope: true});
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return ;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return ;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = {}));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return ;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite(newNode).data(jqLite(firstElementToRemove).data());
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
            var onNewScopeDestroyed;
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var unwatch;
                  if (definition.collection) {
                    unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  onNewScopeDestroyed = (onNewScopeDestroyed || []);
                  onNewScopeDestroyed.push(unwatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
              for (var i = 0,
                  ii = onNewScopeDestroyed.length; i < ii; ++i) {
                onNewScopeDestroyed[i]();
              }
            } : noop;
            if (newScope && destroyBindings !== noop) {
              newScope.$on('$destroy', destroyBindings);
              return noop;
            }
            return destroyBindings;
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return ;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return ;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              if (!response.data) {
                resp.data = response.data;
              } else {
                resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              }
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = Math.max(status, 0);
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function createXhr() {
        return new window.XMLHttpRequest();
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
          return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr();
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (timeoutId !== undefined) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return ;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if ((appUrl = beginsWith(appBase, url)) !== undefined) {
            prevAppUrl = appUrl;
            if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return ;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return ;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return ;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return ;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return ;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return ;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return ;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return ;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return ;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return ;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return ;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return ;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return ;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return ;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return ;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return ;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var rafFn = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          queueFn.supported = rafSupported;
          var cancelLastRAF;
          var taskCount = 0;
          var taskQueue = [];
          return queueFn;
          function flush() {
            for (var i = 0; i < taskQueue.length; i++) {
              var task = taskQueue[i];
              if (task) {
                taskQueue[i] = null;
                task();
              }
            }
            taskCount = taskQueue.length = 0;
          }
          function queueFn(asyncFn) {
            var index = taskQueue.length;
            taskCount++;
            taskQueue.push(asyncFn);
            if (index === 0) {
              cancelLastRAF = rafFn(flush);
            }
            return function cancelQueueFn() {
              if (index >= 0) {
                taskQueue[index] = null;
                index = null;
                if (--taskCount === 0 && cancelLastRAF) {
                  cancelLastRAF();
                  cancelLastRAF = null;
                  taskQueue.length = 0;
                }
              }
            };
          }
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return ;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (newValue.hasOwnProperty(key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!newValue.hasOwnProperty(key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return ;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (lastCookies[name] === undefined) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return ;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return ;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return ;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return ;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        parentForm.$addControl(form);
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return ;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          parentForm: parentForm,
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, controller) {
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = controller.$$parentForm;
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return ;
                      setter(scope, undefined);
                      parentFormCtrl.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    parentFormCtrl.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return ;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return ;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = value === undefined ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return ;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return ;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return ;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
            currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          parentForm: parentForm,
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return ;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return ;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return ;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (parserValid === undefined) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return ;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || nullFormCtrl;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    formCtrl.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  formCtrl.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return ;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (this.$options.updateOn !== undefined) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            parentForm = context.parentForm,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (state === undefined) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: function(scope, selectElement, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return ;
            var selectCtrl = ctrls[0];
            var multiple = attr.multiple;
            var emptyOption;
            for (var i = 0,
                children = selectElement.children(),
                ii = children.length; i < ii; i++) {
              if (children[i].value === '') {
                emptyOption = children.eq(i);
                break;
              }
            }
            var providedEmptyOption = !!emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val('?');
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var renderEmptyOption = function() {
              if (!providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              selectElement.val('');
              emptyOption.prop('selected', true);
              emptyOption.attr('selected', true);
            };
            var removeEmptyOption = function() {
              if (!providedEmptyOption) {
                emptyOption.remove();
              }
            };
            var renderUnknownOption = function() {
              selectElement.prepend(unknownOption);
              selectElement.val('?');
              unknownOption.prop('selected', true);
              unknownOption.attr('selected', true);
            };
            var removeUnknownOption = function() {
              unknownOption.remove();
            };
            if (!multiple) {
              selectCtrl.writeValue = function writeNgOptionsValue(value) {
                var option = options.getOptionFromViewValue(value);
                if (option && !option.disabled) {
                  if (selectElement[0].value !== option.selectValue) {
                    removeUnknownOption();
                    removeEmptyOption();
                    selectElement[0].value = option.selectValue;
                    option.element.selected = true;
                    option.element.setAttribute('selected', 'selected');
                  }
                } else {
                  if (value === null || providedEmptyOption) {
                    removeUnknownOption();
                    renderEmptyOption();
                  } else {
                    removeEmptyOption();
                    renderUnknownOption();
                  }
                }
              };
              selectCtrl.readValue = function readNgOptionsValue() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                if (selectedOption && !selectedOption.disabled) {
                  removeEmptyOption();
                  removeUnknownOption();
                  return options.getViewValueFromOption(selectedOption);
                }
                return null;
              };
              if (ngOptions.trackBy) {
                scope.$watch(function() {
                  return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            } else {
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
              selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                options.items.forEach(function(option) {
                  option.element.selected = false;
                });
                if (value) {
                  value.forEach(function(item) {
                    var option = options.getOptionFromViewValue(item);
                    if (option && !option.disabled)
                      option.element.selected = true;
                  });
                }
              };
              selectCtrl.readValue = function readNgOptionsMultiple() {
                var selectedValues = selectElement.val() || [],
                    selections = [];
                forEach(selectedValues, function(value) {
                  var option = options.selectValueMap[value];
                  if (option && !option.disabled)
                    selections.push(options.getViewValueFromOption(option));
                });
                return selections;
              };
              if (ngOptions.trackBy) {
                scope.$watchCollection(function() {
                  if (isArray(ngModelCtrl.$viewValue)) {
                    return ngModelCtrl.$viewValue.map(function(value) {
                      return ngOptions.getTrackByValue(value);
                    });
                  }
                }, function() {
                  ngModelCtrl.$render();
                });
              }
            }
            if (providedEmptyOption) {
              emptyOption.remove();
              $compile(emptyOption)(scope);
              emptyOption.removeClass('ng-scope');
            } else {
              emptyOption = jqLite(optionTemplate.cloneNode(false));
            }
            updateOptions();
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function updateOptionElement(option, element) {
              option.element = element;
              element.disabled = option.disabled;
              if (option.value !== element.value)
                element.value = option.selectValue;
              if (option.label !== element.label) {
                element.label = option.label;
                element.textContent = option.label;
              }
            }
            function addOrReuseElement(parent, current, type, templateElement) {
              var element;
              if (current && lowercase(current.nodeName) === type) {
                element = current;
              } else {
                element = templateElement.cloneNode(false);
                if (!current) {
                  parent.appendChild(element);
                } else {
                  parent.insertBefore(element, current);
                }
              }
              return element;
            }
            function removeExcessElements(current) {
              var next;
              while (current) {
                next = current.nextSibling;
                jqLiteRemove(current);
                current = next;
              }
            }
            function skipEmptyAndUnknownOptions(current) {
              var emptyOption_ = emptyOption && emptyOption[0];
              var unknownOption_ = unknownOption && unknownOption[0];
              if (emptyOption_ || unknownOption_) {
                while (current && (current === emptyOption_ || current === unknownOption_)) {
                  current = current.nextSibling;
                }
              }
              return current;
            }
            function updateOptions() {
              var previousValue = options && selectCtrl.readValue();
              options = ngOptions.getOptions();
              var groupMap = {};
              var currentElement = selectElement[0].firstChild;
              if (providedEmptyOption) {
                selectElement.prepend(emptyOption);
              }
              currentElement = skipEmptyAndUnknownOptions(currentElement);
              options.items.forEach(function updateOption(option) {
                var group;
                var groupElement;
                var optionElement;
                if (option.group) {
                  group = groupMap[option.group];
                  if (!group) {
                    groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                    currentElement = groupElement.nextSibling;
                    groupElement.label = option.group;
                    group = groupMap[option.group] = {
                      groupElement: groupElement,
                      currentOptionElement: groupElement.firstChild
                    };
                  }
                  optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  group.currentOptionElement = optionElement.nextSibling;
                } else {
                  optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                  updateOptionElement(option, optionElement);
                  currentElement = optionElement.nextSibling;
                }
              });
              Object.keys(groupMap).forEach(function(key) {
                removeExcessElements(groupMap[key].currentOptionElement);
              });
              removeExcessElements(currentElement);
              ngModelCtrl.$render();
              if (!ngModelCtrl.$isEmpty(previousValue)) {
                var nextValue = selectCtrl.readValue();
                if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                  ngModelCtrl.$setViewValue(nextValue);
                  ngModelCtrl.$render();
                }
              }
            }
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          link: function(scope, element, attr, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl)
              return ;
            var selectCtrl = ctrls[0];
            selectCtrl.ngModelCtrl = ngModelCtrl;
            ngModelCtrl.$render = function() {
              selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
            element.on('change', function() {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(selectCtrl.readValue());
              });
            });
            if (attr.multiple) {
              selectCtrl.readValue = function readMultipleValue() {
                var array = [];
                forEach(element.find('option'), function(option) {
                  if (option.selected) {
                    array.push(option.value);
                  }
                });
                return array;
              };
              selectCtrl.writeValue = function writeMultipleValue(value) {
                var items = new HashMap(value);
                forEach(element.find('option'), function(option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              var lastView,
                  lastViewRef = NaN;
              scope.$watch(function selectMultipleWatch() {
                if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                  lastView = shallowCopy(ngModelCtrl.$viewValue);
                  ngModelCtrl.$render();
                }
                lastViewRef = ngModelCtrl.$viewValue;
              });
              ngModelCtrl.$isEmpty = function(value) {
                return !value || value.length === 0;
              };
            }
          }
        };
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        function chromeHack(optionElement) {
          if (optionElement[0].hasAttribute('selected')) {
            optionElement[0].selected = true;
          }
        }
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.ngModelCtrl) {
                if (interpolateFn) {
                  scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                    attr.$set('value', newVal);
                    if (oldVal !== newVal) {
                      selectCtrl.removeOption(oldVal);
                    }
                    selectCtrl.addOption(newVal, element);
                    selectCtrl.ngModelCtrl.$render();
                    chromeHack(element);
                  });
                } else {
                  selectCtrl.addOption(attr.value, element);
                  selectCtrl.ngModelCtrl.$render();
                  chromeHack(element);
                }
                element.on('$destroy', function() {
                  selectCtrl.removeOption(attr.value);
                  selectCtrl.ngModelCtrl.$render();
                });
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(value) {
              return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return ;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return ;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, "angular");
});

System.register("github:angular/bower-angular@1.4.4", ["github:angular/bower-angular@1.4.4/angular"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular@1.4.4/angular");
  global.define = __define;
  return module.exports;
});

(function() {
function define(){};  define.amd = {};
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require("js-data"), require("angular"), (function webpackLoadOptionalExternalModule() {
      try {
        return require("axios");
      } catch (e) {}
    }()));
  else if (typeof define === 'function' && define.amd)
    System.register("github:js-data/js-data-angular@3.0.0/dist/js-data-angular", ["github:js-data/js-data@2.3.0", "github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
      return (function webpackLoadOptionalExternalModuleAmd(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {
        return factory(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, root["axios"]);
      }).call(this, __require('github:js-data/js-data@2.3.0'), __require('github:angular/bower-angular@1.4.4'));
    });
  else if (typeof exports === 'object')
    exports["jsDataAngularModuleName"] = factory(require("js-data"), require("angular"), (function webpackLoadOptionalExternalModule() {
      try {
        return require("axios");
      } catch (e) {}
    }()));
  else
    root["jsDataAngularModuleName"] = factory(root["JSData"], root["angular"], root["axios"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_5__) {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var JSData = __webpack_require__(1);
    var DSHttpAdapter = __webpack_require__(4);
    var angular = __webpack_require__(2);
    var DSUtils = JSData.DSUtils;
    var DSErrors = JSData.DSErrors;
    var isString = DSUtils.isString;
    var isNumber = DSUtils.isNumber;
    var isObject = DSUtils.isObject;
    var set = DSUtils.set;
    var resolveId = DSUtils.resolveId;
    var adapters = [{
      project: 'js-data-localstorage',
      name: 'localstorage',
      'class': 'DSLocalStorageAdapter'
    }, {
      project: 'js-data-localforage',
      name: 'localforage',
      'class': 'DSLocalForageAdapter'
    }, {
      project: 'js-data-firebase',
      name: 'firebase',
      'class': 'DSFirebaseAdapter'
    }, {
      project: 'js-data-sql',
      name: 'sql',
      'class': 'DSSqlAdapter'
    }];
    var functionsToWrap = ['compute', 'digest', 'eject', 'inject'];
    function registerAdapter(adapter) {
      var Adapter = undefined;
      try {
        Adapter = __webpack_require__(3)(adapter.project);
      } catch (e) {}
      if (!Adapter) {
        Adapter = window[adapter['class']];
      }
      if (Adapter) {
        adapter.loaded = true;
        angular.module('js-data').provider(adapter['class'], function() {
          var _this = this;
          _this.defaults = {};
          _this.$get = [function() {
            return new Adapter(_this.defaults);
          }];
        });
      }
    }
    var DSHttpAdapterProvider = function DSHttpAdapterProvider() {
      _classCallCheck(this, DSHttpAdapterProvider);
      var defaults = {};
      this.defaults = defaults;
      this.$get = ['$http', 'DS', function($http, DS) {
        defaults.http = defaults.http || $http;
        var adapter = new DSHttpAdapter(defaults);
        DS.registerAdapter('http', adapter, {'default': true});
        return adapter;
      }];
    };
    var DSProvider = function DSProvider() {
      _classCallCheck(this, DSProvider);
      var _this = this;
      var deps = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].loaded) {
          deps.push(adapters[i]['class']);
        }
      }
      _this.defaults = {};
      JSData.DS.prototype.bindAll = function(resourceName, params, scope, expr, cb) {
        var _this = this;
        params = params || {};
        if (!_this.definitions[resourceName]) {
          throw new DSErrors.NER(resourceName);
        } else if (!isObject(params)) {
          throw new DSErrors.IA('"params" must be an object!');
        } else if (!isObject(scope)) {
          throw new DSErrors.IA('"scope" must be an object!');
        } else if (!isString(expr)) {
          throw new DSErrors.IA('"expr" must be a string!');
        }
        try {
          return scope.$watch(function() {
            return _this.lastModified(resourceName);
          }, function() {
            var items = _this.filter(resourceName, params);
            set(scope, expr, items);
            if (cb) {
              cb(null, items);
            }
          });
        } catch (err) {
          if (cb) {
            cb(err);
          } else {
            throw err;
          }
        }
      };
      JSData.DS.prototype.bindOne = function(resourceName, id, scope, expr, cb) {
        var _this = this;
        id = resolveId(_this.definitions[resourceName], id);
        if (!_this.definitions[resourceName]) {
          throw new DSErrors.NER(resourceName);
        } else if (!isString(id) && !isNumber(id)) {
          throw new DSErrors.IA('"id" must be a string or a number!');
        } else if (!isObject(scope)) {
          throw new DSErrors.IA('"scope" must be an object!');
        } else if (!isString(expr)) {
          throw new DSErrors.IA('"expr" must be a string!');
        }
        try {
          return scope.$watch(function() {
            return _this.lastModified(resourceName, id);
          }, function() {
            var item = _this.get(resourceName, id);
            if (item) {
              _this.compute(resourceName, id);
            }
            set(scope, expr, item);
            if (cb) {
              cb(null, item);
            }
          });
        } catch (err) {
          if (cb) {
            cb(err);
          } else {
            throw err;
          }
        }
      };
      function load() {
        for (var _len = arguments.length,
            args = Array(_len),
            _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var $rootScope = args[args.length - 2];
        var $q = args[args.length - 1];
        var store = new JSData.DS(_this.defaults);
        var originals = {};
        function QPromise(executor) {
          var deferred = $q.defer();
          try {
            executor.call(undefined, angular.bind(deferred, deferred.resolve), angular.bind(deferred, deferred.reject));
          } catch (err) {
            deferred.reject(err);
          }
          return deferred.promise;
        }
        QPromise.all = $q.all;
        QPromise.when = $q.when;
        QPromise.reject = $q.reject;
        DSUtils.Promise = QPromise;
        if (args.length) {
          for (var i = 0; i < args.length; i++) {
            for (var j = 0; j < adapters.length; j++) {
              if (adapters[j].loaded && !adapters[j].registered) {
                adapters[j].registered = true;
                store.registerAdapter(adapters[j].name, args[i]);
                break;
              }
            }
          }
        }
        var _loop = function() {
          var name = functionsToWrap[k];
          originals[name] = store[name];
          store[name] = function() {
            for (var _len2 = arguments.length,
                args = Array(_len2),
                _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            if (!$rootScope.$$phase) {
              return $rootScope.$apply(function() {
                return originals[name].apply(store, args);
              });
            }
            return originals[name].apply(store, args);
          };
        };
        for (var k = 0; k < functionsToWrap.length; k++) {
          _loop();
        }
        if (typeof Object.observe !== 'function' || typeof Array.observe !== 'function') {
          $rootScope.$watch(function() {
            return store.observe.Platform.performMicrotaskCheckpoint();
          });
        }
        return store;
      }
      deps.push('$rootScope');
      deps.push('$q');
      deps.push(load);
      _this.$get = deps;
    };
    angular.module('js-data', ['ng']).value('DSUtils', DSUtils).value('DSErrors', DSErrors).value('DSVersion', JSData.version).provider('DS', DSProvider).provider('DSHttpAdapter', DSHttpAdapterProvider).run(['DS', 'DSHttpAdapter', function(DS, DSHttpAdapter) {
      DS.registerAdapter('http', DSHttpAdapter, {'default': true});
    }]);
    for (var i = 0; i < adapters.length; i++) {
      registerAdapter(adapters[i]);
    }
    module.exports = 'js-data';
    module.exports.name = 'js-data';
  }, function(module, exports, __webpack_require__) {
    module.exports = __WEBPACK_EXTERNAL_MODULE_1__;
  }, function(module, exports, __webpack_require__) {
    module.exports = __WEBPACK_EXTERNAL_MODULE_2__;
  }, function(module, exports, __webpack_require__) {
    var map = {};
    function webpackContext(req) {
      return __webpack_require__(webpackContextResolve(req));
    }
    ;
    function webpackContextResolve(req) {
      return map[req] || (function() {
        throw new Error("Cannot find module '" + req + "'.");
      }());
    }
    ;
    webpackContext.keys = function webpackContextKeys() {
      return Object.keys(map);
    };
    webpackContext.resolve = webpackContextResolve;
    module.exports = webpackContext;
    webpackContext.id = 3;
  }, function(module, exports, __webpack_require__) {
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    var JSData = __webpack_require__(1);
    var axios = null;
    try {
      axios = __webpack_require__(5);
    } catch (e) {}
    var DSUtils = JSData.DSUtils;
    var deepMixIn = DSUtils.deepMixIn;
    var removeCircular = DSUtils.removeCircular;
    var copy = DSUtils.copy;
    var makePath = DSUtils.makePath;
    var isString = DSUtils.isString;
    var isNumber = DSUtils.isNumber;
    var Defaults = (function() {
      function Defaults() {
        _classCallCheck(this, Defaults);
      }
      _createClass(Defaults, [{
        key: 'queryTransform',
        value: function queryTransform(resourceConfig, params) {
          return params;
        }
      }, {
        key: 'deserialize',
        value: function deserialize(resourceConfig, data) {
          return data ? 'data' in data ? data.data : data : data;
        }
      }, {
        key: 'serialize',
        value: function serialize(resourceConfig, data) {
          return data;
        }
      }, {
        key: 'log',
        value: function log() {}
      }, {
        key: 'error',
        value: function error() {}
      }]);
      return Defaults;
    })();
    var defaultsPrototype = Defaults.prototype;
    defaultsPrototype.basePath = '';
    defaultsPrototype.forceTrailingSlash = '';
    defaultsPrototype.httpConfig = {};
    var DSHttpAdapter = (function() {
      function DSHttpAdapter(options) {
        _classCallCheck(this, DSHttpAdapter);
        this.defaults = new Defaults();
        if (console) {
          this.defaults.log = function(a, b) {
            return console[typeof console.info === 'function' ? 'info' : 'log'](a, b);
          };
        }
        if (console) {
          this.defaults.error = function(a, b) {
            return console[typeof console.error === 'function' ? 'error' : 'log'](a, b);
          };
        }
        deepMixIn(this.defaults, options);
        this.http = options.http || axios;
      }
      _createClass(DSHttpAdapter, [{
        key: 'getEndpoint',
        value: function getEndpoint(resourceConfig, id, options) {
          var _this2 = this;
          options = options || {};
          options.params = options.params || {};
          var item = undefined;
          var parentKey = resourceConfig.parentKey;
          var endpoint = options.hasOwnProperty('endpoint') ? options.endpoint : resourceConfig.endpoint;
          var parentField = resourceConfig.parentField;
          var parentDef = resourceConfig.getResource(resourceConfig.parent);
          var parentId = options.params[parentKey];
          if (parentId === false || !parentKey || !parentDef) {
            if (parentId === false) {
              delete options.params[parentKey];
            }
            return endpoint;
          } else {
            delete options.params[parentKey];
            if (DSUtils._sn(id)) {
              item = resourceConfig.get(id);
            } else if (DSUtils._o(id)) {
              item = id;
            }
            if (item) {
              parentId = parentId || item[parentKey] || (item[parentField] ? item[parentField][parentDef.idAttribute] : null);
            }
            if (parentId) {
              var _ret = (function() {
                delete options.endpoint;
                var _options = {};
                DSUtils.forOwn(options, function(value, key) {
                  _options[key] = value;
                });
                return {v: DSUtils.makePath(_this2.getEndpoint(parentDef, parentId, DSUtils._(parentDef, _options)), parentId, endpoint)};
              })();
              if (typeof _ret === 'object')
                return _ret.v;
            } else {
              return endpoint;
            }
          }
        }
      }, {
        key: 'getPath',
        value: function getPath(method, resourceConfig, id, options) {
          var _this = this;
          options = options || {};
          var args = [options.basePath || _this.defaults.basePath || resourceConfig.basePath, this.getEndpoint(resourceConfig, isString(id) || isNumber(id) || method === 'create' ? id : null, options)];
          if (method === 'find' || method === 'update' || method === 'destroy') {
            args.push(id);
          }
          return makePath.apply(DSUtils, args);
        }
      }, {
        key: 'HTTP',
        value: function HTTP(config) {
          var _this = this;
          var start = new Date();
          config = copy(config);
          config = deepMixIn(config, _this.defaults.httpConfig);
          if (_this.defaults.forceTrailingSlash && config.url[config.url.length - 1] !== '/') {
            config.url += '/';
          }
          if (typeof config.data === 'object') {
            config.data = removeCircular(config.data);
          }
          config.method = config.method.toUpperCase();
          var suffix = config.suffix || _this.defaults.suffix;
          if (suffix && config.url.substr(config.url.length - suffix.length) !== suffix) {
            config.url += suffix;
          }
          function logResponse(data) {
            var str = start.toUTCString() + ' - ' + data.config.method.toUpperCase() + ' ' + data.config.url + ' - ' + data.status + ' ' + (new Date().getTime() - start.getTime()) + 'ms';
            if (data.status >= 200 && data.status < 300) {
              if (_this.defaults.log) {
                _this.defaults.log(str, data);
              }
              return data;
            } else {
              if (_this.defaults.error) {
                _this.defaults.error('\'FAILED: ' + str, data);
              }
              return DSUtils.Promise.reject(data);
            }
          }
          if (!this.http) {
            throw new Error('You have not configured this adapter with an http library!');
          }
          return this.http(config).then(logResponse, logResponse);
        }
      }, {
        key: 'GET',
        value: function GET(url, config) {
          config = config || {};
          if (!('method' in config)) {
            config.method = 'get';
          }
          return this.HTTP(deepMixIn(config, {url: url}));
        }
      }, {
        key: 'POST',
        value: function POST(url, attrs, config) {
          config = config || {};
          if (!('method' in config)) {
            config.method = 'post';
          }
          return this.HTTP(deepMixIn(config, {
            url: url,
            data: attrs
          }));
        }
      }, {
        key: 'PUT',
        value: function PUT(url, attrs, config) {
          config = config || {};
          if (!('method' in config)) {
            config.method = 'put';
          }
          return this.HTTP(deepMixIn(config, {
            url: url,
            data: attrs || {}
          }));
        }
      }, {
        key: 'DEL',
        value: function DEL(url, config) {
          config = config || {};
          if (!('method' in config)) {
            config.method = 'delete';
          }
          return this.HTTP(deepMixIn(config, {url: url}));
        }
      }, {
        key: 'find',
        value: function find(resourceConfig, id, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          options.params = _this.defaults.queryTransform(resourceConfig, options.params);
          return _this.GET(_this.getPath('find', resourceConfig, id, options), options).then(function(data) {
            var item = (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
            return !item ? DSUtils.Promise.reject(new Error('Not Found!')) : item;
          });
        }
      }, {
        key: 'findAll',
        value: function findAll(resourceConfig, params, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          if (params) {
            params = _this.defaults.queryTransform(resourceConfig, params);
            deepMixIn(options.params, params);
          }
          return _this.GET(_this.getPath('findAll', resourceConfig, params, options), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }, {
        key: 'create',
        value: function create(resourceConfig, attrs, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          options.params = _this.defaults.queryTransform(resourceConfig, options.params);
          return _this.POST(_this.getPath('create', resourceConfig, attrs, options), options.serialize ? options.serialize(resourceConfig, attrs) : _this.defaults.serialize(resourceConfig, attrs), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }, {
        key: 'update',
        value: function update(resourceConfig, id, attrs, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          options.params = _this.defaults.queryTransform(resourceConfig, options.params);
          return _this.PUT(_this.getPath('update', resourceConfig, id, options), options.serialize ? options.serialize(resourceConfig, attrs) : _this.defaults.serialize(resourceConfig, attrs), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }, {
        key: 'updateAll',
        value: function updateAll(resourceConfig, attrs, params, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          if (params) {
            params = _this.defaults.queryTransform(resourceConfig, params);
            deepMixIn(options.params, params);
          }
          return this.PUT(_this.getPath('updateAll', resourceConfig, attrs, options), options.serialize ? options.serialize(resourceConfig, attrs) : _this.defaults.serialize(resourceConfig, attrs), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }, {
        key: 'destroy',
        value: function destroy(resourceConfig, id, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          options.params = _this.defaults.queryTransform(resourceConfig, options.params);
          return _this.DEL(_this.getPath('destroy', resourceConfig, id, options), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }, {
        key: 'destroyAll',
        value: function destroyAll(resourceConfig, params, options) {
          var _this = this;
          options = options ? copy(options) : {};
          options.suffix = options.suffix || resourceConfig.suffix;
          options.params = options.params || {};
          if (params) {
            params = _this.defaults.queryTransform(resourceConfig, params);
            deepMixIn(options.params, params);
          }
          return this.DEL(_this.getPath('destroyAll', resourceConfig, params, options), options).then(function(data) {
            return (options.deserialize ? options.deserialize : _this.defaults.deserialize)(resourceConfig, data);
          });
        }
      }]);
      return DSHttpAdapter;
    })();
    module.exports = DSHttpAdapter;
  }, function(module, exports, __webpack_require__) {
    if (typeof __WEBPACK_EXTERNAL_MODULE_5__ === 'undefined') {
      var e = new Error("Cannot find module \"axios\"");
      e.code = 'MODULE_NOT_FOUND';
      throw e;
    }
    module.exports = __WEBPACK_EXTERNAL_MODULE_5__;
  }]);
});
;
})();
(function() {
function define(){};  define.amd = {};
System.register("github:js-data/js-data-angular@3.0.0", ["github:js-data/js-data-angular@3.0.0/dist/js-data-angular"], false, function(__require, __exports, __module) {
  return (function(main) {
    return main;
  }).call(this, __require('github:js-data/js-data-angular@3.0.0/dist/js-data-angular'));
});
})();
System.register("github:angular-ui/ui-select@0.12.1/dist/select", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    (function() {
      "use strict";
      var KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        COMMAND: 91,
        MAP: {
          91: "COMMAND",
          8: "BACKSPACE",
          9: "TAB",
          13: "ENTER",
          16: "SHIFT",
          17: "CTRL",
          18: "ALT",
          19: "PAUSEBREAK",
          20: "CAPSLOCK",
          27: "ESC",
          32: "SPACE",
          33: "PAGE_UP",
          34: "PAGE_DOWN",
          35: "END",
          36: "HOME",
          37: "LEFT",
          38: "UP",
          39: "RIGHT",
          40: "DOWN",
          43: "+",
          44: "PRINTSCREEN",
          45: "INSERT",
          46: "DELETE",
          48: "0",
          49: "1",
          50: "2",
          51: "3",
          52: "4",
          53: "5",
          54: "6",
          55: "7",
          56: "8",
          57: "9",
          59: ";",
          61: "=",
          65: "A",
          66: "B",
          67: "C",
          68: "D",
          69: "E",
          70: "F",
          71: "G",
          72: "H",
          73: "I",
          74: "J",
          75: "K",
          76: "L",
          77: "M",
          78: "N",
          79: "O",
          80: "P",
          81: "Q",
          82: "R",
          83: "S",
          84: "T",
          85: "U",
          86: "V",
          87: "W",
          88: "X",
          89: "Y",
          90: "Z",
          96: "0",
          97: "1",
          98: "2",
          99: "3",
          100: "4",
          101: "5",
          102: "6",
          103: "7",
          104: "8",
          105: "9",
          106: "*",
          107: "+",
          109: "-",
          110: ".",
          111: "/",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NUMLOCK",
          145: "SCROLLLOCK",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'"
        },
        isControl: function(e) {
          var k = e.which;
          switch (k) {
            case KEY.COMMAND:
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
              return true;
          }
          if (e.metaKey)
            return true;
          return false;
        },
        isFunctionKey: function(k) {
          k = k.which ? k.which : k;
          return k >= 112 && k <= 123;
        },
        isVerticalMovement: function(k) {
          return ~[KEY.UP, KEY.DOWN].indexOf(k);
        },
        isHorizontalMovement: function(k) {
          return ~[KEY.LEFT, KEY.RIGHT, KEY.BACKSPACE, KEY.DELETE].indexOf(k);
        }
      };
      if (angular.element.prototype.querySelectorAll === undefined) {
        angular.element.prototype.querySelectorAll = function(selector) {
          return angular.element(this[0].querySelectorAll(selector));
        };
      }
      if (angular.element.prototype.closest === undefined) {
        angular.element.prototype.closest = function(selector) {
          var elem = this[0];
          var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
          while (elem) {
            if (matchesSelector.bind(elem)(selector)) {
              return elem;
            } else {
              elem = elem.parentElement;
            }
          }
          return false;
        };
      }
      var latestId = 0;
      var uis = angular.module('ui.select', []).constant('uiSelectConfig', {
        theme: 'bootstrap',
        searchEnabled: true,
        sortable: false,
        placeholder: '',
        refreshDelay: 1000,
        closeOnSelect: true,
        generateId: function() {
          return latestId++;
        },
        appendToBody: false
      }).service('uiSelectMinErr', function() {
        var minErr = angular.$$minErr('ui.select');
        return function() {
          var error = minErr.apply(this, arguments);
          var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
          return new Error(message);
        };
      }).directive('uisTranscludeAppend', function() {
        return {link: function(scope, element, attrs, ctrl, transclude) {
            transclude(scope, function(clone) {
              element.append(clone);
            });
          }};
      }).filter('highlight', function() {
        function escapeRegexp(queryToEscape) {
          return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }
        return function(matchItem, query) {
          return query && matchItem ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
        };
      }).factory('uisOffset', ['$document', '$window', function($document, $window) {
        return function(element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          };
        };
      }]);
      uis.directive('uiSelectChoices', ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {
        return {
          restrict: 'EA',
          require: '^uiSelect',
          replace: true,
          transclude: true,
          templateUrl: function(tElement) {
            var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
            return theme + '/choices.tpl.html';
          },
          compile: function(tElement, tAttrs) {
            if (!tAttrs.repeat)
              throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");
            return function link(scope, element, attrs, $select, transcludeFn) {
              var groupByExp = attrs.groupBy;
              var groupFilterExp = attrs.groupFilter;
              $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp);
              $select.disableChoiceExpression = attrs.uiDisableChoice;
              $select.onHighlightCallback = attrs.onHighlight;
              if (groupByExp) {
                var groups = element.querySelectorAll('.ui-select-choices-group');
                if (groups.length !== 1)
                  throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
                groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
              }
              var choices = element.querySelectorAll('.ui-select-choices-row');
              if (choices.length !== 1) {
                throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
              }
              choices.attr('ng-repeat', RepeatParser.getNgRepeatExpression($select.parserResult.itemName, '$select.items', $select.parserResult.trackByExp, groupByExp)).attr('ng-if', '$select.open').attr('ng-mouseenter', '$select.setActiveItem(' + $select.parserResult.itemName + ')').attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',false,$event)');
              var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');
              if (rowsInner.length !== 1)
                throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
              rowsInner.attr('uis-transclude-append', '');
              $compile(element, transcludeFn)(scope);
              scope.$watch('$select.search', function(newValue) {
                if (newValue && !$select.open && $select.multiple)
                  $select.activate(false, true);
                $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
                $select.refresh(attrs.refresh);
              });
              attrs.$observe('refreshDelay', function() {
                var refreshDelay = scope.$eval(attrs.refreshDelay);
                $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
              });
            };
          }
        };
      }]);
      uis.controller('uiSelectCtrl', ['$scope', '$element', '$timeout', '$filter', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig) {
        var ctrl = this;
        var EMPTY_SEARCH = '';
        ctrl.placeholder = uiSelectConfig.placeholder;
        ctrl.searchEnabled = uiSelectConfig.searchEnabled;
        ctrl.sortable = uiSelectConfig.sortable;
        ctrl.refreshDelay = uiSelectConfig.refreshDelay;
        ctrl.removeSelected = false;
        ctrl.closeOnSelect = true;
        ctrl.search = EMPTY_SEARCH;
        ctrl.activeIndex = 0;
        ctrl.items = [];
        ctrl.open = false;
        ctrl.focus = false;
        ctrl.disabled = false;
        ctrl.selected = undefined;
        ctrl.focusser = undefined;
        ctrl.resetSearchInput = true;
        ctrl.multiple = undefined;
        ctrl.disableChoiceExpression = undefined;
        ctrl.tagging = {
          isActivated: false,
          fct: undefined
        };
        ctrl.taggingTokens = {
          isActivated: false,
          tokens: undefined
        };
        ctrl.lockChoiceExpression = undefined;
        ctrl.clickTriggeredSelect = false;
        ctrl.$filter = $filter;
        ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
        if (ctrl.searchInput.length !== 1) {
          throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
        }
        ctrl.isEmpty = function() {
          return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '';
        };
        function _resetSearchInput() {
          if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {
            ctrl.search = EMPTY_SEARCH;
            if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
              ctrl.activeIndex = ctrl.items.indexOf(ctrl.selected);
            }
          }
        }
        function _groupsFilter(groups, groupNames) {
          var i,
              j,
              result = [];
          for (i = 0; i < groupNames.length; i++) {
            for (j = 0; j < groups.length; j++) {
              if (groups[j].name == [groupNames[i]]) {
                result.push(groups[j]);
              }
            }
          }
          return result;
        }
        ctrl.activate = function(initSearchValue, avoidReset) {
          if (!ctrl.disabled && !ctrl.open) {
            if (!avoidReset)
              _resetSearchInput();
            $scope.$broadcast('uis:activate');
            ctrl.open = true;
            ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
            if (ctrl.activeIndex === -1 && ctrl.taggingLabel !== false) {
              ctrl.activeIndex = 0;
            }
            $timeout(function() {
              ctrl.search = initSearchValue || ctrl.search;
              ctrl.searchInput[0].focus();
            });
          }
        };
        ctrl.findGroupByName = function(name) {
          return ctrl.groups && ctrl.groups.filter(function(group) {
            return group.name === name;
          })[0];
        };
        ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
          function updateGroups(items) {
            var groupFn = $scope.$eval(groupByExp);
            ctrl.groups = [];
            angular.forEach(items, function(item) {
              var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
              var group = ctrl.findGroupByName(groupName);
              if (group) {
                group.items.push(item);
              } else {
                ctrl.groups.push({
                  name: groupName,
                  items: [item]
                });
              }
            });
            if (groupFilterExp) {
              var groupFilterFn = $scope.$eval(groupFilterExp);
              if (angular.isFunction(groupFilterFn)) {
                ctrl.groups = groupFilterFn(ctrl.groups);
              } else if (angular.isArray(groupFilterFn)) {
                ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
              }
            }
            ctrl.items = [];
            ctrl.groups.forEach(function(group) {
              ctrl.items = ctrl.items.concat(group.items);
            });
          }
          function setPlainItems(items) {
            ctrl.items = items;
          }
          ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;
          ctrl.parserResult = RepeatParser.parse(repeatAttr);
          ctrl.isGrouped = !!groupByExp;
          ctrl.itemProperty = ctrl.parserResult.itemName;
          ctrl.refreshItems = function(data) {
            data = data || ctrl.parserResult.source($scope);
            var selectedItems = ctrl.selected;
            if ((angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.removeSelected) {
              ctrl.setItemsFn(data);
            } else {
              if (data !== undefined) {
                var filteredItems = data.filter(function(i) {
                  return selectedItems.indexOf(i) < 0;
                });
                ctrl.setItemsFn(filteredItems);
              }
            }
          };
          $scope.$watchCollection(ctrl.parserResult.source, function(items) {
            if (items === undefined || items === null) {
              ctrl.items = [];
            } else {
              if (!angular.isArray(items)) {
                throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
              } else {
                ctrl.refreshItems(items);
                ctrl.ngModel.$modelValue = null;
              }
            }
          });
        };
        var _refreshDelayPromise;
        ctrl.refresh = function(refreshAttr) {
          if (refreshAttr !== undefined) {
            if (_refreshDelayPromise) {
              $timeout.cancel(_refreshDelayPromise);
            }
            _refreshDelayPromise = $timeout(function() {
              $scope.$eval(refreshAttr);
            }, ctrl.refreshDelay);
          }
        };
        ctrl.setActiveItem = function(item) {
          ctrl.activeIndex = ctrl.items.indexOf(item);
        };
        ctrl.isActive = function(itemScope) {
          if (!ctrl.open) {
            return false;
          }
          var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
          var isActive = itemIndex === ctrl.activeIndex;
          if (!isActive || (itemIndex < 0 && ctrl.taggingLabel !== false) || (itemIndex < 0 && ctrl.taggingLabel === false)) {
            return false;
          }
          if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
            itemScope.$eval(ctrl.onHighlightCallback);
          }
          return isActive;
        };
        ctrl.isDisabled = function(itemScope) {
          if (!ctrl.open)
            return ;
          var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
          var isDisabled = false;
          var item;
          if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
            item = ctrl.items[itemIndex];
            isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression));
            item._uiSelectChoiceDisabled = isDisabled;
          }
          return isDisabled;
        };
        ctrl.select = function(item, skipFocusser, $event) {
          if (item === undefined || !item._uiSelectChoiceDisabled) {
            if (!ctrl.items && !ctrl.search)
              return ;
            if (!item || !item._uiSelectChoiceDisabled) {
              if (ctrl.tagging.isActivated) {
                if (ctrl.taggingLabel === false) {
                  if (ctrl.activeIndex < 0) {
                    item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
                    if (!item || angular.equals(ctrl.items[0], item)) {
                      return ;
                    }
                  } else {
                    item = ctrl.items[ctrl.activeIndex];
                  }
                } else {
                  if (ctrl.activeIndex === 0) {
                    if (item === undefined)
                      return ;
                    if (ctrl.tagging.fct !== undefined && typeof item === 'string') {
                      item = ctrl.tagging.fct(ctrl.search);
                      if (!item)
                        return ;
                    } else if (typeof item === 'string') {
                      item = item.replace(ctrl.taggingLabel, '').trim();
                    }
                  }
                }
                if (ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter(function(selection) {
                  return angular.equals(selection, item);
                }).length > 0) {
                  ctrl.close(skipFocusser);
                  return ;
                }
              }
              $scope.$broadcast('uis:select', item);
              var locals = {};
              locals[ctrl.parserResult.itemName] = item;
              $timeout(function() {
                ctrl.onSelectCallback($scope, {
                  $item: item,
                  $model: ctrl.parserResult.modelMapper($scope, locals)
                });
              });
              if (ctrl.closeOnSelect) {
                ctrl.close(skipFocusser);
              }
              if ($event && $event.type === 'click') {
                ctrl.clickTriggeredSelect = true;
              }
            }
          }
        };
        ctrl.close = function(skipFocusser) {
          if (!ctrl.open)
            return ;
          if (ctrl.ngModel && ctrl.ngModel.$setTouched)
            ctrl.ngModel.$setTouched();
          _resetSearchInput();
          ctrl.open = false;
          $scope.$broadcast('uis:close', skipFocusser);
        };
        ctrl.setFocus = function() {
          if (!ctrl.focus)
            ctrl.focusInput[0].focus();
        };
        ctrl.clear = function($event) {
          ctrl.select(undefined);
          $event.stopPropagation();
          $timeout(function() {
            ctrl.focusser[0].focus();
          }, 0, false);
        };
        ctrl.toggle = function(e) {
          if (ctrl.open) {
            ctrl.close();
            e.preventDefault();
            e.stopPropagation();
          } else {
            ctrl.activate();
          }
        };
        ctrl.isLocked = function(itemScope, itemIndex) {
          var isLocked,
              item = ctrl.selected[itemIndex];
          if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
            isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression));
            item._uiSelectChoiceLocked = isLocked;
          }
          return isLocked;
        };
        var sizeWatch = null;
        ctrl.sizeSearchInput = function() {
          var input = ctrl.searchInput[0],
              container = ctrl.searchInput.parent().parent()[0],
              calculateContainerWidth = function() {
                return container.clientWidth * !!input.offsetParent;
              },
              updateIfVisible = function(containerWidth) {
                if (containerWidth === 0) {
                  return false;
                }
                var inputWidth = containerWidth - input.offsetLeft - 10;
                if (inputWidth < 50)
                  inputWidth = containerWidth;
                ctrl.searchInput.css('width', inputWidth + 'px');
                return true;
              };
          ctrl.searchInput.css('width', '10px');
          $timeout(function() {
            if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
              sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {
                if (updateIfVisible(containerWidth)) {
                  sizeWatch();
                  sizeWatch = null;
                }
              });
            }
          });
        };
        function _handleDropDownSelection(key) {
          var processed = true;
          switch (key) {
            case KEY.DOWN:
              if (!ctrl.open && ctrl.multiple)
                ctrl.activate(false, true);
              else if (ctrl.activeIndex < ctrl.items.length - 1) {
                ctrl.activeIndex++;
              }
              break;
            case KEY.UP:
              if (!ctrl.open && ctrl.multiple)
                ctrl.activate(false, true);
              else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) {
                ctrl.activeIndex--;
              }
              break;
            case KEY.TAB:
              if (!ctrl.multiple || ctrl.open)
                ctrl.select(ctrl.items[ctrl.activeIndex], true);
              break;
            case KEY.ENTER:
              if (ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)) {
                ctrl.select(ctrl.items[ctrl.activeIndex]);
              } else {
                ctrl.activate(false, true);
              }
              break;
            case KEY.ESC:
              ctrl.close();
              break;
            default:
              processed = false;
          }
          return processed;
        }
        ctrl.searchInput.on('keydown', function(e) {
          var key = e.which;
          $scope.$apply(function() {
            var tagged = false;
            if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
              _handleDropDownSelection(key);
              if (ctrl.taggingTokens.isActivated) {
                for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                  if (ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode]) {
                    if (ctrl.search.length > 0) {
                      tagged = true;
                    }
                  }
                }
                if (tagged) {
                  $timeout(function() {
                    ctrl.searchInput.triggerHandler('tagged');
                    var newItem = ctrl.search.replace(KEY.MAP[e.keyCode], '').trim();
                    if (ctrl.tagging.fct) {
                      newItem = ctrl.tagging.fct(newItem);
                    }
                    if (newItem)
                      ctrl.select(newItem, true);
                  });
                }
              }
            }
          });
          if (KEY.isVerticalMovement(key) && ctrl.items.length > 0) {
            _ensureHighlightVisible();
          }
          if (key === KEY.ENTER || key === KEY.ESC) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
        ctrl.searchInput.on('paste', function(e) {
          var data = e.originalEvent.clipboardData.getData('text/plain');
          if (data && data.length > 0 && ctrl.taggingTokens.isActivated && ctrl.tagging.fct) {
            var items = data.split(ctrl.taggingTokens.tokens[0]);
            if (items && items.length > 0) {
              angular.forEach(items, function(item) {
                var newItem = ctrl.tagging.fct(item);
                if (newItem) {
                  ctrl.select(newItem, true);
                }
              });
              e.preventDefault();
              e.stopPropagation();
            }
          }
        });
        ctrl.searchInput.on('tagged', function() {
          $timeout(function() {
            _resetSearchInput();
          });
        });
        function _ensureHighlightVisible() {
          var container = $element.querySelectorAll('.ui-select-choices-content');
          var choices = container.querySelectorAll('.ui-select-choices-row');
          if (choices.length < 1) {
            throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
          }
          if (ctrl.activeIndex < 0) {
            return ;
          }
          var highlighted = choices[ctrl.activeIndex];
          var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
          var height = container[0].offsetHeight;
          if (posY > height) {
            container[0].scrollTop += posY - height;
          } else if (posY < highlighted.clientHeight) {
            if (ctrl.isGrouped && ctrl.activeIndex === 0)
              container[0].scrollTop = 0;
            else
              container[0].scrollTop -= highlighted.clientHeight - posY;
          }
        }
        $scope.$on('$destroy', function() {
          ctrl.searchInput.off('keyup keydown tagged blur paste');
        });
      }]);
      uis.directive('uiSelect', ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout', function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {
        return {
          restrict: 'EA',
          templateUrl: function(tElement, tAttrs) {
            var theme = tAttrs.theme || uiSelectConfig.theme;
            return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
          },
          replace: true,
          transclude: true,
          require: ['uiSelect', '^ngModel'],
          scope: true,
          controller: 'uiSelectCtrl',
          controllerAs: '$select',
          compile: function(tElement, tAttrs) {
            if (angular.isDefined(tAttrs.multiple))
              tElement.append("<ui-select-multiple/>").removeAttr('multiple');
            else
              tElement.append("<ui-select-single/>");
            return function(scope, element, attrs, ctrls, transcludeFn) {
              var $select = ctrls[0];
              var ngModel = ctrls[1];
              $select.generatedId = uiSelectConfig.generateId();
              $select.baseTitle = attrs.title || 'Select box';
              $select.focusserTitle = $select.baseTitle + ' focus';
              $select.focusserId = 'focusser-' + $select.generatedId;
              $select.closeOnSelect = function() {
                if (angular.isDefined(attrs.closeOnSelect)) {
                  return $parse(attrs.closeOnSelect)();
                } else {
                  return uiSelectConfig.closeOnSelect;
                }
              }();
              $select.onSelectCallback = $parse(attrs.onSelect);
              $select.onRemoveCallback = $parse(attrs.onRemove);
              $select.ngModel = ngModel;
              $select.choiceGrouped = function(group) {
                return $select.isGrouped && group && group.name;
              };
              if (attrs.tabindex) {
                attrs.$observe('tabindex', function(value) {
                  $select.focusInput.attr("tabindex", value);
                  element.removeAttr("tabindex");
                });
              }
              scope.$watch('searchEnabled', function() {
                var searchEnabled = scope.$eval(attrs.searchEnabled);
                $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
              });
              scope.$watch('sortable', function() {
                var sortable = scope.$eval(attrs.sortable);
                $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
              });
              attrs.$observe('disabled', function() {
                $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
              });
              attrs.$observe('resetSearchInput', function() {
                var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
              });
              attrs.$observe('tagging', function() {
                if (attrs.tagging !== undefined) {
                  var taggingEval = scope.$eval(attrs.tagging);
                  $select.tagging = {
                    isActivated: true,
                    fct: taggingEval !== true ? taggingEval : undefined
                  };
                } else {
                  $select.tagging = {
                    isActivated: false,
                    fct: undefined
                  };
                }
              });
              attrs.$observe('taggingLabel', function() {
                if (attrs.tagging !== undefined) {
                  if (attrs.taggingLabel === 'false') {
                    $select.taggingLabel = false;
                  } else {
                    $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
                  }
                }
              });
              attrs.$observe('taggingTokens', function() {
                if (attrs.tagging !== undefined) {
                  var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',', 'ENTER'];
                  $select.taggingTokens = {
                    isActivated: true,
                    tokens: tokens
                  };
                }
              });
              if (angular.isDefined(attrs.autofocus)) {
                $timeout(function() {
                  $select.setFocus();
                });
              }
              if (angular.isDefined(attrs.focusOn)) {
                scope.$on(attrs.focusOn, function() {
                  $timeout(function() {
                    $select.setFocus();
                  });
                });
              }
              function onDocumentClick(e) {
                if (!$select.open)
                  return ;
                var contains = false;
                if (window.jQuery) {
                  contains = window.jQuery.contains(element[0], e.target);
                } else {
                  contains = element[0].contains(e.target);
                }
                if (!contains && !$select.clickTriggeredSelect) {
                  var focusableControls = ['input', 'button', 'textarea'];
                  var targetScope = angular.element(e.target).scope();
                  var skipFocusser = targetScope && targetScope.$select && targetScope.$select !== $select;
                  if (!skipFocusser)
                    skipFocusser = ~focusableControls.indexOf(e.target.tagName.toLowerCase());
                  $select.close(skipFocusser);
                  scope.$digest();
                }
                $select.clickTriggeredSelect = false;
              }
              $document.on('click', onDocumentClick);
              scope.$on('$destroy', function() {
                $document.off('click', onDocumentClick);
              });
              transcludeFn(scope, function(clone) {
                var transcluded = angular.element('<div>').append(clone);
                var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
                transcludedMatch.removeAttr('ui-select-match');
                transcludedMatch.removeAttr('data-ui-select-match');
                if (transcludedMatch.length !== 1) {
                  throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
                }
                element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);
                var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
                transcludedChoices.removeAttr('ui-select-choices');
                transcludedChoices.removeAttr('data-ui-select-choices');
                if (transcludedChoices.length !== 1) {
                  throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
                }
                element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);
              });
              var appendToBody = scope.$eval(attrs.appendToBody);
              if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
                scope.$watch('$select.open', function(isOpen) {
                  if (isOpen) {
                    positionDropdown();
                  } else {
                    resetDropdown();
                  }
                });
                scope.$on('$destroy', function() {
                  resetDropdown();
                });
              }
              var placeholder = null,
                  originalWidth = '';
              function positionDropdown() {
                var offset = uisOffset(element);
                placeholder = angular.element('<div class="ui-select-placeholder"></div>');
                placeholder[0].style.width = offset.width + 'px';
                placeholder[0].style.height = offset.height + 'px';
                element.after(placeholder);
                originalWidth = element[0].style.width;
                $document.find('body').append(element);
                element[0].style.position = 'absolute';
                element[0].style.left = offset.left + 'px';
                element[0].style.top = offset.top + 'px';
                element[0].style.width = offset.width + 'px';
              }
              function resetDropdown() {
                if (placeholder === null) {
                  return ;
                }
                placeholder.replaceWith(element);
                placeholder = null;
                element[0].style.position = '';
                element[0].style.left = '';
                element[0].style.top = '';
                element[0].style.width = originalWidth;
              }
              var dropdown = null,
                  directionUpClassName = 'direction-up';
              scope.$watch('$select.open', function(isOpen) {
                if (isOpen) {
                  dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');
                  if (dropdown === null) {
                    return ;
                  }
                  dropdown[0].style.opacity = 0;
                  $timeout(function() {
                    var offset = uisOffset(element);
                    var offsetDropdown = uisOffset(dropdown);
                    if (offset.top + offset.height + offsetDropdown.height > $document[0].documentElement.scrollTop + $document[0].documentElement.clientHeight) {
                      dropdown[0].style.position = 'absolute';
                      dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
                      element.addClass(directionUpClassName);
                    }
                    dropdown[0].style.opacity = 1;
                  });
                } else {
                  if (dropdown === null) {
                    return ;
                  }
                  dropdown[0].style.position = '';
                  dropdown[0].style.top = '';
                  element.removeClass(directionUpClassName);
                }
              });
            };
          }
        };
      }]);
      uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
        return {
          restrict: 'EA',
          require: '^uiSelect',
          replace: true,
          transclude: true,
          templateUrl: function(tElement) {
            var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
            var multi = tElement.parent().attr('multiple');
            return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
          },
          link: function(scope, element, attrs, $select) {
            $select.lockChoiceExpression = attrs.uiLockChoice;
            attrs.$observe('placeholder', function(placeholder) {
              $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
            });
            function setAllowClear(allow) {
              $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
            }
            attrs.$observe('allowClear', setAllowClear);
            setAllowClear(attrs.allowClear);
            if ($select.multiple) {
              $select.sizeSearchInput();
            }
          }
        };
      }]);
      uis.directive('uiSelectMultiple', ['uiSelectMinErr', '$timeout', function(uiSelectMinErr, $timeout) {
        return {
          restrict: 'EA',
          require: ['^uiSelect', '^ngModel'],
          controller: ['$scope', '$timeout', function($scope, $timeout) {
            var ctrl = this,
                $select = $scope.$select,
                ngModel;
            $scope.$evalAsync(function() {
              ngModel = $scope.ngModel;
            });
            ctrl.activeMatchIndex = -1;
            ctrl.updateModel = function() {
              ngModel.$setViewValue(Date.now());
              ctrl.refreshComponent();
            };
            ctrl.refreshComponent = function() {
              $select.refreshItems();
              $select.sizeSearchInput();
            };
            ctrl.removeChoice = function(index) {
              var removedChoice = $select.selected[index];
              if (removedChoice._uiSelectChoiceLocked)
                return ;
              var locals = {};
              locals[$select.parserResult.itemName] = removedChoice;
              $select.selected.splice(index, 1);
              ctrl.activeMatchIndex = -1;
              $select.sizeSearchInput();
              $timeout(function() {
                $select.onRemoveCallback($scope, {
                  $item: removedChoice,
                  $model: $select.parserResult.modelMapper($scope, locals)
                });
              });
              ctrl.updateModel();
            };
            ctrl.getPlaceholder = function() {
              if ($select.selected.length)
                return ;
              return $select.placeholder;
            };
          }],
          controllerAs: '$selectMultiple',
          link: function(scope, element, attrs, ctrls) {
            var $select = ctrls[0];
            var ngModel = scope.ngModel = ctrls[1];
            var $selectMultiple = scope.$selectMultiple;
            $select.multiple = true;
            $select.removeSelected = true;
            $select.focusInput = $select.searchInput;
            ngModel.$parsers.unshift(function() {
              var locals = {},
                  result,
                  resultMultiple = [];
              for (var j = $select.selected.length - 1; j >= 0; j--) {
                locals = {};
                locals[$select.parserResult.itemName] = $select.selected[j];
                result = $select.parserResult.modelMapper(scope, locals);
                resultMultiple.unshift(result);
              }
              return resultMultiple;
            });
            ngModel.$formatters.unshift(function(inputValue) {
              var data = $select.parserResult.source(scope, {$select: {search: ''}}),
                  locals = {},
                  result;
              if (!data)
                return inputValue;
              var resultMultiple = [];
              var checkFnMultiple = function(list, value) {
                if (!list || !list.length)
                  return ;
                for (var p = list.length - 1; p >= 0; p--) {
                  locals[$select.parserResult.itemName] = list[p];
                  result = $select.parserResult.modelMapper(scope, locals);
                  if ($select.parserResult.trackByExp) {
                    var matches = /\.(.+)/.exec($select.parserResult.trackByExp);
                    if (matches.length > 0 && result[matches[1]] == value[matches[1]]) {
                      resultMultiple.unshift(list[p]);
                      return true;
                    }
                  }
                  if (angular.equals(result, value)) {
                    resultMultiple.unshift(list[p]);
                    return true;
                  }
                }
                return false;
              };
              if (!inputValue)
                return resultMultiple;
              for (var k = inputValue.length - 1; k >= 0; k--) {
                if (!checkFnMultiple($select.selected, inputValue[k])) {
                  if (!checkFnMultiple(data, inputValue[k])) {
                    resultMultiple.unshift(inputValue[k]);
                  }
                }
              }
              return resultMultiple;
            });
            scope.$watchCollection(function() {
              return ngModel.$modelValue;
            }, function(newValue, oldValue) {
              if (oldValue != newValue) {
                ngModel.$modelValue = null;
                $selectMultiple.refreshComponent();
              }
            });
            ngModel.$render = function() {
              if (!angular.isArray(ngModel.$viewValue)) {
                if (angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null) {
                  $select.selected = [];
                } else {
                  throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
                }
              }
              $select.selected = ngModel.$viewValue;
              scope.$evalAsync();
            };
            scope.$on('uis:select', function(event, item) {
              $select.selected.push(item);
              $selectMultiple.updateModel();
            });
            scope.$on('uis:activate', function() {
              $selectMultiple.activeMatchIndex = -1;
            });
            scope.$watch('$select.disabled', function(newValue, oldValue) {
              if (oldValue && !newValue)
                $select.sizeSearchInput();
            });
            $select.searchInput.on('keydown', function(e) {
              var key = e.which;
              scope.$apply(function() {
                var processed = false;
                if (KEY.isHorizontalMovement(key)) {
                  processed = _handleMatchSelection(key);
                }
                if (processed && key != KEY.TAB) {
                  e.preventDefault();
                  e.stopPropagation();
                }
              });
            });
            function _getCaretPosition(el) {
              if (angular.isNumber(el.selectionStart))
                return el.selectionStart;
              else
                return el.value.length;
            }
            function _handleMatchSelection(key) {
              var caretPosition = _getCaretPosition($select.searchInput[0]),
                  length = $select.selected.length,
                  first = 0,
                  last = length - 1,
                  curr = $selectMultiple.activeMatchIndex,
                  next = $selectMultiple.activeMatchIndex + 1,
                  prev = $selectMultiple.activeMatchIndex - 1,
                  newIndex = curr;
              if (caretPosition > 0 || ($select.search.length && key == KEY.RIGHT))
                return false;
              $select.close();
              function getNewActiveMatchIndex() {
                switch (key) {
                  case KEY.LEFT:
                    if (~$selectMultiple.activeMatchIndex)
                      return prev;
                    else
                      return last;
                    break;
                  case KEY.RIGHT:
                    if (!~$selectMultiple.activeMatchIndex || curr === last) {
                      $select.activate();
                      return false;
                    } else
                      return next;
                    break;
                  case KEY.BACKSPACE:
                    if (~$selectMultiple.activeMatchIndex) {
                      $selectMultiple.removeChoice(curr);
                      return prev;
                    } else
                      return last;
                    break;
                  case KEY.DELETE:
                    if (~$selectMultiple.activeMatchIndex) {
                      $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                      return curr;
                    } else
                      return false;
                }
              }
              newIndex = getNewActiveMatchIndex();
              if (!$select.selected.length || newIndex === false)
                $selectMultiple.activeMatchIndex = -1;
              else
                $selectMultiple.activeMatchIndex = Math.min(last, Math.max(first, newIndex));
              return true;
            }
            $select.searchInput.on('keyup', function(e) {
              if (!KEY.isVerticalMovement(e.which)) {
                scope.$evalAsync(function() {
                  $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                });
              }
              if ($select.tagging.isActivated && $select.search.length > 0) {
                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which)) {
                  return ;
                }
                $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                if ($select.taggingLabel === false)
                  return ;
                var items = angular.copy($select.items);
                var stashArr = angular.copy($select.items);
                var newItem;
                var item;
                var hasTag = false;
                var dupeIndex = -1;
                var tagItems;
                var tagItem;
                if ($select.tagging.fct !== undefined) {
                  tagItems = $select.$filter('filter')(items, {'isTag': true});
                  if (tagItems.length > 0) {
                    tagItem = tagItems[0];
                  }
                  if (items.length > 0 && tagItem) {
                    hasTag = true;
                    items = items.slice(1, items.length);
                    stashArr = stashArr.slice(1, stashArr.length);
                  }
                  newItem = $select.tagging.fct($select.search);
                  newItem.isTag = true;
                  if (stashArr.filter(function(origItem) {
                    return angular.equals(origItem, $select.tagging.fct($select.search));
                  }).length > 0) {
                    return ;
                  }
                  newItem.isTag = true;
                } else {
                  tagItems = $select.$filter('filter')(items, function(item) {
                    return item.match($select.taggingLabel);
                  });
                  if (tagItems.length > 0) {
                    tagItem = tagItems[0];
                  }
                  item = items[0];
                  if (item !== undefined && items.length > 0 && tagItem) {
                    hasTag = true;
                    items = items.slice(1, items.length);
                    stashArr = stashArr.slice(1, stashArr.length);
                  }
                  newItem = $select.search + ' ' + $select.taggingLabel;
                  if (_findApproxDupe($select.selected, $select.search) > -1) {
                    return ;
                  }
                  if (_findCaseInsensitiveDupe(stashArr.concat($select.selected))) {
                    if (hasTag) {
                      items = stashArr;
                      scope.$evalAsync(function() {
                        $select.activeIndex = 0;
                        $select.items = items;
                      });
                    }
                    return ;
                  }
                  if (_findCaseInsensitiveDupe(stashArr)) {
                    if (hasTag) {
                      $select.items = stashArr.slice(1, stashArr.length);
                    }
                    return ;
                  }
                }
                if (hasTag)
                  dupeIndex = _findApproxDupe($select.selected, newItem);
                if (dupeIndex > -1) {
                  items = items.slice(dupeIndex + 1, items.length - 1);
                } else {
                  items = [];
                  items.push(newItem);
                  items = items.concat(stashArr);
                }
                scope.$evalAsync(function() {
                  $select.activeIndex = 0;
                  $select.items = items;
                });
              }
            });
            function _findCaseInsensitiveDupe(arr) {
              if (arr === undefined || $select.search === undefined) {
                return false;
              }
              var hasDupe = arr.filter(function(origItem) {
                if ($select.search.toUpperCase() === undefined || origItem === undefined) {
                  return false;
                }
                return origItem.toUpperCase() === $select.search.toUpperCase();
              }).length > 0;
              return hasDupe;
            }
            function _findApproxDupe(haystack, needle) {
              var dupeIndex = -1;
              if (angular.isArray(haystack)) {
                var tempArr = angular.copy(haystack);
                for (var i = 0; i < tempArr.length; i++) {
                  if ($select.tagging.fct === undefined) {
                    if (tempArr[i] + ' ' + $select.taggingLabel === needle) {
                      dupeIndex = i;
                    }
                  } else {
                    var mockObj = tempArr[i];
                    mockObj.isTag = true;
                    if (angular.equals(mockObj, needle)) {
                      dupeIndex = i;
                    }
                  }
                }
              }
              return dupeIndex;
            }
            $select.searchInput.on('blur', function() {
              $timeout(function() {
                $selectMultiple.activeMatchIndex = -1;
              });
            });
          }
        };
      }]);
      uis.directive('uiSelectSingle', ['$timeout', '$compile', function($timeout, $compile) {
        return {
          restrict: 'EA',
          require: ['^uiSelect', '^ngModel'],
          link: function(scope, element, attrs, ctrls) {
            var $select = ctrls[0];
            var ngModel = ctrls[1];
            ngModel.$parsers.unshift(function(inputValue) {
              var locals = {},
                  result;
              locals[$select.parserResult.itemName] = inputValue;
              result = $select.parserResult.modelMapper(scope, locals);
              return result;
            });
            ngModel.$formatters.unshift(function(inputValue) {
              var data = $select.parserResult.source(scope, {$select: {search: ''}}),
                  locals = {},
                  result;
              if (data) {
                var checkFnSingle = function(d) {
                  locals[$select.parserResult.itemName] = d;
                  result = $select.parserResult.modelMapper(scope, locals);
                  return result == inputValue;
                };
                if ($select.selected && checkFnSingle($select.selected)) {
                  return $select.selected;
                }
                for (var i = data.length - 1; i >= 0; i--) {
                  if (checkFnSingle(data[i]))
                    return data[i];
                }
              }
              return inputValue;
            });
            scope.$watch('$select.selected', function(newValue) {
              if (ngModel.$viewValue !== newValue) {
                ngModel.$setViewValue(newValue);
              }
            });
            ngModel.$render = function() {
              $select.selected = ngModel.$viewValue;
            };
            scope.$on('uis:select', function(event, item) {
              $select.selected = item;
            });
            scope.$on('uis:close', function(event, skipFocusser) {
              $timeout(function() {
                $select.focusser.prop('disabled', false);
                if (!skipFocusser)
                  $select.focusser[0].focus();
              }, 0, false);
            });
            scope.$on('uis:activate', function() {
              focusser.prop('disabled', true);
            });
            var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
            $compile(focusser)(scope);
            $select.focusser = focusser;
            $select.focusInput = focusser;
            element.parent().append(focusser);
            focusser.bind("focus", function() {
              scope.$evalAsync(function() {
                $select.focus = true;
              });
            });
            focusser.bind("blur", function() {
              scope.$evalAsync(function() {
                $select.focus = false;
              });
            });
            focusser.bind("keydown", function(e) {
              if (e.which === KEY.BACKSPACE) {
                e.preventDefault();
                e.stopPropagation();
                $select.select(undefined);
                scope.$apply();
                return ;
              }
              if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                return ;
              }
              if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE) {
                e.preventDefault();
                e.stopPropagation();
                $select.activate();
              }
              scope.$digest();
            });
            focusser.bind("keyup input", function(e) {
              if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
                return ;
              }
              $select.activate(focusser.val());
              focusser.val('');
              scope.$digest();
            });
          }
        };
      }]);
      uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
        return {
          require: '^uiSelect',
          link: function(scope, element, attrs, $select) {
            if (scope[attrs.uiSelectSort] === null) {
              throw uiSelectMinErr('sort', "Expected a list to sort");
            }
            var options = angular.extend({axis: 'horizontal'}, scope.$eval(attrs.uiSelectSortOptions));
            var axis = options.axis,
                draggingClassName = 'dragging',
                droppingClassName = 'dropping',
                droppingBeforeClassName = 'dropping-before',
                droppingAfterClassName = 'dropping-after';
            scope.$watch(function() {
              return $select.sortable;
            }, function(n) {
              if (n) {
                element.attr('draggable', true);
              } else {
                element.removeAttr('draggable');
              }
            });
            element.on('dragstart', function(e) {
              element.addClass(draggingClassName);
              (e.dataTransfer || e.originalEvent.dataTransfer).setData('text/plain', scope.$index);
            });
            element.on('dragend', function() {
              element.removeClass(draggingClassName);
            });
            var move = function(from, to) {
              this.splice(to, 0, this.splice(from, 1)[0]);
            };
            var dragOverHandler = function(e) {
              e.preventDefault();
              var offset = axis === 'vertical' ? e.offsetY || e.layerY || (e.originalEvent ? e.originalEvent.offsetY : 0) : e.offsetX || e.layerX || (e.originalEvent ? e.originalEvent.offsetX : 0);
              if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
                element.removeClass(droppingAfterClassName);
                element.addClass(droppingBeforeClassName);
              } else {
                element.removeClass(droppingBeforeClassName);
                element.addClass(droppingAfterClassName);
              }
            };
            var dropTimeout;
            var dropHandler = function(e) {
              e.preventDefault();
              var droppedItemIndex = parseInt((e.dataTransfer || e.originalEvent.dataTransfer).getData('text/plain'), 10);
              $timeout.cancel(dropTimeout);
              dropTimeout = $timeout(function() {
                _dropHandler(droppedItemIndex);
              }, 20);
            };
            var _dropHandler = function(droppedItemIndex) {
              var theList = scope.$eval(attrs.uiSelectSort),
                  itemToMove = theList[droppedItemIndex],
                  newIndex = null;
              if (element.hasClass(droppingBeforeClassName)) {
                if (droppedItemIndex < scope.$index) {
                  newIndex = scope.$index - 1;
                } else {
                  newIndex = scope.$index;
                }
              } else {
                if (droppedItemIndex < scope.$index) {
                  newIndex = scope.$index;
                } else {
                  newIndex = scope.$index + 1;
                }
              }
              move.apply(theList, [droppedItemIndex, newIndex]);
              scope.$apply(function() {
                scope.$emit('uiSelectSort:change', {
                  array: theList,
                  item: itemToMove,
                  from: droppedItemIndex,
                  to: newIndex
                });
              });
              element.removeClass(droppingClassName);
              element.removeClass(droppingBeforeClassName);
              element.removeClass(droppingAfterClassName);
              element.off('drop', dropHandler);
            };
            element.on('dragenter', function() {
              if (element.hasClass(draggingClassName)) {
                return ;
              }
              element.addClass(droppingClassName);
              element.on('dragover', dragOverHandler);
              element.on('drop', dropHandler);
            });
            element.on('dragleave', function(e) {
              if (e.target != element) {
                return ;
              }
              element.removeClass(droppingClassName);
              element.removeClass(droppingBeforeClassName);
              element.removeClass(droppingAfterClassName);
              element.off('dragover', dragOverHandler);
              element.off('drop', dropHandler);
            });
          }
        };
      }]);
      uis.service('uisRepeatParser', ['uiSelectMinErr', '$parse', function(uiSelectMinErr, $parse) {
        var self = this;
        self.parse = function(expression) {
          var match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?([\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
          }
          return {
            itemName: match[2],
            source: $parse(match[3]),
            trackByExp: match[4],
            modelMapper: $parse(match[1] || match[2])
          };
        };
        self.getGroupNgRepeatExpression = function() {
          return '$group in $select.groups';
        };
        self.getNgRepeatExpression = function(itemName, source, trackByExp, grouped) {
          var expression = itemName + ' in ' + (grouped ? '$group.items' : source);
          if (trackByExp) {
            expression += ' track by ' + trackByExp;
          }
          return expression;
        };
      }]);
    }());
    angular.module("ui.select").run(["$templateCache", function($templateCache) {
      $templateCache.put("bootstrap/choices.tpl.html", "<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"javascript:void(0)\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
      $templateCache.put("bootstrap/match-multiple.tpl.html", "<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
      $templateCache.put("bootstrap/match.tpl.html", "<div class=\"ui-select-match\" ng-hide=\"$select.open\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty()\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
      $templateCache.put("bootstrap/select-multiple.tpl.html", "<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div></div>");
      $templateCache.put("bootstrap/select.tpl.html", "<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div></div>");
      $templateCache.put("select2/choices.tpl.html", "<ul class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
      $templateCache.put("select2/match-multiple.tpl.html", "<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
      $templateCache.put("select2/match.tpl.html", "<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
      $templateCache.put("select2/select-multiple.tpl.html", "<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"text\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"ui-select-choices\"></div></div></div>");
      $templateCache.put("select2/select.tpl.html", "<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"select2-search\" ng-show=\"$select.searchEnabled\"><input type=\"text\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div></div></div>");
      $templateCache.put("selectize/choices.tpl.html", "<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
      $templateCache.put("selectize/match.tpl.html", "<div ng-hide=\"($select.open || $select.isEmpty())\" class=\"ui-select-match\" ng-transclude=\"\"></div>");
      $templateCache.put("selectize/select.tpl.html", "<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.activate()\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.searchEnabled || ($select.selected && !$select.open)\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div></div>");
    }]);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-ui/ui-select@0.12.1", ["github:angular-ui/ui-select@0.12.1/dist/select"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/ui-select@0.12.1/dist/select");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-ui/ui-router@0.2.15/angular-ui-router", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return ;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return ;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return ;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return ;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return ;
              }
              if ($location.url() === location)
                return ;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if (hash)
                toParams['#'] = hash;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return ;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return ;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            var newHref = null,
                isAnchor = element.prop("tagName").toUpperCase() === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : hrefKind,
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return ;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$addStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return ;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var states = [],
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$addStateInfo = function(newState, newParams) {
              var state = $state.get(newState, stateContext($element));
              states.push({
                state: state || {name: newState},
                params: newParams
              });
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (anyMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function anyMatch() {
              for (var i = 0; i < states.length; i++) {
                if (isMatch(states[i].state, states[i].params)) {
                  return true;
                }
              }
              return false;
            }
            function isMatch(state, params) {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return $state.is(state.name, params);
              } else {
                return $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-ui/ui-router@0.2.15", ["github:angular-ui/ui-router@0.2.15/angular-ui-router"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/ui-router@0.2.15/angular-ui-router");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-translate/bower-angular-translate@2.7.2/angular-translate", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    (function(root, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], function() {
          return (factory());
        });
      } else if (typeof exports === 'object') {
        module.exports = factory();
      } else {
        factory();
      }
    }(this, function() {
      angular.module('pascalprecht.translate', ['ng']).run(runTranslate);
      function runTranslate($translate) {
        'use strict';
        var key = $translate.storageKey(),
            storage = $translate.storage();
        var fallbackFromIncorrectStorageValue = function() {
          var preferred = $translate.preferredLanguage();
          if (angular.isString(preferred)) {
            $translate.use(preferred);
          } else {
            storage.put(key, $translate.use());
          }
        };
        fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';
        if (storage) {
          if (!storage.get(key)) {
            fallbackFromIncorrectStorageValue();
          } else {
            $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);
          }
        } else if (angular.isString($translate.preferredLanguage())) {
          $translate.use($translate.preferredLanguage());
        }
      }
      runTranslate.$inject = ['$translate'];
      runTranslate.displayName = 'runTranslate';
      angular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);
      function $translateSanitizationProvider() {
        'use strict';
        var $sanitize,
            currentStrategy = null,
            hasConfiguredStrategy = false,
            hasShownNoStrategyConfiguredWarning = false,
            strategies;
        strategies = {
          sanitize: function(value, mode) {
            if (mode === 'text') {
              value = htmlSanitizeValue(value);
            }
            return value;
          },
          escape: function(value, mode) {
            if (mode === 'text') {
              value = htmlEscapeValue(value);
            }
            return value;
          },
          sanitizeParameters: function(value, mode) {
            if (mode === 'params') {
              value = mapInterpolationParameters(value, htmlSanitizeValue);
            }
            return value;
          },
          escapeParameters: function(value, mode) {
            if (mode === 'params') {
              value = mapInterpolationParameters(value, htmlEscapeValue);
            }
            return value;
          }
        };
        strategies.escaped = strategies.escapeParameters;
        this.addStrategy = function(strategyName, strategyFunction) {
          strategies[strategyName] = strategyFunction;
          return this;
        };
        this.removeStrategy = function(strategyName) {
          delete strategies[strategyName];
          return this;
        };
        this.useStrategy = function(strategy) {
          hasConfiguredStrategy = true;
          currentStrategy = strategy;
          return this;
        };
        this.$get = ['$injector', '$log', function($injector, $log) {
          var applyStrategies = function(value, mode, selectedStrategies) {
            angular.forEach(selectedStrategies, function(selectedStrategy) {
              if (angular.isFunction(selectedStrategy)) {
                value = selectedStrategy(value, mode);
              } else if (angular.isFunction(strategies[selectedStrategy])) {
                value = strategies[selectedStrategy](value, mode);
              } else {
                throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \'' + selectedStrategy + '\'');
              }
            });
            return value;
          };
          var showNoStrategyConfiguredWarning = function() {
            if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
              $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');
              hasShownNoStrategyConfiguredWarning = true;
            }
          };
          if ($injector.has('$sanitize')) {
            $sanitize = $injector.get('$sanitize');
          }
          return {
            useStrategy: (function(self) {
              return function(strategy) {
                self.useStrategy(strategy);
              };
            })(this),
            sanitize: function(value, mode, strategy) {
              if (!currentStrategy) {
                showNoStrategyConfiguredWarning();
              }
              if (arguments.length < 3) {
                strategy = currentStrategy;
              }
              if (!strategy) {
                return value;
              }
              var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];
              return applyStrategies(value, mode, selectedStrategies);
            }
          };
        }];
        var htmlEscapeValue = function(value) {
          var element = angular.element('<div></div>');
          element.text(value);
          return element.html();
        };
        var htmlSanitizeValue = function(value) {
          if (!$sanitize) {
            throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \'escape\'.');
          }
          return $sanitize(value);
        };
        var mapInterpolationParameters = function(value, iteratee) {
          if (angular.isObject(value)) {
            var result = angular.isArray(value) ? [] : {};
            angular.forEach(value, function(propertyValue, propertyKey) {
              result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee);
            });
            return result;
          } else if (angular.isNumber(value)) {
            return value;
          } else {
            return iteratee(value);
          }
        };
      }
      angular.module('pascalprecht.translate').constant('pascalprechtTranslateOverrider', {}).provider('$translate', $translate);
      function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
        'use strict';
        var $translationTable = {},
            $preferredLanguage,
            $availableLanguageKeys = [],
            $languageKeyAliases,
            $fallbackLanguage,
            $fallbackWasString,
            $uses,
            $nextLang,
            $storageFactory,
            $storageKey = $STORAGE_KEY,
            $storagePrefix,
            $missingTranslationHandlerFactory,
            $interpolationFactory,
            $interpolatorFactories = [],
            $loaderFactory,
            $cloakClassName = 'translate-cloak',
            $loaderOptions,
            $notFoundIndicatorLeft,
            $notFoundIndicatorRight,
            $postCompilingEnabled = false,
            $forceAsyncReloadEnabled = false,
            NESTED_OBJECT_DELIMITER = '.',
            loaderCache,
            directivePriority = 0,
            statefulFilter = true,
            uniformLanguageTagResolver = 'default',
            languageTagResolver = {
              'default': function(tag) {
                return (tag || '').split('-').join('_');
              },
              java: function(tag) {
                var temp = (tag || '').split('-').join('_');
                var parts = temp.split('_');
                return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;
              },
              bcp47: function(tag) {
                var temp = (tag || '').split('_').join('-');
                var parts = temp.split('-');
                return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;
              }
            };
        var version = '2.7.2';
        var getFirstBrowserLanguage = function() {
          if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
            return pascalprechtTranslateOverrider.getLocale();
          }
          var nav = $windowProvider.$get().navigator,
              browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],
              i,
              language;
          if (angular.isArray(nav.languages)) {
            for (i = 0; i < nav.languages.length; i++) {
              language = nav.languages[i];
              if (language && language.length) {
                return language;
              }
            }
          }
          for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
            language = nav[browserLanguagePropertyKeys[i]];
            if (language && language.length) {
              return language;
            }
          }
          return null;
        };
        getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';
        var getLocale = function() {
          var locale = getFirstBrowserLanguage() || '';
          if (languageTagResolver[uniformLanguageTagResolver]) {
            locale = languageTagResolver[uniformLanguageTagResolver](locale);
          }
          return locale;
        };
        getLocale.displayName = 'angular-translate/service: getLocale';
        var indexOf = function(array, searchElement) {
          for (var i = 0,
              len = array.length; i < len; i++) {
            if (array[i] === searchElement) {
              return i;
            }
          }
          return -1;
        };
        var trim = function() {
          return this.toString().replace(/^\s+|\s+$/g, '');
        };
        var negotiateLocale = function(preferred) {
          var avail = [],
              locale = angular.lowercase(preferred),
              i = 0,
              n = $availableLanguageKeys.length;
          for (; i < n; i++) {
            avail.push(angular.lowercase($availableLanguageKeys[i]));
          }
          if (indexOf(avail, locale) > -1) {
            return preferred;
          }
          if ($languageKeyAliases) {
            var alias;
            for (var langKeyAlias in $languageKeyAliases) {
              var hasWildcardKey = false;
              var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && angular.lowercase(langKeyAlias) === angular.lowercase(preferred);
              if (langKeyAlias.slice(-1) === '*') {
                hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);
              }
              if (hasExactKey || hasWildcardKey) {
                alias = $languageKeyAliases[langKeyAlias];
                if (indexOf(avail, angular.lowercase(alias)) > -1) {
                  return alias;
                }
              }
            }
          }
          if (preferred) {
            var parts = preferred.split('_');
            if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {
              return parts[0];
            }
          }
          return preferred;
        };
        var translations = function(langKey, translationTable) {
          if (!langKey && !translationTable) {
            return $translationTable;
          }
          if (langKey && !translationTable) {
            if (angular.isString(langKey)) {
              return $translationTable[langKey];
            }
          } else {
            if (!angular.isObject($translationTable[langKey])) {
              $translationTable[langKey] = {};
            }
            angular.extend($translationTable[langKey], flatObject(translationTable));
          }
          return this;
        };
        this.translations = translations;
        this.cloakClassName = function(name) {
          if (!name) {
            return $cloakClassName;
          }
          $cloakClassName = name;
          return this;
        };
        var flatObject = function(data, path, result, prevKey) {
          var key,
              keyWithPath,
              keyWithShortPath,
              val;
          if (!path) {
            path = [];
          }
          if (!result) {
            result = {};
          }
          for (key in data) {
            if (!Object.prototype.hasOwnProperty.call(data, key)) {
              continue;
            }
            val = data[key];
            if (angular.isObject(val)) {
              flatObject(val, path.concat(key), result, key);
            } else {
              keyWithPath = path.length ? ('' + path.join(NESTED_OBJECT_DELIMITER) + NESTED_OBJECT_DELIMITER + key) : key;
              if (path.length && key === prevKey) {
                keyWithShortPath = '' + path.join(NESTED_OBJECT_DELIMITER);
                result[keyWithShortPath] = '@:' + keyWithPath;
              }
              result[keyWithPath] = val;
            }
          }
          return result;
        };
        flatObject.displayName = 'flatObject';
        this.addInterpolation = function(factory) {
          $interpolatorFactories.push(factory);
          return this;
        };
        this.useMessageFormatInterpolation = function() {
          return this.useInterpolation('$translateMessageFormatInterpolation');
        };
        this.useInterpolation = function(factory) {
          $interpolationFactory = factory;
          return this;
        };
        this.useSanitizeValueStrategy = function(value) {
          $translateSanitizationProvider.useStrategy(value);
          return this;
        };
        this.preferredLanguage = function(langKey) {
          setupPreferredLanguage(langKey);
          return this;
        };
        var setupPreferredLanguage = function(langKey) {
          if (langKey) {
            $preferredLanguage = langKey;
          }
          return $preferredLanguage;
        };
        this.translationNotFoundIndicator = function(indicator) {
          this.translationNotFoundIndicatorLeft(indicator);
          this.translationNotFoundIndicatorRight(indicator);
          return this;
        };
        this.translationNotFoundIndicatorLeft = function(indicator) {
          if (!indicator) {
            return $notFoundIndicatorLeft;
          }
          $notFoundIndicatorLeft = indicator;
          return this;
        };
        this.translationNotFoundIndicatorRight = function(indicator) {
          if (!indicator) {
            return $notFoundIndicatorRight;
          }
          $notFoundIndicatorRight = indicator;
          return this;
        };
        this.fallbackLanguage = function(langKey) {
          fallbackStack(langKey);
          return this;
        };
        var fallbackStack = function(langKey) {
          if (langKey) {
            if (angular.isString(langKey)) {
              $fallbackWasString = true;
              $fallbackLanguage = [langKey];
            } else if (angular.isArray(langKey)) {
              $fallbackWasString = false;
              $fallbackLanguage = langKey;
            }
            if (angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
              $fallbackLanguage.push($preferredLanguage);
            }
            return this;
          } else {
            if ($fallbackWasString) {
              return $fallbackLanguage[0];
            } else {
              return $fallbackLanguage;
            }
          }
        };
        this.use = function(langKey) {
          if (langKey) {
            if (!$translationTable[langKey] && (!$loaderFactory)) {
              throw new Error('$translateProvider couldn\'t find translationTable for langKey: \'' + langKey + '\'');
            }
            $uses = langKey;
            return this;
          }
          return $uses;
        };
        var storageKey = function(key) {
          if (!key) {
            if ($storagePrefix) {
              return $storagePrefix + $storageKey;
            }
            return $storageKey;
          }
          $storageKey = key;
          return this;
        };
        this.storageKey = storageKey;
        this.useUrlLoader = function(url, options) {
          return this.useLoader('$translateUrlLoader', angular.extend({url: url}, options));
        };
        this.useStaticFilesLoader = function(options) {
          return this.useLoader('$translateStaticFilesLoader', options);
        };
        this.useLoader = function(loaderFactory, options) {
          $loaderFactory = loaderFactory;
          $loaderOptions = options || {};
          return this;
        };
        this.useLocalStorage = function() {
          return this.useStorage('$translateLocalStorage');
        };
        this.useCookieStorage = function() {
          return this.useStorage('$translateCookieStorage');
        };
        this.useStorage = function(storageFactory) {
          $storageFactory = storageFactory;
          return this;
        };
        this.storagePrefix = function(prefix) {
          if (!prefix) {
            return prefix;
          }
          $storagePrefix = prefix;
          return this;
        };
        this.useMissingTranslationHandlerLog = function() {
          return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');
        };
        this.useMissingTranslationHandler = function(factory) {
          $missingTranslationHandlerFactory = factory;
          return this;
        };
        this.usePostCompiling = function(value) {
          $postCompilingEnabled = !(!value);
          return this;
        };
        this.forceAsyncReload = function(value) {
          $forceAsyncReloadEnabled = !(!value);
          return this;
        };
        this.uniformLanguageTag = function(options) {
          if (!options) {
            options = {};
          } else if (angular.isString(options)) {
            options = {standard: options};
          }
          uniformLanguageTagResolver = options.standard;
          return this;
        };
        this.determinePreferredLanguage = function(fn) {
          var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();
          if (!$availableLanguageKeys.length) {
            $preferredLanguage = locale;
          } else {
            $preferredLanguage = negotiateLocale(locale);
          }
          return this;
        };
        this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
          if (languageKeys) {
            $availableLanguageKeys = languageKeys;
            if (aliases) {
              $languageKeyAliases = aliases;
            }
            return this;
          }
          return $availableLanguageKeys;
        };
        this.useLoaderCache = function(cache) {
          if (cache === false) {
            loaderCache = undefined;
          } else if (cache === true) {
            loaderCache = true;
          } else if (typeof(cache) === 'undefined') {
            loaderCache = '$translationCache';
          } else if (cache) {
            loaderCache = cache;
          }
          return this;
        };
        this.directivePriority = function(priority) {
          if (priority === undefined) {
            return directivePriority;
          } else {
            directivePriority = priority;
            return this;
          }
        };
        this.statefulFilter = function(state) {
          if (state === undefined) {
            return statefulFilter;
          } else {
            statefulFilter = state;
            return this;
          }
        };
        this.$get = ['$log', '$injector', '$rootScope', '$q', function($log, $injector, $rootScope, $q) {
          var Storage,
              defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),
              pendingLoader = false,
              interpolatorHashMap = {},
              langPromises = {},
              fallbackIndex,
              startFallbackIteration;
          var $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
            if (angular.isArray(translationId)) {
              var translateAll = function(translationIds) {
                var results = {};
                var promises = [];
                var translate = function(translationId) {
                  var deferred = $q.defer();
                  var regardless = function(value) {
                    results[translationId] = value;
                    deferred.resolve([translationId, value]);
                  };
                  $translate(translationId, interpolateParams, interpolationId, defaultTranslationText).then(regardless, regardless);
                  return deferred.promise;
                };
                for (var i = 0,
                    c = translationIds.length; i < c; i++) {
                  promises.push(translate(translationIds[i]));
                }
                return $q.all(promises).then(function() {
                  return results;
                });
              };
              return translateAll(translationId);
            }
            var deferred = $q.defer();
            if (translationId) {
              translationId = trim.apply(translationId);
            }
            var promiseToWaitFor = (function() {
              var promise = $preferredLanguage ? langPromises[$preferredLanguage] : langPromises[$uses];
              fallbackIndex = 0;
              if ($storageFactory && !promise) {
                var langKey = Storage.get($storageKey);
                promise = langPromises[langKey];
                if ($fallbackLanguage && $fallbackLanguage.length) {
                  var index = indexOf($fallbackLanguage, langKey);
                  fallbackIndex = (index === 0) ? 1 : 0;
                  if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                    $fallbackLanguage.push($preferredLanguage);
                  }
                }
              }
              return promise;
            }());
            if (!promiseToWaitFor) {
              determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
            } else {
              var promiseResolved = function() {
                determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
              };
              promiseResolved.displayName = 'promiseResolved';
              promiseToWaitFor['finally'](promiseResolved, deferred.reject);
            }
            return deferred.promise;
          };
          var applyNotFoundIndicators = function(translationId) {
            if ($notFoundIndicatorLeft) {
              translationId = [$notFoundIndicatorLeft, translationId].join(' ');
            }
            if ($notFoundIndicatorRight) {
              translationId = [translationId, $notFoundIndicatorRight].join(' ');
            }
            return translationId;
          };
          var useLanguage = function(key) {
            $uses = key;
            $rootScope.$emit('$translateChangeSuccess', {language: key});
            if ($storageFactory) {
              Storage.put($translate.storageKey(), $uses);
            }
            defaultInterpolator.setLocale($uses);
            var eachInterpolator = function(interpolator, id) {
              interpolatorHashMap[id].setLocale($uses);
            };
            eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';
            angular.forEach(interpolatorHashMap, eachInterpolator);
            $rootScope.$emit('$translateChangeEnd', {language: key});
          };
          var loadAsync = function(key) {
            if (!key) {
              throw 'No language key specified for loading.';
            }
            var deferred = $q.defer();
            $rootScope.$emit('$translateLoadingStart', {language: key});
            pendingLoader = true;
            var cache = loaderCache;
            if (typeof(cache) === 'string') {
              cache = $injector.get(cache);
            }
            var loaderOptions = angular.extend({}, $loaderOptions, {
              key: key,
              $http: angular.extend({}, {cache: cache}, $loaderOptions.$http)
            });
            var onLoaderSuccess = function(data) {
              var translationTable = {};
              $rootScope.$emit('$translateLoadingSuccess', {language: key});
              if (angular.isArray(data)) {
                angular.forEach(data, function(table) {
                  angular.extend(translationTable, flatObject(table));
                });
              } else {
                angular.extend(translationTable, flatObject(data));
              }
              pendingLoader = false;
              deferred.resolve({
                key: key,
                table: translationTable
              });
              $rootScope.$emit('$translateLoadingEnd', {language: key});
            };
            onLoaderSuccess.displayName = 'onLoaderSuccess';
            var onLoaderError = function(key) {
              $rootScope.$emit('$translateLoadingError', {language: key});
              deferred.reject(key);
              $rootScope.$emit('$translateLoadingEnd', {language: key});
            };
            onLoaderError.displayName = 'onLoaderError';
            $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError);
            return deferred.promise;
          };
          if ($storageFactory) {
            Storage = $injector.get($storageFactory);
            if (!Storage.get || !Storage.put) {
              throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or put() method!');
            }
          }
          if ($interpolatorFactories.length) {
            var eachInterpolationFactory = function(interpolatorFactory) {
              var interpolator = $injector.get(interpolatorFactory);
              interpolator.setLocale($preferredLanguage || $uses);
              interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
            };
            eachInterpolationFactory.displayName = 'interpolationFactoryAdder';
            angular.forEach($interpolatorFactories, eachInterpolationFactory);
          }
          var getTranslationTable = function(langKey) {
            var deferred = $q.defer();
            if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
              deferred.resolve($translationTable[langKey]);
            } else if (langPromises[langKey]) {
              var onResolve = function(data) {
                translations(data.key, data.table);
                deferred.resolve(data.table);
              };
              onResolve.displayName = 'translationTableResolver';
              langPromises[langKey].then(onResolve, deferred.reject);
            } else {
              deferred.reject();
            }
            return deferred.promise;
          };
          var getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator) {
            var deferred = $q.defer();
            var onResolve = function(translationTable) {
              if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
                Interpolator.setLocale(langKey);
                var translation = translationTable[translationId];
                if (translation.substr(0, 2) === '@:') {
                  getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator).then(deferred.resolve, deferred.reject);
                } else {
                  deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));
                }
                Interpolator.setLocale($uses);
              } else {
                deferred.reject();
              }
            };
            onResolve.displayName = 'fallbackTranslationResolver';
            getTranslationTable(langKey).then(onResolve, deferred.reject);
            return deferred.promise;
          };
          var getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator) {
            var result,
                translationTable = $translationTable[langKey];
            if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
              Interpolator.setLocale(langKey);
              result = Interpolator.interpolate(translationTable[translationId], interpolateParams);
              if (result.substr(0, 2) === '@:') {
                return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);
              }
              Interpolator.setLocale($uses);
            }
            return result;
          };
          var translateByHandler = function(translationId, interpolateParams) {
            if ($missingTranslationHandlerFactory) {
              var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);
              if (resultString !== undefined) {
                return resultString;
              } else {
                return translationId;
              }
            } else {
              return translationId;
            }
          };
          var resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {
            var deferred = $q.defer();
            if (fallbackLanguageIndex < $fallbackLanguage.length) {
              var langKey = $fallbackLanguage[fallbackLanguageIndex];
              getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(deferred.resolve, function() {
                resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);
              });
            } else {
              if (defaultTranslationText) {
                deferred.resolve(defaultTranslationText);
              } else {
                deferred.resolve(translateByHandler(translationId, interpolateParams));
              }
            }
            return deferred.promise;
          };
          var resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {
            var result;
            if (fallbackLanguageIndex < $fallbackLanguage.length) {
              var langKey = $fallbackLanguage[fallbackLanguageIndex];
              result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);
              if (!result) {
                result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
              }
            }
            return result;
          };
          var fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText) {
            return resolveForFallbackLanguage((startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);
          };
          var fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator) {
            return resolveForFallbackLanguageInstant((startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);
          };
          var determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
            var deferred = $q.defer();
            var table = $uses ? $translationTable[$uses] : $translationTable,
                Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;
            if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
              var translation = table[translationId];
              if (translation.substr(0, 2) === '@:') {
                $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
              } else {
                deferred.resolve(Interpolator.interpolate(translation, interpolateParams));
              }
            } else {
              var missingTranslationHandlerTranslation;
              if ($missingTranslationHandlerFactory && !pendingLoader) {
                missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
              }
              if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText).then(function(translation) {
                  deferred.resolve(translation);
                }, function(_translationId) {
                  deferred.reject(applyNotFoundIndicators(_translationId));
                });
              } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                if (defaultTranslationText) {
                  deferred.resolve(defaultTranslationText);
                } else {
                  deferred.resolve(missingTranslationHandlerTranslation);
                }
              } else {
                if (defaultTranslationText) {
                  deferred.resolve(defaultTranslationText);
                } else {
                  deferred.reject(applyNotFoundIndicators(translationId));
                }
              }
            }
            return deferred.promise;
          };
          var determineTranslationInstant = function(translationId, interpolateParams, interpolationId) {
            var result,
                table = $uses ? $translationTable[$uses] : $translationTable,
                Interpolator = defaultInterpolator;
            if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
              Interpolator = interpolatorHashMap[interpolationId];
            }
            if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
              var translation = table[translationId];
              if (translation.substr(0, 2) === '@:') {
                result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId);
              } else {
                result = Interpolator.interpolate(translation, interpolateParams);
              }
            } else {
              var missingTranslationHandlerTranslation;
              if ($missingTranslationHandlerFactory && !pendingLoader) {
                missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
              }
              if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                fallbackIndex = 0;
                result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);
              } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                result = missingTranslationHandlerTranslation;
              } else {
                result = applyNotFoundIndicators(translationId);
              }
            }
            return result;
          };
          var clearNextLangAndPromise = function(key) {
            if ($nextLang === key) {
              $nextLang = undefined;
            }
            langPromises[key] = undefined;
          };
          $translate.preferredLanguage = function(langKey) {
            if (langKey) {
              setupPreferredLanguage(langKey);
            }
            return $preferredLanguage;
          };
          $translate.cloakClassName = function() {
            return $cloakClassName;
          };
          $translate.fallbackLanguage = function(langKey) {
            if (langKey !== undefined && langKey !== null) {
              fallbackStack(langKey);
              if ($loaderFactory) {
                if ($fallbackLanguage && $fallbackLanguage.length) {
                  for (var i = 0,
                      len = $fallbackLanguage.length; i < len; i++) {
                    if (!langPromises[$fallbackLanguage[i]]) {
                      langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                    }
                  }
                }
              }
              $translate.use($translate.use());
            }
            if ($fallbackWasString) {
              return $fallbackLanguage[0];
            } else {
              return $fallbackLanguage;
            }
          };
          $translate.useFallbackLanguage = function(langKey) {
            if (langKey !== undefined && langKey !== null) {
              if (!langKey) {
                startFallbackIteration = 0;
              } else {
                var langKeyPosition = indexOf($fallbackLanguage, langKey);
                if (langKeyPosition > -1) {
                  startFallbackIteration = langKeyPosition;
                }
              }
            }
          };
          $translate.proposedLanguage = function() {
            return $nextLang;
          };
          $translate.storage = function() {
            return Storage;
          };
          $translate.use = function(key) {
            if (!key) {
              return $uses;
            }
            var deferred = $q.defer();
            $rootScope.$emit('$translateChangeStart', {language: key});
            var aliasedKey = negotiateLocale(key);
            if (aliasedKey) {
              key = aliasedKey;
            }
            if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
              $nextLang = key;
              langPromises[key] = loadAsync(key).then(function(translation) {
                translations(translation.key, translation.table);
                deferred.resolve(translation.key);
                useLanguage(translation.key);
                return translation;
              }, function(key) {
                $rootScope.$emit('$translateChangeError', {language: key});
                deferred.reject(key);
                $rootScope.$emit('$translateChangeEnd', {language: key});
                return $q.reject(key);
              });
              langPromises[key]['finally'](function() {
                clearNextLangAndPromise(key);
              });
            } else if ($nextLang === key && langPromises[key]) {
              langPromises[key].then(function(translation) {
                deferred.resolve(translation.key);
                return translation;
              }, function(key) {
                deferred.reject(key);
                return $q.reject(key);
              });
            } else {
              deferred.resolve(key);
              useLanguage(key);
            }
            return deferred.promise;
          };
          $translate.storageKey = function() {
            return storageKey();
          };
          $translate.isPostCompilingEnabled = function() {
            return $postCompilingEnabled;
          };
          $translate.isForceAsyncReloadEnabled = function() {
            return $forceAsyncReloadEnabled;
          };
          $translate.refresh = function(langKey) {
            if (!$loaderFactory) {
              throw new Error('Couldn\'t refresh translation table, no loader registered!');
            }
            var deferred = $q.defer();
            function resolve() {
              deferred.resolve();
              $rootScope.$emit('$translateRefreshEnd', {language: langKey});
            }
            function reject() {
              deferred.reject();
              $rootScope.$emit('$translateRefreshEnd', {language: langKey});
            }
            $rootScope.$emit('$translateRefreshStart', {language: langKey});
            if (!langKey) {
              var tables = [],
                  loadingKeys = {};
              if ($fallbackLanguage && $fallbackLanguage.length) {
                for (var i = 0,
                    len = $fallbackLanguage.length; i < len; i++) {
                  tables.push(loadAsync($fallbackLanguage[i]));
                  loadingKeys[$fallbackLanguage[i]] = true;
                }
              }
              if ($uses && !loadingKeys[$uses]) {
                tables.push(loadAsync($uses));
              }
              var allTranslationsLoaded = function(tableData) {
                $translationTable = {};
                angular.forEach(tableData, function(data) {
                  translations(data.key, data.table);
                });
                if ($uses) {
                  useLanguage($uses);
                }
                resolve();
              };
              allTranslationsLoaded.displayName = 'refreshPostProcessor';
              $q.all(tables).then(allTranslationsLoaded, reject);
            } else if ($translationTable[langKey]) {
              var oneTranslationsLoaded = function(data) {
                translations(data.key, data.table);
                if (langKey === $uses) {
                  useLanguage($uses);
                }
                resolve();
              };
              oneTranslationsLoaded.displayName = 'refreshPostProcessor';
              loadAsync(langKey).then(oneTranslationsLoaded, reject);
            } else {
              reject();
            }
            return deferred.promise;
          };
          $translate.instant = function(translationId, interpolateParams, interpolationId) {
            if (translationId === null || angular.isUndefined(translationId)) {
              return translationId;
            }
            if (angular.isArray(translationId)) {
              var results = {};
              for (var i = 0,
                  c = translationId.length; i < c; i++) {
                results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId);
              }
              return results;
            }
            if (angular.isString(translationId) && translationId.length < 1) {
              return translationId;
            }
            if (translationId) {
              translationId = trim.apply(translationId);
            }
            var result,
                possibleLangKeys = [];
            if ($preferredLanguage) {
              possibleLangKeys.push($preferredLanguage);
            }
            if ($uses) {
              possibleLangKeys.push($uses);
            }
            if ($fallbackLanguage && $fallbackLanguage.length) {
              possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
            }
            for (var j = 0,
                d = possibleLangKeys.length; j < d; j++) {
              var possibleLangKey = possibleLangKeys[j];
              if ($translationTable[possibleLangKey]) {
                if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {
                  result = determineTranslationInstant(translationId, interpolateParams, interpolationId);
                } else if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
                  result = applyNotFoundIndicators(translationId);
                }
              }
              if (typeof result !== 'undefined') {
                break;
              }
            }
            if (!result && result !== '') {
              result = defaultInterpolator.interpolate(translationId, interpolateParams);
              if ($missingTranslationHandlerFactory && !pendingLoader) {
                result = translateByHandler(translationId, interpolateParams);
              }
            }
            return result;
          };
          $translate.versionInfo = function() {
            return version;
          };
          $translate.loaderCache = function() {
            return loaderCache;
          };
          $translate.directivePriority = function() {
            return directivePriority;
          };
          $translate.statefulFilter = function() {
            return statefulFilter;
          };
          if ($loaderFactory) {
            if (angular.equals($translationTable, {})) {
              $translate.use($translate.use());
            }
            if ($fallbackLanguage && $fallbackLanguage.length) {
              var processAsyncResult = function(translation) {
                translations(translation.key, translation.table);
                $rootScope.$emit('$translateChangeEnd', {language: translation.key});
                return translation;
              };
              for (var i = 0,
                  len = $fallbackLanguage.length; i < len; i++) {
                var fallbackLanguageId = $fallbackLanguage[i];
                if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
                  langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
                }
              }
            }
          }
          return $translate;
        }];
      }
      $translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];
      $translate.displayName = 'displayName';
      angular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);
      function $translateDefaultInterpolation($interpolate, $translateSanitization) {
        'use strict';
        var $translateInterpolator = {},
            $locale,
            $identifier = 'default';
        $translateInterpolator.setLocale = function(locale) {
          $locale = locale;
        };
        $translateInterpolator.getInterpolationIdentifier = function() {
          return $identifier;
        };
        $translateInterpolator.useSanitizeValueStrategy = function(value) {
          $translateSanitization.useStrategy(value);
          return this;
        };
        $translateInterpolator.interpolate = function(string, interpolationParams) {
          interpolationParams = interpolationParams || {};
          interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');
          var interpolatedText = $interpolate(string)(interpolationParams);
          interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');
          return interpolatedText;
        };
        return $translateInterpolator;
      }
      $translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];
      $translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';
      angular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');
      angular.module('pascalprecht.translate').directive('translate', translateDirective);
      function translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {
        'use strict';
        var trim = function() {
          return this.toString().replace(/^\s+|\s+$/g, '');
        };
        return {
          restrict: 'AE',
          scope: true,
          priority: $translate.directivePriority(),
          compile: function(tElement, tAttr) {
            var translateValuesExist = (tAttr.translateValues) ? tAttr.translateValues : undefined;
            var translateInterpolation = (tAttr.translateInterpolation) ? tAttr.translateInterpolation : undefined;
            var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);
            var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',
                watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';
            return function linkFn(scope, iElement, iAttr) {
              scope.interpolateParams = {};
              scope.preText = '';
              scope.postText = '';
              var translationIds = {};
              var initInterpolationParams = function(interpolateParams, iAttr, tAttr) {
                if (iAttr.translateValues) {
                  angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
                }
                if (translateValueExist) {
                  for (var attr in tAttr) {
                    if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                      var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
                      interpolateParams[attributeName] = tAttr[attr];
                    }
                  }
                }
              };
              var observeElementTranslation = function(translationId) {
                if (angular.isFunction(observeElementTranslation._unwatchOld)) {
                  observeElementTranslation._unwatchOld();
                  observeElementTranslation._unwatchOld = undefined;
                }
                if (angular.equals(translationId, '') || !angular.isDefined(translationId)) {
                  var interpolateMatches = trim.apply(iElement.text()).match(interpolateRegExp);
                  if (angular.isArray(interpolateMatches)) {
                    scope.preText = interpolateMatches[1];
                    scope.postText = interpolateMatches[3];
                    translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                    var watcherMatches = iElement.text().match(watcherRegExp);
                    if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                      observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                        translationIds.translate = newValue;
                        updateTranslations();
                      });
                    }
                  } else {
                    translationIds.translate = iElement.text().replace(/^\s+|\s+$/g, '');
                  }
                } else {
                  translationIds.translate = translationId;
                }
                updateTranslations();
              };
              var observeAttributeTranslation = function(translateAttr) {
                iAttr.$observe(translateAttr, function(translationId) {
                  translationIds[translateAttr] = translationId;
                  updateTranslations();
                });
              };
              initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
              var firstAttributeChangedEvent = true;
              iAttr.$observe('translate', function(translationId) {
                if (typeof translationId === 'undefined') {
                  observeElementTranslation('');
                } else {
                  if (translationId !== '' || !firstAttributeChangedEvent) {
                    translationIds.translate = translationId;
                    updateTranslations();
                  }
                }
                firstAttributeChangedEvent = false;
              });
              for (var translateAttr in iAttr) {
                if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {
                  observeAttributeTranslation(translateAttr);
                }
              }
              iAttr.$observe('translateDefault', function(value) {
                scope.defaultText = value;
              });
              if (translateValuesExist) {
                iAttr.$observe('translateValues', function(interpolateParams) {
                  if (interpolateParams) {
                    scope.$parent.$watch(function() {
                      angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                    });
                  }
                });
              }
              if (translateValueExist) {
                var observeValueAttribute = function(attrName) {
                  iAttr.$observe(attrName, function(value) {
                    var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                    scope.interpolateParams[attributeName] = value;
                  });
                };
                for (var attr in iAttr) {
                  if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                    observeValueAttribute(attr);
                  }
                }
              }
              var updateTranslations = function() {
                for (var key in translationIds) {
                  if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
                    updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText);
                  }
                }
              };
              var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText) {
                if (translationId) {
                  $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText).then(function(translation) {
                    applyTranslation(translation, scope, true, translateAttr);
                  }, function(translationId) {
                    applyTranslation(translationId, scope, false, translateAttr);
                  });
                } else {
                  applyTranslation(translationId, scope, false, translateAttr);
                }
              };
              var applyTranslation = function(value, scope, successful, translateAttr) {
                if (translateAttr === 'translate') {
                  if (!successful && typeof scope.defaultText !== 'undefined') {
                    value = scope.defaultText;
                  }
                  iElement.html(scope.preText + value + scope.postText);
                  var globallyEnabled = $translate.isPostCompilingEnabled();
                  var locallyDefined = typeof tAttr.translateCompile !== 'undefined';
                  var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';
                  if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
                    $compile(iElement.contents())(scope);
                  }
                } else {
                  if (!successful && typeof scope.defaultText !== 'undefined') {
                    value = scope.defaultText;
                  }
                  var attributeName = iAttr.$attr[translateAttr];
                  if (attributeName.substr(0, 5) === 'data-') {
                    attributeName = attributeName.substr(5);
                  }
                  attributeName = attributeName.substr(15);
                  iElement.attr(attributeName, value);
                }
              };
              if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
                scope.$watch('interpolateParams', updateTranslations, true);
              }
              var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);
              if (iElement.text().length) {
                if (iAttr.translate) {
                  observeElementTranslation(iAttr.translate);
                } else {
                  observeElementTranslation('');
                }
              } else if (iAttr.translate) {
                observeElementTranslation(iAttr.translate);
              }
              updateTranslations();
              scope.$on('$destroy', unbind);
            };
          }
        };
      }
      translateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];
      translateDirective.displayName = 'translateDirective';
      angular.module('pascalprecht.translate').directive('translateCloak', translateCloakDirective);
      function translateCloakDirective($rootScope, $translate) {
        'use strict';
        return {compile: function(tElement) {
            var applyCloak = function() {
              tElement.addClass($translate.cloakClassName());
            },
                removeCloak = function() {
                  tElement.removeClass($translate.cloakClassName());
                },
                removeListener = $rootScope.$on('$translateChangeEnd', function() {
                  removeCloak();
                  removeListener();
                  removeListener = null;
                });
            applyCloak();
            return function linkFn(scope, iElement, iAttr) {
              if (iAttr.translateCloak && iAttr.translateCloak.length) {
                iAttr.$observe('translateCloak', function(translationId) {
                  $translate(translationId).then(removeCloak, applyCloak);
                });
              }
            };
          }};
      }
      translateCloakDirective.$inject = ['$rootScope', '$translate'];
      translateCloakDirective.displayName = 'translateCloakDirective';
      angular.module('pascalprecht.translate').filter('translate', translateFilterFactory);
      function translateFilterFactory($parse, $translate) {
        'use strict';
        var translateFilter = function(translationId, interpolateParams, interpolation) {
          if (!angular.isObject(interpolateParams)) {
            interpolateParams = $parse(interpolateParams)(this);
          }
          return $translate.instant(translationId, interpolateParams, interpolation);
        };
        if ($translate.statefulFilter()) {
          translateFilter.$stateful = true;
        }
        return translateFilter;
      }
      translateFilterFactory.$inject = ['$parse', '$translate'];
      translateFilterFactory.displayName = 'translateFilterFactory';
      angular.module('pascalprecht.translate').factory('$translationCache', $translationCache);
      function $translationCache($cacheFactory) {
        'use strict';
        return $cacheFactory('translations');
      }
      $translationCache.$inject = ['$cacheFactory'];
      $translationCache.displayName = '$translationCache';
      return 'pascalprecht.translate';
    }));
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-translate/bower-angular-translate@2.7.2", ["github:angular-translate/bower-angular-translate@2.7.2/angular-translate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-translate/bower-angular-translate@2.7.2/angular-translate");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-translate/bower-angular-translate-storage-local@2.7.2/angular-translate-storage-local", ["github:angular/bower-angular@1.4.4", "github:angular-translate/bower-angular-translate@2.7.2"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4", "github:angular-translate/bower-angular-translate@2.7.2"]);
  (function() {
    "format global";
    "deps angular";
    "deps angular-translate";
    (function(root, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], function() {
          return (factory());
        });
      } else if (typeof exports === 'object') {
        module.exports = factory();
      } else {
        factory();
      }
    }(this, function() {
      angular.module('pascalprecht.translate').factory('$translateLocalStorage', $translateLocalStorageFactory);
      function $translateLocalStorageFactory($window, $translateCookieStorage) {
        'use strict';
        var localStorageAdapter = (function() {
          var langKey;
          return {
            get: function(name) {
              if (!langKey) {
                langKey = $window.localStorage.getItem(name);
              }
              return langKey;
            },
            set: function(name, value) {
              langKey = value;
              $window.localStorage.setItem(name, value);
            },
            put: function(name, value) {
              langKey = value;
              $window.localStorage.setItem(name, value);
            }
          };
        }());
        var hasLocalStorageSupport = 'localStorage' in $window;
        if (hasLocalStorageSupport) {
          var testKey = 'pascalprecht.translate.storageTest';
          try {
            if ($window.localStorage !== null) {
              $window.localStorage.setItem(testKey, 'foo');
              $window.localStorage.removeItem(testKey);
              hasLocalStorageSupport = true;
            } else {
              hasLocalStorageSupport = false;
            }
          } catch (e) {
            hasLocalStorageSupport = false;
          }
        }
        var $translateLocalStorage = hasLocalStorageSupport ? localStorageAdapter : $translateCookieStorage;
        return $translateLocalStorage;
      }
      $translateLocalStorageFactory.$inject = ['$window', '$translateCookieStorage'];
      $translateLocalStorageFactory.displayName = '$translateLocalStorageFactory';
      return 'pascalprecht.translate';
    }));
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-translate/bower-angular-translate-storage-local@2.7.2", ["github:angular-translate/bower-angular-translate-storage-local@2.7.2/angular-translate-storage-local"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-translate/bower-angular-translate-storage-local@2.7.2/angular-translate-storage-local");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-translate/bower-angular-translate-storage-cookie@2.7.2/angular-translate-storage-cookie", ["github:angular/bower-angular@1.4.4", "github:angular-translate/bower-angular-translate@2.7.2"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4", "github:angular-translate/bower-angular-translate@2.7.2"]);
  (function() {
    "format global";
    "deps angular";
    "deps angular-translate";
    (function(root, factory) {
      if (typeof define === 'function' && define.amd) {
        define([], function() {
          return (factory());
        });
      } else if (typeof exports === 'object') {
        module.exports = factory();
      } else {
        factory();
      }
    }(this, function() {
      angular.module('pascalprecht.translate').factory('$translateCookieStorage', $translateCookieStorageFactory);
      function $translateCookieStorageFactory($cookieStore) {
        'use strict';
        var $translateCookieStorage = {
          get: function(name) {
            return $cookieStore.get(name);
          },
          set: function(name, value) {
            $cookieStore.put(name, value);
          },
          put: function(name, value) {
            $cookieStore.put(name, value);
          }
        };
        return $translateCookieStorage;
      }
      $translateCookieStorageFactory.$inject = ['$cookieStore'];
      $translateCookieStorageFactory.displayName = '$translateCookieStorage';
      return 'pascalprecht.translate';
    }));
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-translate/bower-angular-translate-storage-cookie@2.7.2", ["github:angular-translate/bower-angular-translate-storage-cookie@2.7.2/angular-translate-storage-cookie"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-translate/bower-angular-translate-storage-cookie@2.7.2/angular-translate-storage-cookie");
  global.define = __define;
  return module.exports;
});

System.register("github:angular/bower-angular-sanitize@1.4.4/angular-sanitize", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
          END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
          ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
          BEGIN_TAG_REGEXP = /^</,
          BEGING_END_TAGE_REGEXP = /^<\//,
          COMMENT_REGEXP = /<!--(.*?)-->/g,
          DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
          CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
          SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
      var voidElements = makeMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = makeMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
      var specialElements = makeMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
      var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
      var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      function htmlParser(html, handler) {
        if (typeof html !== 'string') {
          if (html === null || typeof html === 'undefined') {
            html = '';
          } else {
            html = '' + html;
          }
        }
        var index,
            chars,
            match,
            stack = [],
            last = html,
            text;
        stack.last = function() {
          return stack[stack.length - 1];
        };
        while (html) {
          text = '';
          chars = true;
          if (!stack.last() || !specialElements[stack.last()]) {
            if (html.indexOf("<!--") === 0) {
              index = html.indexOf("--", 4);
              if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                if (handler.comment)
                  handler.comment(html.substring(4, index));
                html = html.substring(index + 3);
                chars = false;
              }
            } else if (DOCTYPE_REGEXP.test(html)) {
              match = html.match(DOCTYPE_REGEXP);
              if (match) {
                html = html.replace(match[0], '');
                chars = false;
              }
            } else if (BEGING_END_TAGE_REGEXP.test(html)) {
              match = html.match(END_TAG_REGEXP);
              if (match) {
                html = html.substring(match[0].length);
                match[0].replace(END_TAG_REGEXP, parseEndTag);
                chars = false;
              }
            } else if (BEGIN_TAG_REGEXP.test(html)) {
              match = html.match(START_TAG_REGEXP);
              if (match) {
                if (match[4]) {
                  html = html.substring(match[0].length);
                  match[0].replace(START_TAG_REGEXP, parseStartTag);
                }
                chars = false;
              } else {
                text += '<';
                html = html.substring(1);
              }
            }
            if (chars) {
              index = html.indexOf("<");
              text += index < 0 ? html : html.substring(0, index);
              html = index < 0 ? "" : html.substring(index);
              if (handler.chars)
                handler.chars(decodeEntities(text));
            }
          } else {
            html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
              text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
              if (handler.chars)
                handler.chars(decodeEntities(text));
              return "";
            });
            parseEndTag("", stack.last());
          }
          if (html == last) {
            throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
          }
          last = html;
        }
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
          tagName = angular.lowercase(tagName);
          if (blockElements[tagName]) {
            while (stack.last() && inlineElements[stack.last()]) {
              parseEndTag("", stack.last());
            }
          }
          if (optionalEndTagElements[tagName] && stack.last() == tagName) {
            parseEndTag("", tagName);
          }
          unary = voidElements[tagName] || !!unary;
          if (!unary) {
            stack.push(tagName);
          }
          var attrs = {};
          rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
            var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
            attrs[name] = decodeEntities(value);
          });
          if (handler.start)
            handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
          var pos = 0,
              i;
          tagName = angular.lowercase(tagName);
          if (tagName) {
            for (pos = stack.length - 1; pos >= 0; pos--) {
              if (stack[pos] == tagName)
                break;
            }
          }
          if (pos >= 0) {
            for (i = stack.length - 1; i >= pos; i--)
              if (handler.end)
                handler.end(stack[i]);
            stack.length = pos;
          }
        }
      }
      var hiddenPre = document.createElement("pre");
      function decodeEntities(value) {
        if (!value) {
          return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs, unary) {
            tag = angular.lowercase(tag);
            if (!ignore && specialElements[tag]) {
              ignore = tag;
            }
            if (!ignore && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out(unary ? '/>' : '>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignore && validElements[tag] === true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignore) {
              ignore = false;
            }
          },
          chars: function(chars) {
            if (!ignore) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        return function(text, target) {
          if (!text)
            return text;
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return ;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            html.push('<a ');
            if (angular.isDefined(target)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular/bower-angular-sanitize@1.4.4", ["github:angular/bower-angular-sanitize@1.4.4/angular-sanitize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-sanitize@1.4.4/angular-sanitize");
  global.define = __define;
  return module.exports;
});

System.register("github:angular-ui/bootstrap-bower@0.13.1/ui-bootstrap-tpls", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {
    angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.transition", "ui.bootstrap.typeahead"]);
    angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-popup.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/tooltip/tooltip-template-popup.html", "template/popover/popover-template.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]);
    angular.module('ui.bootstrap.collapse', []).directive('collapse', ['$animate', function($animate) {
      return {link: function(scope, element, attrs) {
          function expand() {
            element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
            $animate.addClass(element, 'in', {to: {height: element[0].scrollHeight + 'px'}}).then(expandDone);
          }
          function expandDone() {
            element.removeClass('collapsing');
            element.css({height: 'auto'});
          }
          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }
            element.css({height: element[0].scrollHeight + 'px'}).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
            $animate.removeClass(element, 'in', {to: {height: '0'}}).then(collapseDone);
          }
          function collapseDone() {
            element.css({height: '0'});
            element.removeClass('collapsing');
            element.addClass('collapse');
          }
          scope.$watch(attrs.collapse, function(shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('accordionConfig', {closeOthers: true}).controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function(group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on('$destroy', function(event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }]).directive('accordion', function() {
      return {
        restrict: 'EA',
        controller: 'AccordionController',
        transclude: true,
        replace: false,
        templateUrl: 'template/accordion/accordion.html'
      };
    }).directive('accordionGroup', function() {
      return {
        require: '^accordion',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: 'template/accordion/accordion-group.html',
        scope: {
          heading: '@',
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          accordionCtrl.addGroup(scope);
          scope.$watch('isOpen', function(value) {
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });
          scope.toggleOpen = function() {
            if (!scope.isDisabled) {
              scope.isOpen = !scope.isOpen;
            }
          };
        }
      };
    }).directive('accordionHeading', function() {
      return {
        restrict: 'EA',
        transclude: true,
        template: '',
        replace: true,
        require: '^accordionGroup',
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    }).directive('accordionTransclude', function() {
      return {
        require: '^accordionGroup',
        link: function(scope, element, attr, controller) {
          scope.$watch(function() {
            return controller[attr.accordionTransclude];
          }, function(heading) {
            if (heading) {
              element.html('');
              element.append(heading);
            }
          });
        }
      };
    });
    ;
    angular.module('ui.bootstrap.alert', []).controller('AlertController', ['$scope', '$attrs', function($scope, $attrs) {
      $scope.closeable = !!$attrs.close;
      this.close = $scope.close;
    }]).directive('alert', function() {
      return {
        restrict: 'EA',
        controller: 'AlertController',
        templateUrl: 'template/alert/alert.html',
        transclude: true,
        replace: true,
        scope: {
          type: '@',
          close: '&'
        }
      };
    }).directive('dismissOnTimeout', ['$timeout', function($timeout) {
      return {
        require: 'alert',
        link: function(scope, element, attrs, alertCtrl) {
          $timeout(function() {
            alertCtrl.close();
          }, parseInt(attrs.dismissOnTimeout, 10));
        }
      };
    }]);
    angular.module('ui.bootstrap.bindHtml', []).value('$bindHtmlUnsafeSuppressDeprecated', false).directive('bindHtmlUnsafe', ['$log', '$bindHtmlUnsafeSuppressDeprecated', function($log, $bindHtmlUnsafeSuppressDeprecated) {
      return function(scope, element, attr) {
        if (!$bindHtmlUnsafeSuppressDeprecated) {
          $log.warn('bindHtmlUnsafe is now deprecated. Use ngBindHtml instead');
        }
        element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
          element.html(value || '');
        });
      };
    }]);
    angular.module('ui.bootstrap.buttons', []).constant('buttonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
      this.activeClass = buttonConfig.activeClass || 'active';
      this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }]).directive('btnRadio', function() {
      return {
        require: ['btnRadio', 'ngModel'],
        controller: 'ButtonsController',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
                ngModelCtrl.$render();
              });
            }
          });
        }
      };
    }).directive('btnCheckbox', function() {
      return {
        require: ['btnCheckbox', 'ngModel'],
        controller: 'ButtonsController',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attributeValue, defaultValue) {
            var val = scope.$eval(attributeValue);
            return angular.isDefined(val) ? val : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });
    angular.module('ui.bootstrap.carousel', []).controller('CarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {
      var self = this,
          slides = self.slides = $scope.slides = [],
          NO_TRANSITION = 'uib-noTransition',
          SLIDE_DIRECTION = 'uib-slideDirection',
          currentIndex = -1,
          currentInterval,
          isPlaying;
      self.currentSlide = null;
      var destroyed = false;
      self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = self.indexOfSlide(nextSlide);
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
          goNext(nextSlide, nextIndex, direction);
        }
      };
      function goNext(slide, index, direction) {
        if (destroyed) {
          return ;
        }
        angular.extend(slide, {
          direction: direction,
          active: true
        });
        angular.extend(self.currentSlide || {}, {
          direction: direction,
          active: false
        });
        if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition && slide.$element) {
          slide.$element.data(SLIDE_DIRECTION, slide.direction);
          $scope.$currentTransition = true;
          slide.$element.one('$animate:close', function closeFn() {
            $scope.$currentTransition = null;
          });
        }
        self.currentSlide = slide;
        currentIndex = index;
        restartTimer();
      }
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
      function getSlideByIndex(index) {
        if (angular.isUndefined(slides[index].index)) {
          return slides[index];
        }
        var i,
            len = slides.length;
        for (i = 0; i < slides.length; ++i) {
          if (slides[i].index == index) {
            return slides[i];
          }
        }
      }
      self.getCurrentIndex = function() {
        if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
          return +self.currentSlide.index;
        }
        return currentIndex;
      };
      self.indexOfSlide = function(slide) {
        return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
      };
      $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return ;
        }
        return self.select(getSlideByIndex(newIndex), 'next');
      };
      $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return ;
        }
        return self.select(getSlideByIndex(newIndex), 'prev');
      };
      $scope.isActive = function(slide) {
        return self.currentSlide === slide;
      };
      $scope.$watch('interval', restartTimer);
      $scope.$on('$destroy', resetTimer);
      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }
      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }
      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
      $scope.play = function() {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };
      $scope.pause = function() {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };
      self.addSlide = function(slide, element) {
        slide.$element = element;
        slides.push(slide);
        if (slides.length === 1 || slide.active) {
          self.select(slides[slides.length - 1]);
          if (slides.length == 1) {
            $scope.play();
          }
        } else {
          slide.active = false;
        }
      };
      self.removeSlide = function(slide) {
        if (angular.isDefined(slide.index)) {
          slides.sort(function(a, b) {
            return +a.index > +b.index;
          });
        }
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        if (slides.length > 0 && slide.active) {
          if (index >= slides.length) {
            self.select(slides[index - 1]);
          } else {
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
        }
      };
      $scope.$watch('noTransition', function(noTransition) {
        $element.data(NO_TRANSITION, noTransition);
      });
    }]).directive('carousel', [function() {
      return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        controller: 'CarouselController',
        require: 'carousel',
        templateUrl: 'template/carousel/carousel.html',
        scope: {
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        }
      };
    }]).directive('slide', function() {
      return {
        require: '^carousel',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: 'template/carousel/slide.html',
        scope: {
          active: '=?',
          index: '=?'
        },
        link: function(scope, element, attrs, carouselCtrl) {
          carouselCtrl.addSlide(scope, element);
          scope.$on('$destroy', function() {
            carouselCtrl.removeSlide(scope);
          });
          scope.$watch('active', function(active) {
            if (active) {
              carouselCtrl.select(scope);
            }
          });
        }
      };
    }).animation('.item', ['$animate', function($animate) {
      var NO_TRANSITION = 'uib-noTransition',
          SLIDE_DIRECTION = 'uib-slideDirection';
      return {
        beforeAddClass: function(element, className, done) {
          if (className == 'active' && element.parent() && !element.parent().data(NO_TRANSITION)) {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction == 'next' ? 'left' : 'right';
            element.addClass(direction);
            $animate.addClass(element, directionClass).then(function() {
              if (!stopped) {
                element.removeClass(directionClass + ' ' + direction);
              }
              done();
            });
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className == 'active' && element.parent() && !element.parent().data(NO_TRANSITION)) {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction == 'next' ? 'left' : 'right';
            $animate.addClass(element, directionClass).then(function() {
              if (!stopped) {
                element.removeClass(directionClass);
              }
              done();
            });
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }]);
    ;
    angular.module('ui.bootstrap.dateparser', []).service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {
      var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      this.parsers = {};
      var formatCodeToRegex = {
        'yyyy': {
          regex: '\\d{4}',
          apply: function(value) {
            this.year = +value;
          }
        },
        'yy': {
          regex: '\\d{2}',
          apply: function(value) {
            this.year = +value + 2000;
          }
        },
        'y': {
          regex: '\\d{1,4}',
          apply: function(value) {
            this.year = +value;
          }
        },
        'MMMM': {
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          }
        },
        'MMM': {
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          }
        },
        'MM': {
          regex: '0[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          }
        },
        'M': {
          regex: '[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          }
        },
        'dd': {
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          }
        },
        'd': {
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          }
        },
        'EEEE': {regex: $locale.DATETIME_FORMATS.DAY.join('|')},
        'EEE': {regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')},
        'HH': {
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          }
        },
        'H': {
          regex: '1?[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          }
        },
        'mm': {
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          }
        },
        'm': {
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          }
        },
        'sss': {
          regex: '[0-9][0-9][0-9]',
          apply: function(value) {
            this.milliseconds = +value;
          }
        },
        'ss': {
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          }
        },
        's': {
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          }
        }
      };
      function createParser(format) {
        var map = [],
            regex = format.split('');
        angular.forEach(formatCodeToRegex, function(data, code) {
          var index = format.indexOf(code);
          if (index > -1) {
            format = format.split('');
            regex[index] = '(' + data.regex + ')';
            format[index] = '$';
            for (var i = index + 1,
                n = index + code.length; i < n; i++) {
              regex[i] = '';
              format[i] = '$';
            }
            format = format.join('');
            map.push({
              index: index,
              apply: data.apply
            });
          }
        });
        return {
          regex: new RegExp('^' + regex.join('') + '$'),
          map: orderByFilter(map, 'index')
        };
      }
      this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) {
          return input;
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
        if (!this.parsers[format]) {
          this.parsers[format] = createParser(format);
        }
        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex);
        if (results && results.length) {
          var fields,
              dt;
          if (baseDate) {
            fields = {
              year: baseDate.getFullYear(),
              month: baseDate.getMonth(),
              date: baseDate.getDate(),
              hours: baseDate.getHours(),
              minutes: baseDate.getMinutes(),
              seconds: baseDate.getSeconds(),
              milliseconds: baseDate.getMilliseconds()
            };
          } else {
            fields = {
              year: 1900,
              month: 0,
              date: 1,
              hours: 0,
              minutes: 0,
              seconds: 0,
              milliseconds: 0
            };
          }
          for (var i = 1,
              n = results.length; i < n; i++) {
            var mapper = map[i - 1];
            if (mapper.apply) {
              mapper.apply.call(fields, results[i]);
            }
          }
          if (isValid(fields.year, fields.month, fields.date)) {
            dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0);
          }
          return dt;
        }
      };
      function isValid(year, month, date) {
        if (date < 1) {
          return false;
        }
        if (month === 1 && date > 28) {
          return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
          return date < 31;
        }
        return true;
      }
    }]);
    angular.module('ui.bootstrap.position', []).factory('$position', ['$document', '$window', function($document, $window) {
      function getStyle(el, cssprop) {
        if (el.currentStyle) {
          return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
          return $window.getComputedStyle(el)[cssprop];
        }
        return el.style[cssprop];
      }
      function isStaticPositioned(element) {
        return (getStyle(element, 'position') || 'static') === 'static';
      }
      var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
      };
      return {
        position: function(element) {
          var elBCR = this.offset(element);
          var offsetParentBCR = {
            top: 0,
            left: 0
          };
          var offsetParentEl = parentOffsetEl(element[0]);
          if (offsetParentEl != $document[0]) {
            offsetParentBCR = this.offset(angular.element(offsetParentEl));
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
          }
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
          };
        },
        offset: function(element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
          var positionStrParts = positionStr.split('-');
          var pos0 = positionStrParts[0],
              pos1 = positionStrParts[1] || 'center';
          var hostElPos,
              targetElWidth,
              targetElHeight,
              targetElPos;
          hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
          targetElWidth = targetEl.prop('offsetWidth');
          targetElHeight = targetEl.prop('offsetHeight');
          var shiftWidth = {
            center: function() {
              return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
            },
            left: function() {
              return hostElPos.left;
            },
            right: function() {
              return hostElPos.left + hostElPos.width;
            }
          };
          var shiftHeight = {
            center: function() {
              return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
            },
            top: function() {
              return hostElPos.top;
            },
            bottom: function() {
              return hostElPos.top + hostElPos.height;
            }
          };
          switch (pos0) {
            case 'right':
              targetElPos = {
                top: shiftHeight[pos1](),
                left: shiftWidth[pos0]()
              };
              break;
            case 'left':
              targetElPos = {
                top: shiftHeight[pos1](),
                left: hostElPos.left - targetElWidth
              };
              break;
            case 'bottom':
              targetElPos = {
                top: shiftHeight[pos0](),
                left: shiftWidth[pos1]()
              };
              break;
            default:
              targetElPos = {
                top: hostElPos.top - targetElHeight,
                left: shiftWidth[pos1]()
              };
              break;
          }
          return targetElPos;
        }
      };
    }]);
    angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position']).constant('datepickerConfig', {
      formatDay: 'dd',
      formatMonth: 'MMMM',
      formatYear: 'yyyy',
      formatDayHeader: 'EEE',
      formatDayTitle: 'MMMM yyyy',
      formatMonthTitle: 'yyyy',
      datepickerMode: 'day',
      minMode: 'day',
      maxMode: 'year',
      showWeeks: true,
      startingDay: 0,
      yearRange: 20,
      minDate: null,
      maxDate: null,
      shortcutPropagation: false
    }).controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop};
      this.modes = ['day', 'month', 'year'];
      angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
      });
      angular.forEach(['minDate', 'maxDate'], function(key) {
        if ($attrs[key]) {
          $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null;
            self.refreshView();
          });
        } else {
          self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
        }
      });
      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.maxMode = self.maxMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      if (angular.isDefined($attrs.initDate)) {
        this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
        $scope.$parent.$watch($attrs.initDate, function(initDate) {
          if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
            self.activeDate = initDate;
            self.refreshView();
          }
        });
      } else {
        this.activeDate = new Date();
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = date;
          } else {
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          }
          ngModelCtrl.$setValidity('date', isValid);
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          this._refreshView();
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
          date: date,
          label: dateFilter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          current: this.compare(date, new Date()) === 0,
          customClass: this.customClass(date)
        };
      };
      this.isDisabled = function(date) {
        return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({
          date: date,
          mode: $scope.datepickerMode
        })));
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      this.fixTimeZone = function(date) {
        var hours = date.getHours();
        date.setHours(hours === 23 ? hours + 2 : 0);
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
          return ;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey) {
          return ;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return ;
          }
          $scope.select(self.activeDate);
          focusElement();
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
          focusElement();
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
    }]).directive('datepicker', function() {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/datepicker/datepicker.html',
        scope: {
          datepickerMode: '=?',
          dateDisabled: '&',
          customClass: '&',
          shortcutPropagation: '&?'
        },
        require: ['datepicker', '?^ngModel'],
        controller: 'DatepickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            datepickerCtrl.init(ngModelCtrl);
          }
        }
      };
    }).directive('daypicker', ['dateFilter', function(dateFilter) {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/datepicker/day.html',
        require: '^datepicker',
        link: function(scope, element, attrs, ctrl) {
          scope.showWeeks = ctrl.showWeeks;
          ctrl.step = {months: 1};
          ctrl.element = element;
          var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function getDaysInMonth(year, month) {
            return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
          }
          function getDates(startDate, n) {
            var dates = new Array(n),
                current = new Date(startDate),
                i = 0,
                date;
            while (i < n) {
              date = new Date(current);
              ctrl.fixTimeZone(date);
              dates[i++] = date;
              current.setDate(current.getDate() + 1);
            }
            return dates;
          }
          ctrl._refreshView = function() {
            var year = ctrl.activeDate.getFullYear(),
                month = ctrl.activeDate.getMonth(),
                firstDayOfMonth = new Date(year, month, 1),
                difference = ctrl.startingDay - firstDayOfMonth.getDay(),
                numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : -difference,
                firstDate = new Date(firstDayOfMonth);
            if (numDisplayedFromPreviousMonth > 0) {
              firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
            }
            var days = getDates(firstDate, 42);
            for (var i = 0; i < 42; i++) {
              days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                secondary: days[i].getMonth() !== month,
                uid: scope.uniqueId + '-' + i
              });
            }
            scope.labels = new Array(7);
            for (var j = 0; j < 7; j++) {
              scope.labels[j] = {
                abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                full: dateFilter(days[j].date, 'EEEE')
              };
            }
            scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
            scope.rows = ctrl.split(days, 7);
            if (scope.showWeeks) {
              scope.weekNumbers = [];
              var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
                  numWeeks = scope.rows.length;
              for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
              }
            }
          };
          ctrl.compare = function(date1, date2) {
            return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
          };
          function getISO8601WeekNumber(date) {
            var checkDate = new Date(date);
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            var time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
          }
          ctrl.handleKeyDown = function(key, evt) {
            var date = ctrl.activeDate.getDate();
            if (key === 'left') {
              date = date - 1;
            } else if (key === 'up') {
              date = date - 7;
            } else if (key === 'right') {
              date = date + 1;
            } else if (key === 'down') {
              date = date + 7;
            } else if (key === 'pageup' || key === 'pagedown') {
              var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
              ctrl.activeDate.setMonth(month, 1);
              date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
            } else if (key === 'home') {
              date = 1;
            } else if (key === 'end') {
              date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
            }
            ctrl.activeDate.setDate(date);
          };
          ctrl.refreshView();
        }
      };
    }]).directive('monthpicker', ['dateFilter', function(dateFilter) {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/datepicker/month.html',
        require: '^datepicker',
        link: function(scope, element, attrs, ctrl) {
          ctrl.step = {years: 1};
          ctrl.element = element;
          ctrl._refreshView = function() {
            var months = new Array(12),
                year = ctrl.activeDate.getFullYear(),
                date;
            for (var i = 0; i < 12; i++) {
              date = new Date(year, i, 1);
              ctrl.fixTimeZone(date);
              months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {uid: scope.uniqueId + '-' + i});
            }
            scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
            scope.rows = ctrl.split(months, 3);
          };
          ctrl.compare = function(date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
          };
          ctrl.handleKeyDown = function(key, evt) {
            var date = ctrl.activeDate.getMonth();
            if (key === 'left') {
              date = date - 1;
            } else if (key === 'up') {
              date = date - 3;
            } else if (key === 'right') {
              date = date + 1;
            } else if (key === 'down') {
              date = date + 3;
            } else if (key === 'pageup' || key === 'pagedown') {
              var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
              ctrl.activeDate.setFullYear(year);
            } else if (key === 'home') {
              date = 0;
            } else if (key === 'end') {
              date = 11;
            }
            ctrl.activeDate.setMonth(date);
          };
          ctrl.refreshView();
        }
      };
    }]).directive('yearpicker', ['dateFilter', function(dateFilter) {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/datepicker/year.html',
        require: '^datepicker',
        link: function(scope, element, attrs, ctrl) {
          var range = ctrl.yearRange;
          ctrl.step = {years: range};
          ctrl.element = element;
          function getStartingYear(year) {
            return parseInt((year - 1) / range, 10) * range + 1;
          }
          ctrl._refreshView = function() {
            var years = new Array(range),
                date;
            for (var i = 0,
                start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
              date = new Date(start + i, 0, 1);
              ctrl.fixTimeZone(date);
              years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {uid: scope.uniqueId + '-' + i});
            }
            scope.title = [years[0].label, years[range - 1].label].join(' - ');
            scope.rows = ctrl.split(years, 5);
          };
          ctrl.compare = function(date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
          };
          ctrl.handleKeyDown = function(key, evt) {
            var date = ctrl.activeDate.getFullYear();
            if (key === 'left') {
              date = date - 1;
            } else if (key === 'up') {
              date = date - 5;
            } else if (key === 'right') {
              date = date + 1;
            } else if (key === 'down') {
              date = date + 5;
            } else if (key === 'pageup' || key === 'pagedown') {
              date += (key === 'pageup' ? -1 : 1) * ctrl.step.years;
            } else if (key === 'home') {
              date = getStartingYear(ctrl.activeDate.getFullYear());
            } else if (key === 'end') {
              date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
            }
            ctrl.activeDate.setFullYear(date);
          };
          ctrl.refreshView();
        }
      };
    }]).constant('datepickerPopupConfig', {
      datepickerPopup: 'yyyy-MM-dd',
      html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
      },
      currentText: 'Today',
      clearText: 'Clear',
      closeText: 'Done',
      closeOnDateSelection: true,
      appendToBody: false,
      showButtonBar: true
    }).directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig', '$timeout', function($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
      return {
        restrict: 'EA',
        require: 'ngModel',
        scope: {
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@',
          dateDisabled: '&',
          customClass: '&'
        },
        link: function(scope, element, attrs, ngModel) {
          var dateFormat,
              closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
              appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
          scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
          scope.getText = function(key) {
            return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
          };
          var isHtml5DateInput = false;
          if (datepickerPopupConfig.html5Types[attrs.type]) {
            dateFormat = datepickerPopupConfig.html5Types[attrs.type];
            isHtml5DateInput = true;
          } else {
            dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
            attrs.$observe('datepickerPopup', function(value, oldValue) {
              var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
              if (newDateFormat !== dateFormat) {
                dateFormat = newDateFormat;
                ngModel.$modelValue = null;
                if (!dateFormat) {
                  throw new Error('datepickerPopup must have a date format specified.');
                }
              }
            });
          }
          if (!dateFormat) {
            throw new Error('datepickerPopup must have a date format specified.');
          }
          if (isHtml5DateInput && attrs.datepickerPopup) {
            throw new Error('HTML5 date input types do not support custom formats.');
          }
          var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
          popupEl.attr({
            'ng-model': 'date',
            'ng-change': 'dateSelection(date)'
          });
          function cameltoDash(string) {
            return string.replace(/([A-Z])/g, function($1) {
              return '-' + $1.toLowerCase();
            });
          }
          var datepickerEl = angular.element(popupEl.children()[0]);
          if (isHtml5DateInput) {
            if (attrs.type == 'month') {
              datepickerEl.attr('datepicker-mode', '"month"');
              datepickerEl.attr('min-mode', 'month');
            }
          }
          if (attrs.datepickerOptions) {
            var options = scope.$parent.$eval(attrs.datepickerOptions);
            if (options.initDate) {
              scope.initDate = options.initDate;
              datepickerEl.attr('init-date', 'initDate');
              delete options.initDate;
            }
            angular.forEach(options, function(value, option) {
              datepickerEl.attr(cameltoDash(option), value);
            });
          }
          scope.watchData = {};
          angular.forEach(['minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
            if (attrs[key]) {
              var getAttribute = $parse(attrs[key]);
              scope.$parent.$watch(getAttribute, function(value) {
                scope.watchData[key] = value;
              });
              datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
              if (key === 'datepickerMode') {
                var setAttribute = getAttribute.assign;
                scope.$watch('watchData.' + key, function(value, oldvalue) {
                  if (angular.isFunction(setAttribute) && value !== oldvalue) {
                    setAttribute(scope.$parent, value);
                  }
                });
              }
            }
          });
          if (attrs.dateDisabled) {
            datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
          }
          if (attrs.showWeeks) {
            datepickerEl.attr('show-weeks', attrs.showWeeks);
          }
          if (attrs.customClass) {
            datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
          }
          function parseDate(viewValue) {
            if (angular.isNumber(viewValue)) {
              viewValue = new Date(viewValue);
            }
            if (!viewValue) {
              return null;
            } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
              return viewValue;
            } else if (angular.isString(viewValue)) {
              var date = dateParser.parse(viewValue, dateFormat, scope.date) || new Date(viewValue);
              if (isNaN(date)) {
                return undefined;
              } else {
                return date;
              }
            } else {
              return undefined;
            }
          }
          function validator(modelValue, viewValue) {
            var value = modelValue || viewValue;
            if (angular.isNumber(value)) {
              value = new Date(value);
            }
            if (!value) {
              return true;
            } else if (angular.isDate(value) && !isNaN(value)) {
              return true;
            } else if (angular.isString(value)) {
              var date = dateParser.parse(value, dateFormat) || new Date(value);
              return !isNaN(date);
            } else {
              return false;
            }
          }
          if (!isHtml5DateInput) {
            ngModel.$$parserName = 'date';
            ngModel.$validators.date = validator;
            ngModel.$parsers.unshift(parseDate);
            ngModel.$formatters.push(function(value) {
              scope.date = value;
              return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
            });
          } else {
            ngModel.$formatters.push(function(value) {
              scope.date = value;
              return value;
            });
          }
          scope.dateSelection = function(dt) {
            if (angular.isDefined(dt)) {
              scope.date = dt;
            }
            var date = scope.date ? dateFilter(scope.date, dateFormat) : '';
            element.val(date);
            ngModel.$setViewValue(date);
            if (closeOnDateSelection) {
              scope.isOpen = false;
              element[0].focus();
            }
          };
          ngModel.$viewChangeListeners.push(function() {
            scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date) || new Date(ngModel.$viewValue);
          });
          var documentClickBind = function(event) {
            if (scope.isOpen && event.target !== element[0]) {
              scope.$apply(function() {
                scope.isOpen = false;
              });
            }
          };
          var inputKeydownBind = function(evt) {
            if (evt.which === 27 && scope.isOpen) {
              evt.preventDefault();
              evt.stopPropagation();
              scope.$apply(function() {
                scope.isOpen = false;
              });
              element[0].focus();
            } else if (evt.which === 40 && !scope.isOpen) {
              evt.preventDefault();
              evt.stopPropagation();
              scope.$apply(function() {
                scope.isOpen = true;
              });
            }
          };
          element.bind('keydown', inputKeydownBind);
          scope.keydown = function(evt) {
            if (evt.which === 27) {
              scope.isOpen = false;
              element[0].focus();
            }
          };
          scope.$watch('isOpen', function(value) {
            if (value) {
              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');
              $document.bind('click', documentClickBind);
              $timeout(function() {
                scope.$broadcast('datepicker.focus');
              }, 0, false);
            } else {
              $document.unbind('click', documentClickBind);
            }
          });
          scope.select = function(date) {
            if (date === 'today') {
              var today = new Date();
              if (angular.isDate(scope.date)) {
                date = new Date(scope.date);
                date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
              } else {
                date = new Date(today.setHours(0, 0, 0, 0));
              }
            }
            scope.dateSelection(date);
          };
          scope.close = function() {
            scope.isOpen = false;
            element[0].focus();
          };
          var $popup = $compile(popupEl)(scope);
          popupEl.remove();
          if (appendToBody) {
            $document.find('body').append($popup);
          } else {
            element.after($popup);
          }
          scope.$on('$destroy', function() {
            if (scope.isOpen === true) {
              scope.$apply(function() {
                scope.isOpen = false;
              });
            }
            $popup.remove();
            element.unbind('keydown', inputKeydownBind);
            $document.unbind('click', documentClickBind);
          });
        }
      };
    }]).directive('datepickerPopupWrap', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        templateUrl: 'template/datepicker/popup.html'
      };
    });
    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('dropdownConfig', {openClass: 'open'}).service('dropdownService', ['$document', '$rootScope', function($document, $rootScope) {
      var openScope = null;
      this.open = function(dropdownScope) {
        if (!openScope) {
          $document.bind('click', closeDropdown);
          $document.bind('keydown', keybindFilter);
        }
        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }
        openScope = dropdownScope;
      };
      this.close = function(dropdownScope) {
        if (openScope === dropdownScope) {
          openScope = null;
          $document.unbind('click', closeDropdown);
          $document.unbind('keydown', keybindFilter);
        }
      };
      var closeDropdown = function(evt) {
        if (!openScope) {
          return ;
        }
        if (evt && openScope.getAutoClose() === 'disabled') {
          return ;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return ;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
          return ;
        }
        openScope.isOpen = false;
        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };
      var keybindFilter = function(evt) {
        if (evt.which === 27) {
          openScope.focusToggleElement();
          closeDropdown();
        } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    }]).controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', '$position', '$document', '$compile', '$templateRequest', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document, $compile, $templateRequest) {
      var self = this,
          scope = $scope.$new(),
          templateScope,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          keynavEnabled = false,
          selectedOption = null;
      this.init = function(element) {
        self.$element = element;
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
          });
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);
        if (appendToBody && self.dropdownMenu) {
          $document.find('body').append(self.dropdownMenu);
          element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
      };
      this.isOpen = function() {
        return scope.isOpen;
      };
      scope.getToggleElement = function() {
        return self.toggleElement;
      };
      scope.getAutoClose = function() {
        return $attrs.autoClose || 'always';
      };
      scope.getElement = function() {
        return self.$element;
      };
      scope.isKeynavEnabled = function() {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? (angular.element(self.dropdownMenu).find('a')) : (angular.element(self.$element).find('ul').eq(0).find('a'));
        switch (keyCode) {
          case (40):
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = (self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1);
              }
              break;
            }
          case (38):
            {
              if (!angular.isNumber(self.selectedOption)) {
                return ;
              } else {
                self.selectedOption = (self.selectedOption === 0 ? 0 : self.selectedOption - 1);
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function() {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function() {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch('isOpen', function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
          var pos = $position.positionElements(self.$element, self.dropdownMenu, 'bottom-left', true);
          var css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };
          var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            css.right = (window.innerWidth - (pos.left + self.$element.prop('offsetWidth'))) + 'px';
          }
          self.dropdownMenu.css(css);
        }
        $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass).then(function() {
          if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
            toggleInvoker($scope, {open: !!isOpen});
          }
        });
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
              });
            });
          }
          scope.focusToggleElement();
          dropdownService.open(scope);
        } else {
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          dropdownService.close(scope);
          self.selectedOption = null;
        }
        setIsOpen($scope, isOpen);
      });
      $scope.$on('$locationChangeSuccess', function() {
        if (scope.getAutoClose() !== 'disabled') {
          scope.isOpen = false;
        }
      });
      $scope.$on('$destroy', function() {
        scope.$destroy();
      });
    }]).directive('dropdown', function() {
      return {
        controller: 'DropdownController',
        link: function(scope, element, attrs, dropdownCtrl) {
          dropdownCtrl.init(element);
          element.addClass('dropdown');
        }
      };
    }).directive('dropdownMenu', function() {
      return {
        restrict: 'AC',
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return ;
          }
          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }
          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }).directive('keyboardNav', function() {
      return {
        restrict: 'A',
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          element.bind('keydown', function(e) {
            if ([38, 40].indexOf(e.which) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              var elems = angular.element(element).find('a');
              switch (e.keyCode) {
                case (40):
                  {
                    if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                      dropdownCtrl.selectedOption = 0;
                    } else {
                      dropdownCtrl.selectedOption = (dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1);
                    }
                  }
                  break;
                case (38):
                  {
                    dropdownCtrl.selectedOption = (dropdownCtrl.selectedOption === 0 ? 0 : dropdownCtrl.selectedOption - 1);
                  }
                  break;
              }
              elems[dropdownCtrl.selectedOption].focus();
            }
          });
        }
      };
    }).directive('dropdownToggle', function() {
      return {
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return ;
          }
          element.addClass('dropdown-toggle');
          dropdownCtrl.toggleElement = element;
          var toggleDropdown = function(event) {
            event.preventDefault();
            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function() {
                dropdownCtrl.toggle();
              });
            }
          };
          element.bind('click', toggleDropdown);
          element.attr({
            'aria-haspopup': true,
            'aria-expanded': false
          });
          scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });
          scope.$on('$destroy', function() {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    });
    angular.module('ui.bootstrap.modal', []).factory('$$stackedMap', function() {
      return {createNew: function() {
          var stack = [];
          return {
            add: function(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function() {
              return stack[stack.length - 1];
            },
            remove: function(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function() {
              return stack.splice(stack.length - 1, 1)[0];
            },
            length: function() {
              return stack.length;
            }
          };
        }};
    }).directive('modalBackdrop', ['$animate', '$modalStack', function($animate, $modalStack) {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };
      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animate.addClass(element, attrs.modalInClass);
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            $animate.removeClass(element, attrs.modalInClass).then(done);
          });
        }
      }
    }]).directive('modalWindow', ['$modalStack', '$q', '$animate', function($modalStack, $q, $animate) {
      return {
        restrict: 'EA',
        scope: {index: '@'},
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value == 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            if (attrs.modalInClass) {
              $animate.addClass(element, attrs.modalInClass);
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                $animate.removeClass(element, attrs.modalInClass).then(done);
              });
            }
            var inputsWithAutofocus = element[0].querySelectorAll('[autofocus]');
            if (inputsWithAutofocus.length) {
              inputsWithAutofocus[0].focus();
            } else {
              element[0].focus();
            }
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }]).directive('modalAnimationClass', [function() {
      return {compile: function(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }};
    }]).directive('modalTransclude', function() {
      return {link: function($scope, $element, $attrs, controller, $transclude) {
          $transclude($scope.$parent, function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }};
    }).factory('$modalStack', ['$animate', '$timeout', '$document', '$compile', '$rootScope', '$q', '$$stackedMap', function($animate, $timeout, $document, $compile, $rootScope, $q, $$stackedMap) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl,
          backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {NOW_CLOSING_EVENT: 'modal.stack.now-closing'};
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
          checkRemoveBackdrop();
        });
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else {
          body.focus();
        }
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() == -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
          if (afterAnimating.done) {
            return ;
          }
          afterAnimating.done = true;
          domEl.remove();
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }
      $document.bind('keydown', function(evt) {
        var modal;
        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            evt.preventDefault();
            $rootScope.$apply(function() {
              $modalStack.dismiss(modal.key, 'escape key press');
            });
          }
        }
      });
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement;
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });
        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element('<div modal-backdrop="modal-backdrop"></div>');
          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr('modal-animation', 'true');
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }
        var angularDomEl = angular.element('<div modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(OPENED_MODAL_CLASS);
      };
      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      return $modalStack;
    }]).provider('$modal', function() {
      var $modalProvider = {
        options: {
          animation: true,
          backdrop: true,
          keyboard: true
        },
        $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$modalStack', function($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }
          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              var ctrlInstance,
                  ctrlLocals = {};
              var resolveIter = 1;
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function(value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });
                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                if (modalOptions.controllerAs) {
                  if (modalOptions.bindToController) {
                    angular.extend(modalScope, ctrlInstance);
                  } else {
                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size
              });
            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });
            templateAndResolvePromise.then(function() {
              modalOpenedDeferred.resolve(true);
            }, function(reason) {
              modalOpenedDeferred.reject(reason);
            });
            return modalInstance;
          };
          return $modal;
        }]
      };
      return $modalProvider;
    });
    angular.module('ui.bootstrap.pagination', []).controller('PaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop},
          setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_;
        this.config = config;
        ngModelCtrl.$render = function() {
          self.render();
        };
        if ($attrs.itemsPerPage) {
          $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = self.calculateTotalPages();
          });
        } else {
          this.itemsPerPage = config.itemsPerPage;
        }
        $scope.$watch('totalItems', function() {
          $scope.totalPages = self.calculateTotalPages();
        });
        $scope.$watch('totalPages', function(value) {
          setNumPages($scope.$parent, value);
          if ($scope.page > value) {
            $scope.selectPage(value);
          } else {
            ngModelCtrl.$render();
          }
        });
      };
      this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };
      this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
      };
      $scope.selectPage = function(page, evt) {
        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ngModelCtrl.$setViewValue(page);
          ngModelCtrl.$render();
        }
      };
      $scope.getText = function(key) {
        return $scope[key + 'Text'] || self.config[key + 'Text'];
      };
      $scope.noPrevious = function() {
        return $scope.page === 1;
      };
      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };
    }]).constant('paginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true
    }).directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['pagination', '?ngModel'],
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pagination.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return ;
          }
          var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
              rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
          scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
          scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
          paginationCtrl.init(ngModelCtrl, paginationConfig);
          if (attrs.maxSize) {
            scope.$parent.$watch($parse(attrs.maxSize), function(value) {
              maxSize = parseInt(value, 10);
              paginationCtrl.render();
            });
          }
          function makePage(number, text, isActive) {
            return {
              number: number,
              text: text,
              active: isActive
            };
          }
          function getPages(currentPage, totalPages) {
            var pages = [];
            var startPage = 1,
                endPage = totalPages;
            var isMaxSized = (angular.isDefined(maxSize) && maxSize < totalPages);
            if (isMaxSized) {
              if (rotate) {
                startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                endPage = startPage + maxSize - 1;
                if (endPage > totalPages) {
                  endPage = totalPages;
                  startPage = endPage - maxSize + 1;
                }
              } else {
                startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
                endPage = Math.min(startPage + maxSize - 1, totalPages);
              }
            }
            for (var number = startPage; number <= endPage; number++) {
              var page = makePage(number, number, number === currentPage);
              pages.push(page);
            }
            if (isMaxSized && !rotate) {
              if (startPage > 1) {
                var previousPageSet = makePage(startPage - 1, '...', false);
                pages.unshift(previousPageSet);
              }
              if (endPage < totalPages) {
                var nextPageSet = makePage(endPage + 1, '...', false);
                pages.push(nextPageSet);
              }
            }
            return pages;
          }
          var originalRender = paginationCtrl.render;
          paginationCtrl.render = function() {
            originalRender();
            if (scope.page > 0 && scope.page <= scope.totalPages) {
              scope.pages = getPages(scope.page, scope.totalPages);
            }
          };
        }
      };
    }]).constant('pagerConfig', {
      itemsPerPage: 10,
      previousText: '« Previous',
      nextText: 'Next »',
      align: true
    }).directive('pager', ['pagerConfig', function(pagerConfig) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@'
        },
        require: ['pager', '?ngModel'],
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pager.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return ;
          }
          scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
          paginationCtrl.init(ngModelCtrl, pagerConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml']).provider('$tooltip', function() {
      var defaultOptions = {
        placement: 'top',
        animation: true,
        popupDelay: 0,
        useContentExp: false
      };
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'focus': 'blur'
      };
      var globalOptions = {};
      this.options = function(value) {
        angular.extend(globalOptions, value);
      };
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      this.$get = ['$window', '$compile', '$timeout', '$document', '$position', '$interpolate', function($window, $compile, $timeout, $document, $position, $interpolate) {
        return function $tooltip(type, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);
          function getTriggers(trigger) {
            var show = trigger || options.trigger || defaultTriggerShow;
            var hide = triggerMap[show] || show;
            return {
              show: show,
              hide: hide
            };
          }
          var directiveName = snake_case(type);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'placement="' + startSym + 'placement' + endSym + '" ' + 'popup-class="' + startSym + 'popupClass' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + 'origin-scope="origScope" ' + '>' + '</div>';
          return {
            restrict: 'EA',
            compile: function(tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var popupTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var ttScope = scope.$new(true);
                var positionTooltip = function() {
                  if (!tooltip) {
                    return ;
                  }
                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  ttPosition.top += 'px';
                  ttPosition.left += 'px';
                  tooltip.css(ttPosition);
                };
                ttScope.origScope = scope;
                ttScope.isOpen = false;
                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return ;
                  }
                  prepareTooltip();
                  if (ttScope.popupDelay) {
                    if (!popupTimeout) {
                      popupTimeout = $timeout(show, ttScope.popupDelay, false);
                      popupTimeout.then(function(reposition) {
                        reposition();
                      });
                    }
                  } else {
                    show()();
                  }
                }
                function hideTooltipBind() {
                  scope.$apply(function() {
                    hide();
                  });
                }
                function show() {
                  popupTimeout = null;
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                  if (!(options.useContentExp ? ttScope.contentExp() : ttScope.content)) {
                    return angular.noop;
                  }
                  createTooltip();
                  tooltip.css({
                    top: 0,
                    left: 0,
                    display: 'block'
                  });
                  ttScope.$digest();
                  positionTooltip();
                  ttScope.isOpen = true;
                  ttScope.$apply();
                  return positionTooltip;
                }
                function hide() {
                  ttScope.isOpen = false;
                  $timeout.cancel(popupTimeout);
                  popupTimeout = null;
                  if (ttScope.animation) {
                    if (!transitionTimeout) {
                      transitionTimeout = $timeout(removeTooltip, 500);
                    }
                  } else {
                    removeTooltip();
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    removeTooltip();
                  }
                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                    if (appendToBody) {
                      $document.find('body').append(tooltip);
                    } else {
                      element.after(tooltip);
                    }
                  });
                  tooltipLinkedScope.$watch(function() {
                    $timeout(positionTooltip, 0, false);
                  });
                  if (options.useContentExp) {
                    tooltipLinkedScope.$watch('contentExp()', function(val) {
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    });
                  }
                }
                function removeTooltip() {
                  transitionTimeout = null;
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }
                function prepareTooltip() {
                  prepPopupClass();
                  prepPlacement();
                  prepPopupDelay();
                }
                ttScope.contentExp = function() {
                  return scope.$eval(attrs[type]);
                };
                if (!options.useContentExp) {
                  attrs.$observe(type, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  });
                }
                attrs.$observe('disabled', function(val) {
                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                });
                function prepPopupClass() {
                  ttScope.popupClass = attrs[prefix + 'Class'];
                }
                function prepPlacement() {
                  var val = attrs[prefix + 'Placement'];
                  ttScope.placement = angular.isDefined(val) ? val : options.placement;
                }
                function prepPopupDelay() {
                  var val = attrs[prefix + 'PopupDelay'];
                  var delay = parseInt(val, 10);
                  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                }
                var unregisterTriggers = function() {
                  element.unbind(triggers.show, showTooltipBind);
                  element.unbind(triggers.hide, hideTooltipBind);
                };
                function prepTriggers() {
                  var val = attrs[prefix + 'Trigger'];
                  unregisterTriggers();
                  triggers = getTriggers(val);
                  if (triggers.show === triggers.hide) {
                    element.bind(triggers.show, toggleTooltipBind);
                  } else {
                    element.bind(triggers.show, showTooltipBind);
                    element.bind(triggers.hide, hideTooltipBind);
                  }
                }
                prepTriggers();
                var animation = scope.$eval(attrs[prefix + 'Animation']);
                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                if (appendToBody) {
                  scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                    if (ttScope.isOpen) {
                      hide();
                    }
                  });
                }
                scope.$on('$destroy', function onDestroyTooltip() {
                  $timeout.cancel(transitionTimeout);
                  $timeout.cancel(popupTimeout);
                  unregisterTriggers();
                  removeTooltip();
                  ttScope = null;
                });
              };
            }
          };
        };
      }];
    }).directive('tooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function($animate, $sce, $compile, $templateRequest) {
      return {link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return ;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }};
    }]).directive('tooltipClasses', function() {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          if (scope.placement) {
            element.addClass(scope.placement);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation()) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }).directive('tooltipPopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-popup.html'
      };
    }).directive('tooltip', ['$tooltip', function($tooltip) {
      return $tooltip('tooltip', 'tooltip', 'mouseenter');
    }]).directive('tooltipTemplatePopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/tooltip/tooltip-template-popup.html'
      };
    }).directive('tooltipTemplate', ['$tooltip', function($tooltip) {
      return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('tooltipHtmlPopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-html-popup.html'
      };
    }).directive('tooltipHtml', ['$tooltip', function($tooltip) {
      return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('tooltipHtmlUnsafePopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
      };
    }).value('tooltipHtmlUnsafeSuppressDeprecated', false).directive('tooltipHtmlUnsafe', ['$tooltip', 'tooltipHtmlUnsafeSuppressDeprecated', '$log', function($tooltip, tooltipHtmlUnsafeSuppressDeprecated, $log) {
      if (!tooltipHtmlUnsafeSuppressDeprecated) {
        $log.warn('tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.');
      }
      return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
    }]);
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('popoverTemplatePopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          title: '@',
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/popover/popover-template.html'
      };
    }).directive('popoverTemplate', ['$tooltip', function($tooltip) {
      return $tooltip('popoverTemplate', 'popover', 'click', {useContentExp: true});
    }]).directive('popoverPopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          title: '@',
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover.html'
      };
    }).directive('popover', ['$tooltip', function($tooltip) {
      return $tooltip('popover', 'popover', 'click');
    }]);
    angular.module('ui.bootstrap.progressbar', []).constant('progressConfig', {
      animate: true,
      max: 100
    }).controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.bars = [];
      $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
      this.addBar = function(bar, element) {
        if (!animate) {
          element.css({'transition': 'none'});
        }
        this.bars.push(bar);
        bar.max = $scope.max;
        bar.$watch('value', function(value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
          bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        };
        bar.$on('$destroy', function() {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
      };
      $scope.$watch('max', function(max) {
        self.bars.forEach(function(bar) {
          bar.max = $scope.max;
          bar.recalculatePercentage();
        });
      });
    }]).directive('progress', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {max: '=?'},
        templateUrl: 'template/progressbar/progress.html'
      };
    }).directive('bar', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element);
        }
      };
    }).directive('progressbar', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
          value: '=',
          max: '=?',
          type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
      };
    });
    angular.module('ui.bootstrap.rating', []).constant('ratingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null
    }).controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {
      var ngModelCtrl = {$setViewValue: angular.noop};
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function(value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }
          return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
      };
      this.buildTemplateObjects = function(states) {
        for (var i = 0,
            n = states.length; i < n; i++) {
          states[i] = angular.extend({index: i}, {
            stateOn: this.stateOn,
            stateOff: this.stateOff
          }, states[i]);
        }
        return states;
      };
      $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
          ngModelCtrl.$render();
        }
      };
      $scope.enter = function(value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({value: value});
      };
      $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };
      $scope.onKeydown = function(evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
      };
      this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
      };
    }]).directive('rating', function() {
      return {
        restrict: 'EA',
        require: ['rating', 'ngModel'],
        scope: {
          readonly: '=?',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'RatingController',
        templateUrl: 'template/rating/rating.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    });
    angular.module('ui.bootstrap.tabs', []).controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
      var ctrl = this,
          tabs = ctrl.tabs = $scope.tabs = [];
      ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
          if (tab.active && tab !== selectedTab) {
            tab.active = false;
            tab.onDeselect();
          }
        });
        selectedTab.active = true;
        selectedTab.onSelect();
      };
      ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if (tabs.length === 1 && tab.active !== false) {
          tab.active = true;
        } else if (tab.active) {
          ctrl.select(tab);
        } else {
          tab.active = false;
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1 && !destroyed) {
          var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
          ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
      };
      var destroyed;
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
    }]).directive('tabset', function() {
      return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        scope: {type: '@'},
        controller: 'TabsetController',
        templateUrl: 'template/tabs/tabset.html',
        link: function(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
      };
    }).directive('tab', ['$parse', '$log', function($parse, $log) {
      return {
        require: '^tabset',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
          active: '=?',
          heading: '@',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
          return function postLink(scope, elm, attrs, tabsetCtrl) {
            scope.$watch('active', function(active) {
              if (active) {
                tabsetCtrl.select(scope);
              }
            });
            scope.disabled = false;
            if (attrs.disable) {
              scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
              });
            }
            if (attrs.disabled) {
              $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
              scope.$parent.$watch($parse(attrs.disabled), function(value) {
                scope.disabled = !!value;
              });
            }
            scope.select = function() {
              if (!scope.disabled) {
                scope.active = true;
              }
            };
            tabsetCtrl.addTab(scope);
            scope.$on('$destroy', function() {
              tabsetCtrl.removeTab(scope);
            });
            scope.$transcludeFn = transclude;
          };
        }
      };
    }]).directive('tabHeadingTransclude', [function() {
      return {
        restrict: 'A',
        require: '^tab',
        link: function(scope, elm, attrs, tabCtrl) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }]).directive('tabContentTransclude', function() {
      return {
        restrict: 'A',
        require: '^tabset',
        link: function(scope, elm, attrs) {
          var tab = scope.$eval(attrs.tabContentTransclude);
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading');
      }
    });
    ;
    angular.module('ui.bootstrap.timepicker', []).constant('timepickerConfig', {
      hourStep: 1,
      minuteStep: 1,
      showMeridian: true,
      meridians: null,
      readonlyInput: false,
      mousewheel: true,
      arrowkeys: true,
      showSpinners: true
    }).controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
      var selected = new Date(),
          ngModelCtrl = {$setViewValue: angular.noop},
          meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
      this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function(modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1);
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
          this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl);
      };
      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
          hourStep = parseInt(value, 10);
        });
      }
      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
          minuteStep = parseInt(value, 10);
        });
      }
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
          $scope.showMeridian = !!value;
          if (ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
              selected.setHours(hours);
              refresh();
            }
          } else {
            updateTemplate();
          }
        });
      }
      function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10);
        var valid = ($scope.showMeridian) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
        if (!valid) {
          return undefined;
        }
        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }
      function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return (minutes >= 0 && minutes < 60) ? minutes : undefined;
      }
      function pad(value) {
        return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
      }
      this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
          return (e.detail || delta > 0);
        };
        hoursInputEl.bind('mousewheel wheel', function(e) {
          $scope.$apply((isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours());
          e.preventDefault();
        });
        minutesInputEl.bind('mousewheel wheel', function(e) {
          $scope.$apply((isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes());
          e.preventDefault();
        });
      };
      this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
        hoursInputEl.bind('keydown', function(e) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementHours();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementHours();
            $scope.$apply();
          }
        });
        minutesInputEl.bind('keydown', function(e) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementMinutes();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementMinutes();
            $scope.$apply();
          }
        });
      };
      this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          return ;
        }
        var invalidate = function(invalidHours, invalidMinutes) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
          }
        };
        $scope.updateHours = function() {
          var hours = getHoursFromTemplate();
          if (angular.isDefined(hours)) {
            selected.setHours(hours);
            refresh('h');
          } else {
            invalidate(true);
          }
        };
        hoursInputEl.bind('blur', function(e) {
          if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function() {
              $scope.hours = pad($scope.hours);
            });
          }
        });
        $scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate();
          if (angular.isDefined(minutes)) {
            selected.setMinutes(minutes);
            refresh('m');
          } else {
            invalidate(undefined, true);
          }
        };
        minutesInputEl.bind('blur', function(e) {
          if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function() {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });
      };
      this.render = function() {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
          ngModelCtrl.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if (date) {
            selected = date;
          }
          makeValid();
          updateTemplate();
        }
      };
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }
      function makeValid() {
        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
      }
      function updateTemplate(keyboardChange) {
        var hours = selected.getHours(),
            minutes = selected.getMinutes();
        if ($scope.showMeridian) {
          hours = (hours === 0 || hours === 12) ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
        if (keyboardChange !== 'm') {
          $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }
      function addMinutes(minutes) {
        var dt = new Date(selected.getTime() + minutes * 60000);
        selected.setHours(dt.getHours(), dt.getMinutes());
        refresh();
      }
      $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
      $scope.incrementHours = function() {
        addMinutes(hourStep * 60);
      };
      $scope.decrementHours = function() {
        addMinutes(-hourStep * 60);
      };
      $scope.incrementMinutes = function() {
        addMinutes(minuteStep);
      };
      $scope.decrementMinutes = function() {
        addMinutes(-minuteStep);
      };
      $scope.toggleMeridian = function() {
        addMinutes(12 * 60 * ((selected.getHours() < 12) ? 1 : -1));
      };
    }]).directive('timepicker', function() {
      return {
        restrict: 'EA',
        require: ['timepicker', '?^ngModel'],
        controller: 'TimepickerController',
        replace: true,
        scope: {},
        templateUrl: 'template/timepicker/timepicker.html',
        link: function(scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    });
    angular.module('ui.bootstrap.transition', []).value('$transitionSuppressDeprecated', false).factory('$transition', ['$q', '$timeout', '$rootScope', '$log', '$transitionSuppressDeprecated', function($q, $timeout, $rootScope, $log, $transitionSuppressDeprecated) {
      if (!$transitionSuppressDeprecated) {
        $log.warn('$transition is now deprecated. Use $animate from ngAnimate instead.');
      }
      var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer();
        var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];
        var transitionEndHandler = function(event) {
          $rootScope.$apply(function() {
            element.unbind(endEventName, transitionEndHandler);
            deferred.resolve(element);
          });
        };
        if (endEventName) {
          element.bind(endEventName, transitionEndHandler);
        }
        $timeout(function() {
          if (angular.isString(trigger)) {
            element.addClass(trigger);
          } else if (angular.isFunction(trigger)) {
            trigger(element);
          } else if (angular.isObject(trigger)) {
            element.css(trigger);
          }
          if (!endEventName) {
            deferred.resolve(element);
          }
        });
        deferred.promise.cancel = function() {
          if (endEventName) {
            element.unbind(endEventName, transitionEndHandler);
          }
          deferred.reject('Transition cancelled');
        };
        return deferred.promise;
      };
      var transElement = document.createElement('trans');
      var transitionEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'transition': 'transitionend'
      };
      var animationEndEventNames = {
        'WebkitTransition': 'webkitAnimationEnd',
        'MozTransition': 'animationend',
        'OTransition': 'oAnimationEnd',
        'transition': 'animationend'
      };
      function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
          if (transElement.style[name] !== undefined) {
            return endEventNames[name];
          }
        }
      }
      $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
      $transition.animationEndEventName = findEndEventName(animationEndEventNames);
      return $transition;
    }]);
    angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml']).factory('typeaheadParser', ['$parse', function($parse) {
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {parse: function(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }};
    }]).directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$position', 'typeaheadParser', function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      return {
        require: 'ngModel',
        link: function(originalScope, element, attrs, modelCtrl) {
          var minLength = originalScope.$eval(attrs.typeaheadMinLength);
          if (!minLength && minLength !== 0) {
            minLength = 1;
          }
          var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
          var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
          var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
          var onSelectCallback = $parse(attrs.typeaheadOnSelect);
          var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
          var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
          var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
          var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
          var $setModelValue = $parse(attrs.ngModel).assign;
          var parserResult = typeaheadParser.parse(attrs.typeahead);
          var hasFocus;
          var selected;
          var scope = originalScope.$new();
          originalScope.$on('$destroy', function() {
            scope.$destroy();
          });
          var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
          element.attr({
            'aria-autocomplete': 'list',
            'aria-expanded': false,
            'aria-owns': popupId
          });
          var popUpEl = angular.element('<div typeahead-popup></div>');
          popUpEl.attr({
            id: popupId,
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx)',
            'move-in-progress': 'moveInProgress',
            query: 'query',
            position: 'position'
          });
          if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
          }
          var resetMatches = function() {
            scope.matches = [];
            scope.activeIdx = -1;
            element.attr('aria-expanded', false);
          };
          var getMatchId = function(index) {
            return popupId + '-option-' + index;
          };
          scope.$watch('activeIdx', function(index) {
            if (index < 0) {
              element.removeAttr('aria-activedescendant');
            } else {
              element.attr('aria-activedescendant', getMatchId(index));
            }
          });
          var getMatchesAsync = function(inputValue) {
            var locals = {$viewValue: inputValue};
            isLoadingSetter(originalScope, true);
            $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
              var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
              if (onCurrentRequest && hasFocus) {
                if (matches && matches.length > 0) {
                  scope.activeIdx = focusFirst ? 0 : -1;
                  scope.matches.length = 0;
                  for (var i = 0; i < matches.length; i++) {
                    locals[parserResult.itemName] = matches[i];
                    scope.matches.push({
                      id: getMatchId(i),
                      label: parserResult.viewMapper(scope, locals),
                      model: matches[i]
                    });
                  }
                  scope.query = inputValue;
                  recalculatePosition();
                  element.attr('aria-expanded', true);
                } else {
                  resetMatches();
                }
              }
              if (onCurrentRequest) {
                isLoadingSetter(originalScope, false);
              }
            }, function() {
              resetMatches();
              isLoadingSetter(originalScope, false);
            });
          };
          if (appendToBody) {
            angular.element($window).bind('resize', fireRecalculating);
            $document.find('body').bind('scroll', fireRecalculating);
          }
          var timeoutEventPromise;
          scope.moveInProgress = false;
          function fireRecalculating() {
            if (!scope.moveInProgress) {
              scope.moveInProgress = true;
              scope.$digest();
            }
            if (timeoutEventPromise) {
              $timeout.cancel(timeoutEventPromise);
            }
            timeoutEventPromise = $timeout(function() {
              if (scope.matches.length) {
                recalculatePosition();
              }
              scope.moveInProgress = false;
              scope.$digest();
            }, eventDebounceTime);
          }
          function recalculatePosition() {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top += element.prop('offsetHeight');
          }
          resetMatches();
          scope.query = undefined;
          var timeoutPromise;
          var scheduleSearchWithTimeout = function(inputValue) {
            timeoutPromise = $timeout(function() {
              getMatchesAsync(inputValue);
            }, waitTime);
          };
          var cancelPreviousTimeout = function() {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);
            }
          };
          modelCtrl.$parsers.unshift(function(inputValue) {
            hasFocus = true;
            if (minLength === 0 || inputValue && inputValue.length >= minLength) {
              if (waitTime > 0) {
                cancelPreviousTimeout();
                scheduleSearchWithTimeout(inputValue);
              } else {
                getMatchesAsync(inputValue);
              }
            } else {
              isLoadingSetter(originalScope, false);
              cancelPreviousTimeout();
              resetMatches();
            }
            if (isEditable) {
              return inputValue;
            } else {
              if (!inputValue) {
                modelCtrl.$setValidity('editable', true);
                return inputValue;
              } else {
                modelCtrl.$setValidity('editable', false);
                return undefined;
              }
            }
          });
          modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue,
                emptyViewValue;
            var locals = {};
            if (!isEditable) {
              modelCtrl.$setValidity('editable', true);
            }
            if (inputFormatter) {
              locals.$model = modelValue;
              return inputFormatter(originalScope, locals);
            } else {
              locals[parserResult.itemName] = modelValue;
              candidateViewValue = parserResult.viewMapper(originalScope, locals);
              locals[parserResult.itemName] = undefined;
              emptyViewValue = parserResult.viewMapper(originalScope, locals);
              return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            }
          });
          scope.select = function(activeIdx) {
            var locals = {};
            var model,
                item;
            selected = true;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
            onSelectCallback(originalScope, {
              $item: item,
              $model: model,
              $label: parserResult.viewMapper(originalScope, locals)
            });
            resetMatches();
            $timeout(function() {
              element[0].focus();
            }, 0, false);
          };
          element.bind('keydown', function(evt) {
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
              return ;
            }
            if (scope.activeIdx === -1 && evt.which === 13) {
              return ;
            }
            if (scope.activeIdx === -1 && evt.which === 9) {
              resetMatches();
              scope.$digest();
              return ;
            }
            evt.preventDefault();
            if (evt.which === 40) {
              scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
              scope.$digest();
            } else if (evt.which === 38) {
              scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
              scope.$digest();
            } else if (evt.which === 13 || evt.which === 9) {
              scope.$apply(function() {
                scope.select(scope.activeIdx);
              });
            } else if (evt.which === 27) {
              evt.stopPropagation();
              resetMatches();
              scope.$digest();
            }
          });
          element.bind('blur', function() {
            if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
              selected = true;
              scope.$apply(function() {
                scope.select(scope.activeIdx);
              });
            }
            hasFocus = false;
            selected = false;
          });
          var dismissClickHandler = function(evt) {
            if (element[0] !== evt.target && evt.which !== 3) {
              resetMatches();
              if (!$rootScope.$$phase) {
                scope.$digest();
              }
            }
          };
          $document.bind('click', dismissClickHandler);
          originalScope.$on('$destroy', function() {
            $document.unbind('click', dismissClickHandler);
            if (appendToBody) {
              $popup.remove();
            }
            popUpEl.remove();
          });
          var $popup = $compile(popUpEl)(scope);
          if (appendToBody) {
            $document.find('body').append($popup);
          } else {
            element.after($popup);
          }
        }
      };
    }]).directive('typeaheadPopup', function() {
      return {
        restrict: 'EA',
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&'
        },
        replace: true,
        templateUrl: 'template/typeahead/typeahead-popup.html',
        link: function(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            return scope.matches.length > 0;
          };
          scope.isActive = function(matchIdx) {
            return scope.active == matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx) {
            scope.select({activeIdx: activeIdx});
          };
        }
      };
    }).directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
      return {
        restrict: 'EA',
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function(tplContent) {
            $compile(tplContent.trim())(scope, function(clonedElement) {
              element.replaceWith(clonedElement);
            });
          });
        }
      };
    }]).filter('typeaheadHighlight', function() {
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      return function(matchItem, query) {
        return query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
      };
    });
    angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion-group.html", "<div class=\"panel panel-default\">\n" + "  <div class=\"panel-heading\">\n" + "    <h4 class=\"panel-title\">\n" + "      <a href=\"#\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"$event.preventDefault(); toggleOpen()\" accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "    </h4>\n" + "  </div>\n" + "  <div class=\"panel-collapse collapse\" collapse=\"!isOpen\">\n" + "	  <div class=\"panel-body\" ng-transclude></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion.html", "<div class=\"panel-group\" ng-transclude></div>");
    }]);
    angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" + "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close($event)\">\n" + "        <span aria-hidden=\"true\">&times;</span>\n" + "        <span class=\"sr-only\">Close</span>\n" + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/carousel/carousel.html", "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" + "    <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "        <li ng-repeat=\"slide in slides | orderBy:'index' track by $index\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" + "    </ol>\n" + "    <div class=\"carousel-inner\" ng-transclude></div>\n" + "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a>\n" + "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a>\n" + "</div>\n" + "");
    }]);
    angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/carousel/slide.html", "<div ng-class=\"{\n" + "    'active': active\n" + "  }\" class=\"item text-center\" ng-transclude></div>\n" + "");
    }]);
    angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" + "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" + "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" + "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" + "</div>");
    }]);
    angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/popup.html", "<ul class=\"dropdown-menu\" ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "	<li ng-transclude></li>\n" + "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" + "		<span class=\"btn-group pull-left\">\n" + "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\">{{ getText('current') }}</button>\n" + "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" + "		</span>\n" + "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" + "	</li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/backdrop.html", "<div class=\"modal-backdrop\"\n" + "     modal-animation-class=\"fade\"\n" + "     modal-in-class=\"in\"\n" + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
    }]);
    angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/window.html", "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" + "    modal-animation-class=\"fade\"\n" + "    modal-in-class=\"in\"\n" + "	ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" + "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" modal-transclude></div></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pager.html", "<ul class=\"pager\">\n" + "  <li ng-class=\"{disabled: noPrevious(), previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-class=\"{disabled: noNext(), next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "</ul>");
    }]);
    angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pagination.html", "<ul class=\"pagination\">\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\"\n" + "    tooltip-template-transclude=\"contentExp()\"\n" + "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover-template.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" + "      <div class=\"popover-content\"\n" + "        tooltip-template-transclude=\"contentExp()\"\n" + "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" + "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n" + "");
    }]);
    angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progress.html", "<div class=\"progress\" ng-transclude></div>");
    }]);
    angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" + "    <i ng-repeat=\"r in range track by $index\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\">\n" + "        <span class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    </i>\n" + "</span>");
    }]);
    angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tab.html", "<li ng-class=\"{active: active, disabled: disabled}\">\n" + "  <a href=\"#\" ng-click=\"$event.preventDefault(); select()\" tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
    }]);
    angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\" \n" + "         ng-repeat=\"tab in tabs\" \n" + "         ng-class=\"{active: tab.active}\"\n" + "         tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/timepicker/timepicker.html", "<table>\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" + "      </td>\n" + "      <td>:</td>\n" + "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-match.html", "<a href=\"#\" ng-click=\"$event.preventDefault()\" tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>\n" + "");
    }]);
    angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
    !angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular-ui/bootstrap-bower@0.13.1/index", ["github:angular-ui/bootstrap-bower@0.13.1/ui-bootstrap-tpls"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("github:angular-ui/bootstrap-bower@0.13.1/ui-bootstrap-tpls");
  module.exports = 'ui.bootstrap';
  global.define = __define;
  return module.exports;
});

System.register("github:angular-ui/bootstrap-bower@0.13.1", ["github:angular-ui/bootstrap-bower@0.13.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular-ui/bootstrap-bower@0.13.1/index");
  global.define = __define;
  return module.exports;
});

System.register("github:angular/bower-angular-cookies@1.4.4/angular-cookies", ["github:angular/bower-angular@1.4.4"], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, ["github:angular/bower-angular@1.4.4"]);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      angular.module('ngCookies', ['ng']).provider('$cookies', [function $CookiesProvider() {
        var defaults = this.defaults = {};
        function calcOptions(options) {
          return options ? angular.extend({}, defaults, options) : defaults;
        }
        this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
          return {
            get: function(key) {
              return $$cookieReader()[key];
            },
            getObject: function(key) {
              var value = this.get(key);
              return value ? angular.fromJson(value) : value;
            },
            getAll: function() {
              return $$cookieReader();
            },
            put: function(key, value, options) {
              $$cookieWriter(key, value, calcOptions(options));
            },
            putObject: function(key, value, options) {
              this.put(key, angular.toJson(value), options);
            },
            remove: function(key, options) {
              $$cookieWriter(key, undefined, calcOptions(options));
            }
          };
        }];
      }]);
      angular.module('ngCookies').factory('$cookieStore', ['$cookies', function($cookies) {
        return {
          get: function(key) {
            return $cookies.getObject(key);
          },
          put: function(key, value) {
            $cookies.putObject(key, value);
          },
          remove: function(key) {
            $cookies.remove(key);
          }
        };
      }]);
      function $$CookieWriter($document, $log, $browser) {
        var cookiePath = $browser.baseHref();
        var rawDocument = $document[0];
        function buildCookieString(name, value, options) {
          var path,
              expires;
          options = options || {};
          expires = options.expires;
          path = angular.isDefined(options.path) ? options.path : cookiePath;
          if (value === undefined) {
            expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
            value = '';
          }
          if (angular.isString(expires)) {
            expires = new Date(expires);
          }
          var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
          str += path ? ';path=' + path : '';
          str += options.domain ? ';domain=' + options.domain : '';
          str += expires ? ';expires=' + expires.toUTCString() : '';
          str += options.secure ? ';secure' : '';
          var cookieLength = str.length + 1;
          if (cookieLength > 4096) {
            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
          }
          return str;
        }
        return function(name, value, options) {
          rawDocument.cookie = buildCookieString(name, value, options);
        };
      }
      $$CookieWriter.$inject = ['$document', '$log', '$browser'];
      angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
        this.$get = $$CookieWriter;
      });
    })(window, window.angular);
  }).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("github:angular/bower-angular-cookies@1.4.4", ["github:angular/bower-angular-cookies@1.4.4/angular-cookies"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:angular/bower-angular-cookies@1.4.4/angular-cookies");
  global.define = __define;
  return module.exports;
});
